
QAMGen.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004402  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000002be  00802000  00004402  00004496  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000d91  008022be  008022be  00004754  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004754  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004784  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007d8  00000000  00000000  000047c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001027b  00000000  00000000  00004f9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000051a5  00000000  00000000  00015217  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000055b8  00000000  00000000  0001a3bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000019c0  00000000  00000000  0001f974  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000071e1  00000000  00000000  00021334  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000094ff  00000000  00000000  00028515  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000868  00000000  00000000  00031a14  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 20 01 	jmp	0x240	; 0x240 <__ctors_end>
       4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
       8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
       c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      10:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      14:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      18:	0c 94 80 1e 	jmp	0x3d00	; 0x3d00 <__vector_6>
      1c:	0c 94 af 1e 	jmp	0x3d5e	; 0x3d5e <__vector_7>
      20:	0c 94 de 1e 	jmp	0x3dbc	; 0x3dbc <__vector_8>
      24:	0c 94 0d 1f 	jmp	0x3e1a	; 0x3e1a <__vector_9>
      28:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      2c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      30:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      34:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      38:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <__vector_14>
      3c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      40:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      44:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      48:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      4c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      50:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      54:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      58:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      5c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      60:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      64:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      68:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      6c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      70:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      74:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      78:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      7c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      80:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      84:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      88:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      8c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      90:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      94:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      98:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      9c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      a0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      a4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      a8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      ac:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      b0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      b4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      b8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      bc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      c0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      c4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      c8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      cc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      d0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      d4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      d8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      dc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      e0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      e4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      e8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      ec:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      f0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      f4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      f8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      fc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     100:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     104:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     108:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     10c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     110:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     114:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     118:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     11c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     120:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     124:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     128:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     12c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     130:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     134:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     138:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     13c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     140:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     144:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     148:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     14c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     150:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     154:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     158:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     15c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     160:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     164:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     168:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     16c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     170:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     174:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     178:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     17c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     180:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     184:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     188:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     18c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     190:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     194:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     198:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     19c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1a0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1a4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1a8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1ac:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1b0:	0c 94 4c 15 	jmp	0x2a98	; 0x2a98 <__vector_108>
     1b4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1b8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1bc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1c0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1c4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1c8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1cc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1d0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1d4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1d8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1dc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1e0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1e4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1e8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1ec:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1f0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1f4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1f8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1fc:	98 12       	cpse	r9, r24
     1fe:	98 12       	cpse	r9, r24
     200:	98 12       	cpse	r9, r24
     202:	e5 12       	cpse	r14, r21
     204:	cd 12       	cpse	r12, r29
     206:	e2 12       	cpse	r14, r18
     208:	98 12       	cpse	r9, r24
     20a:	98 12       	cpse	r9, r24
     20c:	e5 12       	cpse	r14, r21
     20e:	cd 12       	cpse	r12, r29

00000210 <__trampolines_start>:
     210:	0c 94 a4 14 	jmp	0x2948	; 0x2948 <vButtonTask>
     214:	0c 94 e5 12 	jmp	0x25ca	; 0x25ca <prvTimerTask+0x212>
     218:	0c 94 12 04 	jmp	0x824	; 0x824 <vEventGroupSetBitsCallback>
     21c:	0c 94 77 1b 	jmp	0x36ee	; 0x36ee <vsendFrame>
     220:	0c 94 dc 11 	jmp	0x23b8	; 0x23b8 <prvTimerTask>
     224:	0c 94 cd 12 	jmp	0x259a	; 0x259a <prvTimerTask+0x1e2>
     228:	0c 94 e2 12 	jmp	0x25c4	; 0x25c4 <prvTimerTask+0x20c>
     22c:	0c 94 7a 1d 	jmp	0x3af4	; 0x3af4 <vQuamGen>
     230:	0c 94 eb 16 	jmp	0x2dd6	; 0x2dd6 <vDisplayUpdateTask>
     234:	0c 94 98 12 	jmp	0x2530	; 0x2530 <prvTimerTask+0x178>
     238:	0c 94 69 13 	jmp	0x26d2	; 0x26d2 <vSteuertask>
     23c:	0c 94 3c 0a 	jmp	0x1478	; 0x1478 <prvIdleTask>

00000240 <__ctors_end>:
     240:	11 24       	eor	r1, r1
     242:	1f be       	out	0x3f, r1	; 63
     244:	cf ef       	ldi	r28, 0xFF	; 255
     246:	cd bf       	out	0x3d, r28	; 61
     248:	df e3       	ldi	r29, 0x3F	; 63
     24a:	de bf       	out	0x3e, r29	; 62
     24c:	00 e0       	ldi	r16, 0x00	; 0
     24e:	0c bf       	out	0x3c, r16	; 60

00000250 <init_mem>:
// !!! Never call this function, it is part of .init-Code
void __attribute__ ((naked, section(".init3"))) init_mem (void);
void init_mem (void)
{
   //  Use inline assembler so it works even with optimization turned off
   __asm volatile (
     250:	ef e4       	ldi	r30, 0x4F	; 79
     252:	f0 e3       	ldi	r31, 0x30	; 48
     254:	8a ea       	ldi	r24, 0xAA	; 170
     256:	90 e4       	ldi	r25, 0x40	; 64
     258:	81 93       	st	Z+, r24
     25a:	e0 30       	cpi	r30, 0x00	; 0
     25c:	f9 07       	cpc	r31, r25
     25e:	e0 f3       	brcs	.-8      	; 0x258 <init_mem+0x8>

00000260 <__do_copy_data>:
     260:	12 e2       	ldi	r17, 0x22	; 34
     262:	a0 e0       	ldi	r26, 0x00	; 0
     264:	b0 e2       	ldi	r27, 0x20	; 32
     266:	e2 e0       	ldi	r30, 0x02	; 2
     268:	f4 e4       	ldi	r31, 0x44	; 68
     26a:	00 e0       	ldi	r16, 0x00	; 0
     26c:	0b bf       	out	0x3b, r16	; 59
     26e:	02 c0       	rjmp	.+4      	; 0x274 <__do_copy_data+0x14>
     270:	07 90       	elpm	r0, Z+
     272:	0d 92       	st	X+, r0
     274:	ae 3b       	cpi	r26, 0xBE	; 190
     276:	b1 07       	cpc	r27, r17
     278:	d9 f7       	brne	.-10     	; 0x270 <__do_copy_data+0x10>

0000027a <__do_clear_bss>:
     27a:	20 e3       	ldi	r18, 0x30	; 48
     27c:	ae eb       	ldi	r26, 0xBE	; 190
     27e:	b2 e2       	ldi	r27, 0x22	; 34
     280:	01 c0       	rjmp	.+2      	; 0x284 <.do_clear_bss_start>

00000282 <.do_clear_bss_loop>:
     282:	1d 92       	st	X+, r1

00000284 <.do_clear_bss_start>:
     284:	af 34       	cpi	r26, 0x4F	; 79
     286:	b2 07       	cpc	r27, r18
     288:	e1 f7       	brne	.-8      	; 0x282 <.do_clear_bss_loop>
     28a:	0e 94 f8 14 	call	0x29f0	; 0x29f0 <main>
     28e:	0c 94 ff 21 	jmp	0x43fe	; 0x43fe <_exit>

00000292 <__bad_interrupt>:
     292:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000296 <initButtons>:
 #define BUTTON_PRESS_LONG			500

 

 void initButtons(void) {
	PORTF.DIRCLR = PIN4_bm; //SW1
     296:	e0 ea       	ldi	r30, 0xA0	; 160
     298:	f6 e0       	ldi	r31, 0x06	; 6
     29a:	80 e1       	ldi	r24, 0x10	; 16
     29c:	82 83       	std	Z+2, r24	; 0x02
	PORTF.DIRCLR = PIN5_bm; //SW2
     29e:	80 e2       	ldi	r24, 0x20	; 32
     2a0:	82 83       	std	Z+2, r24	; 0x02
	PORTF.DIRCLR = PIN6_bm; //SW3
     2a2:	80 e4       	ldi	r24, 0x40	; 64
     2a4:	82 83       	std	Z+2, r24	; 0x02
	PORTF.DIRCLR = PIN7_bm; //SW4
     2a6:	80 e8       	ldi	r24, 0x80	; 128
     2a8:	82 83       	std	Z+2, r24	; 0x02
     2aa:	08 95       	ret

000002ac <updateButtons>:
 void updateButtons(void) {
	static uint16_t b1Count = 0;
	static uint16_t b2Count = 0;
	static uint16_t b3Count = 0;
	static uint16_t b4Count = 0;
	if(Button1_Value == 0) {
     2ac:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <__TEXT_REGION_LENGTH__+0x7006a8>
     2b0:	84 fd       	sbrc	r24, 4
     2b2:	0e c0       	rjmp	.+28     	; 0x2d0 <updateButtons+0x24>
		if(b1Count < 60000) {
     2b4:	80 91 c4 22 	lds	r24, 0x22C4	; 0x8022c4 <b1Count.3829>
     2b8:	90 91 c5 22 	lds	r25, 0x22C5	; 0x8022c5 <b1Count.3829+0x1>
     2bc:	80 36       	cpi	r24, 0x60	; 96
     2be:	2a ee       	ldi	r18, 0xEA	; 234
     2c0:	92 07       	cpc	r25, r18
     2c2:	e8 f4       	brcc	.+58     	; 0x2fe <updateButtons+0x52>
			b1Count++;
     2c4:	01 96       	adiw	r24, 0x01	; 1
     2c6:	80 93 c4 22 	sts	0x22C4, r24	; 0x8022c4 <b1Count.3829>
     2ca:	90 93 c5 22 	sts	0x22C5, r25	; 0x8022c5 <b1Count.3829+0x1>
     2ce:	17 c0       	rjmp	.+46     	; 0x2fe <updateButtons+0x52>
		}
	} else {
		if(b1Count > (BUTTON_PRESS_SHORT / (1000/BUTTON_UPDATE_FREQUENCY_HZ))) {
     2d0:	80 91 c4 22 	lds	r24, 0x22C4	; 0x8022c4 <b1Count.3829>
     2d4:	90 91 c5 22 	lds	r25, 0x22C5	; 0x8022c5 <b1Count.3829+0x1>
     2d8:	8b 30       	cpi	r24, 0x0B	; 11
     2da:	91 05       	cpc	r25, r1
     2dc:	48 f0       	brcs	.+18     	; 0x2f0 <updateButtons+0x44>
			if(b1Count > (BUTTON_PRESS_LONG / (1000/BUTTON_UPDATE_FREQUENCY_HZ))) {
     2de:	c3 97       	sbiw	r24, 0x33	; 51
     2e0:	18 f0       	brcs	.+6      	; 0x2e8 <updateButtons+0x3c>
				//Button was pressed Long
				b1Status = LONG_PRESSED;
     2e2:	10 92 3a 30 	sts	0x303A, r1	; 0x80303a <b1Status>
     2e6:	07 c0       	rjmp	.+14     	; 0x2f6 <updateButtons+0x4a>
			} else {
				//Button was pressed Short	
				b1Status = SHORT_PRESSED;
     2e8:	81 e0       	ldi	r24, 0x01	; 1
     2ea:	80 93 3a 30 	sts	0x303A, r24	; 0x80303a <b1Status>
     2ee:	03 c0       	rjmp	.+6      	; 0x2f6 <updateButtons+0x4a>
			}
		} else {
			b1Status = NOT_PRESSED;
     2f0:	82 e0       	ldi	r24, 0x02	; 2
     2f2:	80 93 3a 30 	sts	0x303A, r24	; 0x80303a <b1Status>
		}
		b1Count = 0;
     2f6:	10 92 c4 22 	sts	0x22C4, r1	; 0x8022c4 <b1Count.3829>
     2fa:	10 92 c5 22 	sts	0x22C5, r1	; 0x8022c5 <b1Count.3829+0x1>
	}
	if(Button2_Value == 0) {
     2fe:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <__TEXT_REGION_LENGTH__+0x7006a8>
     302:	85 fd       	sbrc	r24, 5
     304:	0e c0       	rjmp	.+28     	; 0x322 <updateButtons+0x76>
		if(b2Count < 60000) {
     306:	80 91 c2 22 	lds	r24, 0x22C2	; 0x8022c2 <b2Count.3830>
     30a:	90 91 c3 22 	lds	r25, 0x22C3	; 0x8022c3 <b2Count.3830+0x1>
     30e:	80 36       	cpi	r24, 0x60	; 96
     310:	2a ee       	ldi	r18, 0xEA	; 234
     312:	92 07       	cpc	r25, r18
     314:	e8 f4       	brcc	.+58     	; 0x350 <updateButtons+0xa4>
			b2Count++;
     316:	01 96       	adiw	r24, 0x01	; 1
     318:	80 93 c2 22 	sts	0x22C2, r24	; 0x8022c2 <b2Count.3830>
     31c:	90 93 c3 22 	sts	0x22C3, r25	; 0x8022c3 <b2Count.3830+0x1>
     320:	17 c0       	rjmp	.+46     	; 0x350 <updateButtons+0xa4>
		}
	} else {
		if(b2Count > (BUTTON_PRESS_SHORT / (1000/BUTTON_UPDATE_FREQUENCY_HZ))) {
     322:	80 91 c2 22 	lds	r24, 0x22C2	; 0x8022c2 <b2Count.3830>
     326:	90 91 c3 22 	lds	r25, 0x22C3	; 0x8022c3 <b2Count.3830+0x1>
     32a:	8b 30       	cpi	r24, 0x0B	; 11
     32c:	91 05       	cpc	r25, r1
     32e:	48 f0       	brcs	.+18     	; 0x342 <updateButtons+0x96>
			if(b2Count > (BUTTON_PRESS_LONG / (1000/BUTTON_UPDATE_FREQUENCY_HZ))) {
     330:	c3 97       	sbiw	r24, 0x33	; 51
     332:	18 f0       	brcs	.+6      	; 0x33a <updateButtons+0x8e>
				//Button was pressed Long
				b2Status = LONG_PRESSED;
     334:	10 92 3b 30 	sts	0x303B, r1	; 0x80303b <b2Status>
     338:	07 c0       	rjmp	.+14     	; 0x348 <updateButtons+0x9c>
				} else {
				//Button was pressed Short
				b2Status = SHORT_PRESSED;
     33a:	81 e0       	ldi	r24, 0x01	; 1
     33c:	80 93 3b 30 	sts	0x303B, r24	; 0x80303b <b2Status>
     340:	03 c0       	rjmp	.+6      	; 0x348 <updateButtons+0x9c>
			}
		} else {
			b2Status = NOT_PRESSED;			
     342:	82 e0       	ldi	r24, 0x02	; 2
     344:	80 93 3b 30 	sts	0x303B, r24	; 0x80303b <b2Status>
		}
		b2Count = 0;
     348:	10 92 c2 22 	sts	0x22C2, r1	; 0x8022c2 <b2Count.3830>
     34c:	10 92 c3 22 	sts	0x22C3, r1	; 0x8022c3 <b2Count.3830+0x1>
	}
	if(Button3_Value == 0) {
     350:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <__TEXT_REGION_LENGTH__+0x7006a8>
     354:	86 fd       	sbrc	r24, 6
     356:	0e c0       	rjmp	.+28     	; 0x374 <updateButtons+0xc8>
		if(b3Count < 60000) {
     358:	80 91 c0 22 	lds	r24, 0x22C0	; 0x8022c0 <b3Count.3831>
     35c:	90 91 c1 22 	lds	r25, 0x22C1	; 0x8022c1 <b3Count.3831+0x1>
     360:	80 36       	cpi	r24, 0x60	; 96
     362:	2a ee       	ldi	r18, 0xEA	; 234
     364:	92 07       	cpc	r25, r18
     366:	e8 f4       	brcc	.+58     	; 0x3a2 <updateButtons+0xf6>
			b3Count++;
     368:	01 96       	adiw	r24, 0x01	; 1
     36a:	80 93 c0 22 	sts	0x22C0, r24	; 0x8022c0 <b3Count.3831>
     36e:	90 93 c1 22 	sts	0x22C1, r25	; 0x8022c1 <b3Count.3831+0x1>
     372:	17 c0       	rjmp	.+46     	; 0x3a2 <updateButtons+0xf6>
		}
	} else {
		if(b3Count > (BUTTON_PRESS_SHORT / (1000/BUTTON_UPDATE_FREQUENCY_HZ))) {
     374:	80 91 c0 22 	lds	r24, 0x22C0	; 0x8022c0 <b3Count.3831>
     378:	90 91 c1 22 	lds	r25, 0x22C1	; 0x8022c1 <b3Count.3831+0x1>
     37c:	8b 30       	cpi	r24, 0x0B	; 11
     37e:	91 05       	cpc	r25, r1
     380:	48 f0       	brcs	.+18     	; 0x394 <updateButtons+0xe8>
			if(b3Count > (BUTTON_PRESS_LONG / (1000/BUTTON_UPDATE_FREQUENCY_HZ))) {
     382:	c3 97       	sbiw	r24, 0x33	; 51
     384:	18 f0       	brcs	.+6      	; 0x38c <updateButtons+0xe0>
				//Button was pressed Long
				b3Status = LONG_PRESSED;
     386:	10 92 3c 30 	sts	0x303C, r1	; 0x80303c <b3Status>
     38a:	07 c0       	rjmp	.+14     	; 0x39a <updateButtons+0xee>
				} else {
				//Button was pressed Short
				b3Status = SHORT_PRESSED;
     38c:	81 e0       	ldi	r24, 0x01	; 1
     38e:	80 93 3c 30 	sts	0x303C, r24	; 0x80303c <b3Status>
     392:	03 c0       	rjmp	.+6      	; 0x39a <updateButtons+0xee>
			}
		} else {
			b3Status = NOT_PRESSED;
     394:	82 e0       	ldi	r24, 0x02	; 2
     396:	80 93 3c 30 	sts	0x303C, r24	; 0x80303c <b3Status>
		}
		b3Count = 0;
     39a:	10 92 c0 22 	sts	0x22C0, r1	; 0x8022c0 <b3Count.3831>
     39e:	10 92 c1 22 	sts	0x22C1, r1	; 0x8022c1 <b3Count.3831+0x1>
	}
	if(Button4_Value == 0) {
     3a2:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <__TEXT_REGION_LENGTH__+0x7006a8>
     3a6:	88 23       	and	r24, r24
     3a8:	74 f0       	brlt	.+28     	; 0x3c6 <updateButtons+0x11a>
		if(b4Count < 60000) {
     3aa:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <__data_end>
     3ae:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <__data_end+0x1>
     3b2:	80 36       	cpi	r24, 0x60	; 96
     3b4:	2a ee       	ldi	r18, 0xEA	; 234
     3b6:	92 07       	cpc	r25, r18
     3b8:	e8 f4       	brcc	.+58     	; 0x3f4 <updateButtons+0x148>
			b4Count++;
     3ba:	01 96       	adiw	r24, 0x01	; 1
     3bc:	80 93 be 22 	sts	0x22BE, r24	; 0x8022be <__data_end>
     3c0:	90 93 bf 22 	sts	0x22BF, r25	; 0x8022bf <__data_end+0x1>
     3c4:	08 95       	ret
		}
	} else {
		if(b4Count > (BUTTON_PRESS_SHORT / (1000/BUTTON_UPDATE_FREQUENCY_HZ))) {
     3c6:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <__data_end>
     3ca:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <__data_end+0x1>
     3ce:	8b 30       	cpi	r24, 0x0B	; 11
     3d0:	91 05       	cpc	r25, r1
     3d2:	48 f0       	brcs	.+18     	; 0x3e6 <updateButtons+0x13a>
			if(b4Count > (BUTTON_PRESS_LONG / (1000/BUTTON_UPDATE_FREQUENCY_HZ))) {
     3d4:	c3 97       	sbiw	r24, 0x33	; 51
     3d6:	18 f0       	brcs	.+6      	; 0x3de <updateButtons+0x132>
				//Button was pressed Long
				b4Status = LONG_PRESSED;
     3d8:	10 92 3d 30 	sts	0x303D, r1	; 0x80303d <b4Status>
     3dc:	07 c0       	rjmp	.+14     	; 0x3ec <updateButtons+0x140>
				} else {
				//Button was pressed Short
				b4Status = SHORT_PRESSED;
     3de:	81 e0       	ldi	r24, 0x01	; 1
     3e0:	80 93 3d 30 	sts	0x303D, r24	; 0x80303d <b4Status>
     3e4:	03 c0       	rjmp	.+6      	; 0x3ec <updateButtons+0x140>
			}
		} else {
			b4Status = NOT_PRESSED;
     3e6:	82 e0       	ldi	r24, 0x02	; 2
     3e8:	80 93 3d 30 	sts	0x303D, r24	; 0x80303d <b4Status>
		}
		b4Count = 0;
     3ec:	10 92 be 22 	sts	0x22BE, r1	; 0x8022be <__data_end>
     3f0:	10 92 bf 22 	sts	0x22BF, r1	; 0x8022bf <__data_end+0x1>
     3f4:	08 95       	ret

000003f6 <getButtonPress>:
	}
 }

 button_press_t getButtonPress(button_t button) {
	switch(button) {
     3f6:	81 30       	cpi	r24, 0x01	; 1
     3f8:	49 f0       	breq	.+18     	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
     3fa:	28 f0       	brcs	.+10     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
     3fc:	82 30       	cpi	r24, 0x02	; 2
     3fe:	49 f0       	breq	.+18     	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
     400:	83 30       	cpi	r24, 0x03	; 3
     402:	51 f0       	breq	.+20     	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
     404:	0c c0       	rjmp	.+24     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
		case BUTTON1:
			return b1Status;
     406:	80 91 3a 30 	lds	r24, 0x303A	; 0x80303a <b1Status>
     40a:	08 95       	ret
		break;
		case BUTTON2:
			return b2Status;
     40c:	80 91 3b 30 	lds	r24, 0x303B	; 0x80303b <b2Status>
     410:	08 95       	ret
		break;
		case BUTTON3:
			return b3Status;
     412:	80 91 3c 30 	lds	r24, 0x303C	; 0x80303c <b3Status>
     416:	08 95       	ret
		break;
		case BUTTON4:
			return b4Status;
     418:	80 91 3d 30 	lds	r24, 0x303D	; 0x80303d <b4Status>
     41c:	08 95       	ret
		break;
	}
	return NOT_PRESSED;
     41e:	82 e0       	ldi	r24, 0x02	; 2
     420:	08 95       	ret

00000422 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     422:	0f 93       	push	r16
     424:	cf 93       	push	r28
     426:	df 93       	push	r29
     428:	1f 92       	push	r1
     42a:	cd b7       	in	r28, 0x3d	; 61
     42c:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
     42e:	2f b7       	in	r18, 0x3f	; 63
     430:	29 83       	std	Y+1, r18	; 0x01
     432:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     434:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     436:	fc 01       	movw	r30, r24
     438:	08 ed       	ldi	r16, 0xD8	; 216
     43a:	04 bf       	out	0x34, r16	; 52
     43c:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
     43e:	89 81       	ldd	r24, Y+1	; 0x01
     440:	8f bf       	out	0x3f, r24	; 63
#endif
}
     442:	0f 90       	pop	r0
     444:	df 91       	pop	r29
     446:	cf 91       	pop	r28
     448:	0f 91       	pop	r16
     44a:	08 95       	ret

0000044c <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
     44c:	61 11       	cpse	r22, r1
     44e:	02 c0       	rjmp	.+4      	; 0x454 <CLKSYS_XOSC_Config+0x8>
     450:	90 e0       	ldi	r25, 0x00	; 0
     452:	01 c0       	rjmp	.+2      	; 0x456 <CLKSYS_XOSC_Config+0xa>
     454:	90 e2       	ldi	r25, 0x20	; 32
     456:	84 2b       	or	r24, r20
     458:	89 2b       	or	r24, r25
     45a:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
     45e:	08 95       	ret

00000460 <CLKSYS_PLL_Config>:
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
     460:	6f 71       	andi	r22, 0x1F	; 31
     462:	86 2b       	or	r24, r22
     464:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
     468:	08 95       	ret

0000046a <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
     46a:	e0 e5       	ldi	r30, 0x50	; 80
     46c:	f0 e0       	ldi	r31, 0x00	; 0
     46e:	90 81       	ld	r25, Z
     470:	28 2f       	mov	r18, r24
     472:	20 95       	com	r18
     474:	92 23       	and	r25, r18
     476:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
     478:	90 81       	ld	r25, Z
	return clkEnabled;
}
     47a:	89 23       	and	r24, r25
     47c:	08 95       	ret

0000047e <CLKSYS_Prescalers_Config>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
     47e:	68 2b       	or	r22, r24
     480:	81 e4       	ldi	r24, 0x41	; 65
     482:	90 e0       	ldi	r25, 0x00	; 0
     484:	0e 94 11 02 	call	0x422	; 0x422 <CCPWrite>
     488:	08 95       	ret

0000048a <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
     48a:	0f 93       	push	r16
     48c:	1f 93       	push	r17
     48e:	cf 93       	push	r28
     490:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
     492:	00 e4       	ldi	r16, 0x40	; 64
     494:	10 e0       	ldi	r17, 0x00	; 0
     496:	f8 01       	movw	r30, r16
     498:	60 81       	ld	r22, Z
	CCPWrite( &CLK.CTRL, clkCtrl );
     49a:	68 7f       	andi	r22, 0xF8	; 248
     49c:	68 2b       	or	r22, r24
     49e:	80 e4       	ldi	r24, 0x40	; 64
     4a0:	90 e0       	ldi	r25, 0x00	; 0
     4a2:	0e 94 11 02 	call	0x422	; 0x422 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
     4a6:	f8 01       	movw	r30, r16
     4a8:	80 81       	ld	r24, Z
	return clkCtrl;
}
     4aa:	8c 23       	and	r24, r28
     4ac:	cf 91       	pop	r28
     4ae:	1f 91       	pop	r17
     4b0:	0f 91       	pop	r16
     4b2:	08 95       	ret

000004b4 <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
     4b4:	fc 01       	movw	r30, r24
     4b6:	90 81       	ld	r25, Z
     4b8:	90 7f       	andi	r25, 0xF0	; 240
     4ba:	69 2b       	or	r22, r25
     4bc:	60 83       	st	Z, r22
     4be:	08 95       	ret

000004c0 <TC0_ConfigWGM>:
     4c0:	fc 01       	movw	r30, r24
     4c2:	91 81       	ldd	r25, Z+1	; 0x01
     4c4:	98 7f       	andi	r25, 0xF8	; 248
     4c6:	69 2b       	or	r22, r25
     4c8:	61 83       	std	Z+1, r22	; 0x01
     4ca:	08 95       	ret

000004cc <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
     4cc:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
     4ce:	96 81       	ldd	r25, Z+6	; 0x06
     4d0:	9c 7f       	andi	r25, 0xFC	; 252
     4d2:	69 2b       	or	r22, r25
     4d4:	66 83       	std	Z+6, r22	; 0x06
     4d6:	08 95       	ret

000004d8 <software_reset>:
	 // TODO from here:
	 //
	 // - log the occurance of any error in flash mem (inc counter)
	 // - print a message

	 software_reset();
     4d8:	00 00       	nop
     4da:	88 ed       	ldi	r24, 0xD8	; 216
     4dc:	84 bf       	out	0x34, r24	; 52
     4de:	81 e0       	ldi	r24, 0x01	; 1
     4e0:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     4e4:	08 95       	ret

000004e6 <vApplicationStackOverflowHook>:
     4e6:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <software_reset>
     4ea:	08 95       	ret

000004ec <xEventGroupCreate>:
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
}
     4ec:	cf 93       	push	r28
     4ee:	df 93       	push	r29
     4f0:	80 e1       	ldi	r24, 0x10	; 16
     4f2:	90 e0       	ldi	r25, 0x00	; 0
     4f4:	0e 94 22 04 	call	0x844	; 0x844 <pvPortMalloc>
     4f8:	ec 01       	movw	r28, r24
     4fa:	00 97       	sbiw	r24, 0x00	; 0
     4fc:	41 f0       	breq	.+16     	; 0x50e <xEventGroupCreate+0x22>
     4fe:	fc 01       	movw	r30, r24
     500:	11 92       	st	Z+, r1
     502:	11 92       	st	Z+, r1
     504:	11 92       	st	Z+, r1
     506:	11 92       	st	Z+, r1
     508:	cf 01       	movw	r24, r30
     50a:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
     50e:	ce 01       	movw	r24, r28
     510:	df 91       	pop	r29
     512:	cf 91       	pop	r28
     514:	08 95       	ret

00000516 <xEventGroupWaitBits>:
     516:	2f 92       	push	r2
     518:	3f 92       	push	r3
     51a:	4f 92       	push	r4
     51c:	5f 92       	push	r5
     51e:	6f 92       	push	r6
     520:	7f 92       	push	r7
     522:	8f 92       	push	r8
     524:	9f 92       	push	r9
     526:	af 92       	push	r10
     528:	bf 92       	push	r11
     52a:	cf 92       	push	r12
     52c:	df 92       	push	r13
     52e:	ef 92       	push	r14
     530:	ff 92       	push	r15
     532:	0f 93       	push	r16
     534:	1f 93       	push	r17
     536:	cf 93       	push	r28
     538:	df 93       	push	r29
     53a:	ec 01       	movw	r28, r24
     53c:	4a 01       	movw	r8, r20
     53e:	5b 01       	movw	r10, r22
     540:	62 2e       	mov	r6, r18
     542:	70 2e       	mov	r7, r16
     544:	0e 94 96 0b 	call	0x172c	; 0x172c <vTaskSuspendAll>
     548:	28 80       	ld	r2, Y
     54a:	39 80       	ldd	r3, Y+1	; 0x01
     54c:	4a 80       	ldd	r4, Y+2	; 0x02
     54e:	5b 80       	ldd	r5, Y+3	; 0x03
     550:	01 11       	cpse	r16, r1
     552:	0d c0       	rjmp	.+26     	; 0x56e <xEventGroupWaitBits+0x58>
     554:	81 e0       	ldi	r24, 0x01	; 1
     556:	b2 01       	movw	r22, r4
     558:	a1 01       	movw	r20, r2
     55a:	48 21       	and	r20, r8
     55c:	59 21       	and	r21, r9
     55e:	6a 21       	and	r22, r10
     560:	7b 21       	and	r23, r11
     562:	45 2b       	or	r20, r21
     564:	46 2b       	or	r20, r22
     566:	47 2b       	or	r20, r23
     568:	79 f4       	brne	.+30     	; 0x588 <xEventGroupWaitBits+0x72>
     56a:	80 e0       	ldi	r24, 0x00	; 0
     56c:	0d c0       	rjmp	.+26     	; 0x588 <xEventGroupWaitBits+0x72>
     56e:	81 e0       	ldi	r24, 0x01	; 1
     570:	b2 01       	movw	r22, r4
     572:	a1 01       	movw	r20, r2
     574:	48 21       	and	r20, r8
     576:	59 21       	and	r21, r9
     578:	6a 21       	and	r22, r10
     57a:	7b 21       	and	r23, r11
     57c:	48 15       	cp	r20, r8
     57e:	59 05       	cpc	r21, r9
     580:	6a 05       	cpc	r22, r10
     582:	7b 05       	cpc	r23, r11
     584:	09 f0       	breq	.+2      	; 0x588 <xEventGroupWaitBits+0x72>
     586:	80 e0       	ldi	r24, 0x00	; 0
     588:	88 23       	and	r24, r24
     58a:	81 f0       	breq	.+32     	; 0x5ac <xEventGroupWaitBits+0x96>
     58c:	66 20       	and	r6, r6
     58e:	09 f4       	brne	.+2      	; 0x592 <xEventGroupWaitBits+0x7c>
     590:	70 c0       	rjmp	.+224    	; 0x672 <xEventGroupWaitBits+0x15c>
     592:	80 94       	com	r8
     594:	90 94       	com	r9
     596:	a0 94       	com	r10
     598:	b0 94       	com	r11
     59a:	82 20       	and	r8, r2
     59c:	93 20       	and	r9, r3
     59e:	a4 20       	and	r10, r4
     5a0:	b5 20       	and	r11, r5
     5a2:	88 82       	st	Y, r8
     5a4:	99 82       	std	Y+1, r9	; 0x01
     5a6:	aa 82       	std	Y+2, r10	; 0x02
     5a8:	bb 82       	std	Y+3, r11	; 0x03
     5aa:	63 c0       	rjmp	.+198    	; 0x672 <xEventGroupWaitBits+0x15c>
     5ac:	c1 14       	cp	r12, r1
     5ae:	d1 04       	cpc	r13, r1
     5b0:	e1 04       	cpc	r14, r1
     5b2:	f1 04       	cpc	r15, r1
     5b4:	09 f4       	brne	.+2      	; 0x5b8 <xEventGroupWaitBits+0xa2>
     5b6:	5d c0       	rjmp	.+186    	; 0x672 <xEventGroupWaitBits+0x15c>
     5b8:	66 20       	and	r6, r6
     5ba:	29 f0       	breq	.+10     	; 0x5c6 <xEventGroupWaitBits+0xb0>
     5bc:	40 e0       	ldi	r20, 0x00	; 0
     5be:	50 e0       	ldi	r21, 0x00	; 0
     5c0:	60 e0       	ldi	r22, 0x00	; 0
     5c2:	71 e0       	ldi	r23, 0x01	; 1
     5c4:	03 c0       	rjmp	.+6      	; 0x5cc <xEventGroupWaitBits+0xb6>
     5c6:	40 e0       	ldi	r20, 0x00	; 0
     5c8:	50 e0       	ldi	r21, 0x00	; 0
     5ca:	ba 01       	movw	r22, r20
     5cc:	71 10       	cpse	r7, r1
     5ce:	74 60       	ori	r23, 0x04	; 4
     5d0:	48 29       	or	r20, r8
     5d2:	59 29       	or	r21, r9
     5d4:	6a 29       	or	r22, r10
     5d6:	7b 29       	or	r23, r11
     5d8:	97 01       	movw	r18, r14
     5da:	86 01       	movw	r16, r12
     5dc:	ce 01       	movw	r24, r28
     5de:	04 96       	adiw	r24, 0x04	; 4
     5e0:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <vTaskPlaceOnUnorderedEventList>
     5e4:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
     5e8:	81 11       	cpse	r24, r1
     5ea:	02 c0       	rjmp	.+4      	; 0x5f0 <xEventGroupWaitBits+0xda>
     5ec:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
     5f0:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <uxTaskResetEventItemValue>
     5f4:	91 fd       	sbrc	r25, 1
     5f6:	39 c0       	rjmp	.+114    	; 0x66a <xEventGroupWaitBits+0x154>
     5f8:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     5fc:	ff 93       	push	r31
     5fe:	f8 7f       	andi	r31, 0xF8	; 248
     600:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     604:	68 81       	ld	r22, Y
     606:	79 81       	ldd	r23, Y+1	; 0x01
     608:	8a 81       	ldd	r24, Y+2	; 0x02
     60a:	9b 81       	ldd	r25, Y+3	; 0x03
     60c:	71 10       	cpse	r7, r1
     60e:	0d c0       	rjmp	.+26     	; 0x62a <xEventGroupWaitBits+0x114>
     610:	21 e0       	ldi	r18, 0x01	; 1
     612:	75 01       	movw	r14, r10
     614:	64 01       	movw	r12, r8
     616:	c6 22       	and	r12, r22
     618:	d7 22       	and	r13, r23
     61a:	e8 22       	and	r14, r24
     61c:	f9 22       	and	r15, r25
     61e:	cd 28       	or	r12, r13
     620:	ce 28       	or	r12, r14
     622:	cf 28       	or	r12, r15
     624:	79 f4       	brne	.+30     	; 0x644 <xEventGroupWaitBits+0x12e>
     626:	20 e0       	ldi	r18, 0x00	; 0
     628:	0d c0       	rjmp	.+26     	; 0x644 <xEventGroupWaitBits+0x12e>
     62a:	21 e0       	ldi	r18, 0x01	; 1
     62c:	75 01       	movw	r14, r10
     62e:	64 01       	movw	r12, r8
     630:	c6 22       	and	r12, r22
     632:	d7 22       	and	r13, r23
     634:	e8 22       	and	r14, r24
     636:	f9 22       	and	r15, r25
     638:	c8 14       	cp	r12, r8
     63a:	d9 04       	cpc	r13, r9
     63c:	ea 04       	cpc	r14, r10
     63e:	fb 04       	cpc	r15, r11
     640:	09 f0       	breq	.+2      	; 0x644 <xEventGroupWaitBits+0x12e>
     642:	20 e0       	ldi	r18, 0x00	; 0
     644:	22 23       	and	r18, r18
     646:	71 f0       	breq	.+28     	; 0x664 <xEventGroupWaitBits+0x14e>
     648:	66 20       	and	r6, r6
     64a:	61 f0       	breq	.+24     	; 0x664 <xEventGroupWaitBits+0x14e>
     64c:	80 94       	com	r8
     64e:	90 94       	com	r9
     650:	a0 94       	com	r10
     652:	b0 94       	com	r11
     654:	86 22       	and	r8, r22
     656:	97 22       	and	r9, r23
     658:	a8 22       	and	r10, r24
     65a:	b9 22       	and	r11, r25
     65c:	88 82       	st	Y, r8
     65e:	99 82       	std	Y+1, r9	; 0x01
     660:	aa 82       	std	Y+2, r10	; 0x02
     662:	bb 82       	std	Y+3, r11	; 0x03
     664:	ff 91       	pop	r31
     666:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     66a:	1b 01       	movw	r2, r22
     66c:	2c 01       	movw	r4, r24
     66e:	55 24       	eor	r5, r5
     670:	02 c0       	rjmp	.+4      	; 0x676 <xEventGroupWaitBits+0x160>
     672:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
     676:	c2 01       	movw	r24, r4
     678:	b1 01       	movw	r22, r2
     67a:	df 91       	pop	r29
     67c:	cf 91       	pop	r28
     67e:	1f 91       	pop	r17
     680:	0f 91       	pop	r16
     682:	ff 90       	pop	r15
     684:	ef 90       	pop	r14
     686:	df 90       	pop	r13
     688:	cf 90       	pop	r12
     68a:	bf 90       	pop	r11
     68c:	af 90       	pop	r10
     68e:	9f 90       	pop	r9
     690:	8f 90       	pop	r8
     692:	7f 90       	pop	r7
     694:	6f 90       	pop	r6
     696:	5f 90       	pop	r5
     698:	4f 90       	pop	r4
     69a:	3f 90       	pop	r3
     69c:	2f 90       	pop	r2
     69e:	08 95       	ret

000006a0 <xEventGroupClearBits>:
     6a0:	0f 93       	push	r16
     6a2:	1f 93       	push	r17
     6a4:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     6a8:	ff 93       	push	r31
     6aa:	f8 7f       	andi	r31, 0xF8	; 248
     6ac:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     6b0:	fc 01       	movw	r30, r24
     6b2:	00 81       	ld	r16, Z
     6b4:	11 81       	ldd	r17, Z+1	; 0x01
     6b6:	22 81       	ldd	r18, Z+2	; 0x02
     6b8:	33 81       	ldd	r19, Z+3	; 0x03
     6ba:	40 95       	com	r20
     6bc:	50 95       	com	r21
     6be:	60 95       	com	r22
     6c0:	70 95       	com	r23
     6c2:	40 23       	and	r20, r16
     6c4:	51 23       	and	r21, r17
     6c6:	62 23       	and	r22, r18
     6c8:	73 23       	and	r23, r19
     6ca:	40 83       	st	Z, r20
     6cc:	51 83       	std	Z+1, r21	; 0x01
     6ce:	62 83       	std	Z+2, r22	; 0x02
     6d0:	73 83       	std	Z+3, r23	; 0x03
     6d2:	ff 91       	pop	r31
     6d4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     6d8:	c9 01       	movw	r24, r18
     6da:	b8 01       	movw	r22, r16
     6dc:	1f 91       	pop	r17
     6de:	0f 91       	pop	r16
     6e0:	08 95       	ret

000006e2 <xEventGroupGetBitsFromISR>:
     6e2:	cf 93       	push	r28
     6e4:	df 93       	push	r29
     6e6:	ec 01       	movw	r28, r24
     6e8:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <_portSetInterruptMaskFromIsr>
     6ec:	28 2f       	mov	r18, r24
     6ee:	68 81       	ld	r22, Y
     6f0:	79 81       	ldd	r23, Y+1	; 0x01
     6f2:	8a 81       	ldd	r24, Y+2	; 0x02
     6f4:	9b 81       	ldd	r25, Y+3	; 0x03
     6f6:	20 93 a2 00 	sts	0x00A2, r18	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     6fa:	df 91       	pop	r29
     6fc:	cf 91       	pop	r28
     6fe:	08 95       	ret

00000700 <xEventGroupSetBits>:
     700:	4f 92       	push	r4
     702:	5f 92       	push	r5
     704:	6f 92       	push	r6
     706:	7f 92       	push	r7
     708:	af 92       	push	r10
     70a:	bf 92       	push	r11
     70c:	cf 92       	push	r12
     70e:	df 92       	push	r13
     710:	ef 92       	push	r14
     712:	ff 92       	push	r15
     714:	0f 93       	push	r16
     716:	1f 93       	push	r17
     718:	cf 93       	push	r28
     71a:	df 93       	push	r29
     71c:	ec 01       	movw	r28, r24
     71e:	6a 01       	movw	r12, r20
     720:	7b 01       	movw	r14, r22
     722:	8c 01       	movw	r16, r24
     724:	09 5f       	subi	r16, 0xF9	; 249
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	0e 94 96 0b 	call	0x172c	; 0x172c <vTaskSuspendAll>
     72c:	eb 85       	ldd	r30, Y+11	; 0x0b
     72e:	fc 85       	ldd	r31, Y+12	; 0x0c
     730:	88 81       	ld	r24, Y
     732:	99 81       	ldd	r25, Y+1	; 0x01
     734:	aa 81       	ldd	r26, Y+2	; 0x02
     736:	bb 81       	ldd	r27, Y+3	; 0x03
     738:	c8 2a       	or	r12, r24
     73a:	d9 2a       	or	r13, r25
     73c:	ea 2a       	or	r14, r26
     73e:	fb 2a       	or	r15, r27
     740:	c8 82       	st	Y, r12
     742:	d9 82       	std	Y+1, r13	; 0x01
     744:	ea 82       	std	Y+2, r14	; 0x02
     746:	fb 82       	std	Y+3, r15	; 0x03
     748:	0e 17       	cp	r16, r30
     74a:	1f 07       	cpc	r17, r31
     74c:	09 f4       	brne	.+2      	; 0x750 <xEventGroupSetBits+0x50>
     74e:	42 c0       	rjmp	.+132    	; 0x7d4 <xEventGroupSetBits+0xd4>
     750:	c1 2c       	mov	r12, r1
     752:	d1 2c       	mov	r13, r1
     754:	76 01       	movw	r14, r12
     756:	a4 80       	ldd	r10, Z+4	; 0x04
     758:	b5 80       	ldd	r11, Z+5	; 0x05
     75a:	80 81       	ld	r24, Z
     75c:	91 81       	ldd	r25, Z+1	; 0x01
     75e:	a2 81       	ldd	r26, Z+2	; 0x02
     760:	b3 81       	ldd	r27, Z+3	; 0x03
     762:	ac 01       	movw	r20, r24
     764:	bd 01       	movw	r22, r26
     766:	77 27       	eor	r23, r23
     768:	b2 fd       	sbrc	r27, 2
     76a:	0f c0       	rjmp	.+30     	; 0x78a <xEventGroupSetBits+0x8a>
     76c:	48 80       	ld	r4, Y
     76e:	59 80       	ldd	r5, Y+1	; 0x01
     770:	6a 80       	ldd	r6, Y+2	; 0x02
     772:	7b 80       	ldd	r7, Y+3	; 0x03
     774:	44 22       	and	r4, r20
     776:	55 22       	and	r5, r21
     778:	66 22       	and	r6, r22
     77a:	77 22       	and	r7, r23
     77c:	21 e0       	ldi	r18, 0x01	; 1
     77e:	45 28       	or	r4, r5
     780:	46 28       	or	r4, r6
     782:	47 28       	or	r4, r7
     784:	89 f4       	brne	.+34     	; 0x7a8 <xEventGroupSetBits+0xa8>
     786:	20 e0       	ldi	r18, 0x00	; 0
     788:	0f c0       	rjmp	.+30     	; 0x7a8 <xEventGroupSetBits+0xa8>
     78a:	48 80       	ld	r4, Y
     78c:	59 80       	ldd	r5, Y+1	; 0x01
     78e:	6a 80       	ldd	r6, Y+2	; 0x02
     790:	7b 80       	ldd	r7, Y+3	; 0x03
     792:	44 22       	and	r4, r20
     794:	55 22       	and	r5, r21
     796:	66 22       	and	r6, r22
     798:	77 22       	and	r7, r23
     79a:	21 e0       	ldi	r18, 0x01	; 1
     79c:	44 16       	cp	r4, r20
     79e:	55 06       	cpc	r5, r21
     7a0:	66 06       	cpc	r6, r22
     7a2:	77 06       	cpc	r7, r23
     7a4:	09 f0       	breq	.+2      	; 0x7a8 <xEventGroupSetBits+0xa8>
     7a6:	20 e0       	ldi	r18, 0x00	; 0
     7a8:	22 23       	and	r18, r18
     7aa:	71 f0       	breq	.+28     	; 0x7c8 <xEventGroupSetBits+0xc8>
     7ac:	b0 ff       	sbrs	r27, 0
     7ae:	04 c0       	rjmp	.+8      	; 0x7b8 <xEventGroupSetBits+0xb8>
     7b0:	c4 2a       	or	r12, r20
     7b2:	d5 2a       	or	r13, r21
     7b4:	e6 2a       	or	r14, r22
     7b6:	f7 2a       	or	r15, r23
     7b8:	48 81       	ld	r20, Y
     7ba:	59 81       	ldd	r21, Y+1	; 0x01
     7bc:	6a 81       	ldd	r22, Y+2	; 0x02
     7be:	7b 81       	ldd	r23, Y+3	; 0x03
     7c0:	72 60       	ori	r23, 0x02	; 2
     7c2:	cf 01       	movw	r24, r30
     7c4:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <vTaskRemoveFromUnorderedEventList>
     7c8:	ea 2d       	mov	r30, r10
     7ca:	fb 2d       	mov	r31, r11
     7cc:	0e 17       	cp	r16, r30
     7ce:	1f 07       	cpc	r17, r31
     7d0:	11 f6       	brne	.-124    	; 0x756 <xEventGroupSetBits+0x56>
     7d2:	03 c0       	rjmp	.+6      	; 0x7da <xEventGroupSetBits+0xda>
     7d4:	c1 2c       	mov	r12, r1
     7d6:	d1 2c       	mov	r13, r1
     7d8:	76 01       	movw	r14, r12
     7da:	c0 94       	com	r12
     7dc:	d0 94       	com	r13
     7de:	e0 94       	com	r14
     7e0:	f0 94       	com	r15
     7e2:	88 81       	ld	r24, Y
     7e4:	99 81       	ldd	r25, Y+1	; 0x01
     7e6:	aa 81       	ldd	r26, Y+2	; 0x02
     7e8:	bb 81       	ldd	r27, Y+3	; 0x03
     7ea:	c8 22       	and	r12, r24
     7ec:	d9 22       	and	r13, r25
     7ee:	ea 22       	and	r14, r26
     7f0:	fb 22       	and	r15, r27
     7f2:	c8 82       	st	Y, r12
     7f4:	d9 82       	std	Y+1, r13	; 0x01
     7f6:	ea 82       	std	Y+2, r14	; 0x02
     7f8:	fb 82       	std	Y+3, r15	; 0x03
     7fa:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
     7fe:	68 81       	ld	r22, Y
     800:	79 81       	ldd	r23, Y+1	; 0x01
     802:	8a 81       	ldd	r24, Y+2	; 0x02
     804:	9b 81       	ldd	r25, Y+3	; 0x03
     806:	df 91       	pop	r29
     808:	cf 91       	pop	r28
     80a:	1f 91       	pop	r17
     80c:	0f 91       	pop	r16
     80e:	ff 90       	pop	r15
     810:	ef 90       	pop	r14
     812:	df 90       	pop	r13
     814:	cf 90       	pop	r12
     816:	bf 90       	pop	r11
     818:	af 90       	pop	r10
     81a:	7f 90       	pop	r7
     81c:	6f 90       	pop	r6
     81e:	5f 90       	pop	r5
     820:	4f 90       	pop	r4
     822:	08 95       	ret

00000824 <vEventGroupSetBitsCallback>:
     824:	0e 94 80 03 	call	0x700	; 0x700 <xEventGroupSetBits>
     828:	08 95       	ret

0000082a <xEventGroupSetBitsFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
	{
     82a:	0f 93       	push	r16
     82c:	1f 93       	push	r17
	BaseType_t xReturn;

		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
     82e:	89 01       	movw	r16, r18
     830:	9a 01       	movw	r18, r20
     832:	ab 01       	movw	r20, r22
     834:	bc 01       	movw	r22, r24
     836:	82 e1       	ldi	r24, 0x12	; 18
     838:	94 e0       	ldi	r25, 0x04	; 4
     83a:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTimerPendFunctionCallFromISR>

		return xReturn;
	}
     83e:	1f 91       	pop	r17
     840:	0f 91       	pop	r16
     842:	08 95       	ret

00000844 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     844:	cf 93       	push	r28
     846:	df 93       	push	r29
     848:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     84a:	0e 94 96 0b 	call	0x172c	; 0x172c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     84e:	20 91 c6 22 	lds	r18, 0x22C6	; 0x8022c6 <xNextFreeByte>
     852:	30 91 c7 22 	lds	r19, 0x22C7	; 0x8022c7 <xNextFreeByte+0x1>
     856:	c9 01       	movw	r24, r18
     858:	8c 0f       	add	r24, r28
     85a:	9d 1f       	adc	r25, r29
     85c:	88 3b       	cpi	r24, 0xB8	; 184
     85e:	4b e0       	ldi	r20, 0x0B	; 11
     860:	94 07       	cpc	r25, r20
     862:	58 f4       	brcc	.+22     	; 0x87a <pvPortMalloc+0x36>
     864:	28 17       	cp	r18, r24
     866:	39 07       	cpc	r19, r25
     868:	58 f4       	brcc	.+22     	; 0x880 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     86a:	e9 01       	movw	r28, r18
     86c:	c8 53       	subi	r28, 0x38	; 56
     86e:	dd 4d       	sbci	r29, 0xDD	; 221
			xNextFreeByte += xWantedSize;			
     870:	80 93 c6 22 	sts	0x22C6, r24	; 0x8022c6 <xNextFreeByte>
     874:	90 93 c7 22 	sts	0x22C7, r25	; 0x8022c7 <xNextFreeByte+0x1>
     878:	05 c0       	rjmp	.+10     	; 0x884 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     87a:	c0 e0       	ldi	r28, 0x00	; 0
     87c:	d0 e0       	ldi	r29, 0x00	; 0
     87e:	02 c0       	rjmp	.+4      	; 0x884 <pvPortMalloc+0x40>
     880:	c0 e0       	ldi	r28, 0x00	; 0
     882:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     884:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     888:	ce 01       	movw	r24, r28
     88a:	df 91       	pop	r29
     88c:	cf 91       	pop	r28
     88e:	08 95       	ret

00000890 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     890:	08 95       	ret

00000892 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     892:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     894:	03 96       	adiw	r24, 0x03	; 3
     896:	81 83       	std	Z+1, r24	; 0x01
     898:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     89a:	4f ef       	ldi	r20, 0xFF	; 255
     89c:	5f ef       	ldi	r21, 0xFF	; 255
     89e:	ba 01       	movw	r22, r20
     8a0:	43 83       	std	Z+3, r20	; 0x03
     8a2:	54 83       	std	Z+4, r21	; 0x04
     8a4:	65 83       	std	Z+5, r22	; 0x05
     8a6:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8a8:	87 83       	std	Z+7, r24	; 0x07
     8aa:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8ac:	81 87       	std	Z+9, r24	; 0x09
     8ae:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8b0:	10 82       	st	Z, r1
     8b2:	08 95       	ret

000008b4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8b4:	fc 01       	movw	r30, r24
     8b6:	12 86       	std	Z+10, r1	; 0x0a
     8b8:	13 86       	std	Z+11, r1	; 0x0b
     8ba:	08 95       	ret

000008bc <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     8bc:	cf 93       	push	r28
     8be:	df 93       	push	r29
     8c0:	9c 01       	movw	r18, r24
     8c2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     8c4:	dc 01       	movw	r26, r24
     8c6:	11 96       	adiw	r26, 0x01	; 1
     8c8:	cd 91       	ld	r28, X+
     8ca:	dc 91       	ld	r29, X
     8cc:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     8ce:	c4 83       	std	Z+4, r28	; 0x04
     8d0:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     8d2:	8e 81       	ldd	r24, Y+6	; 0x06
     8d4:	9f 81       	ldd	r25, Y+7	; 0x07
     8d6:	86 83       	std	Z+6, r24	; 0x06
     8d8:	97 83       	std	Z+7, r25	; 0x07

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	9f 81       	ldd	r25, Y+7	; 0x07
     8de:	dc 01       	movw	r26, r24
     8e0:	14 96       	adiw	r26, 0x04	; 4
     8e2:	6d 93       	st	X+, r22
     8e4:	7c 93       	st	X, r23
     8e6:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxPrevious = pxNewListItem;
     8e8:	6e 83       	std	Y+6, r22	; 0x06
     8ea:	7f 83       	std	Y+7, r23	; 0x07

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8ec:	22 87       	std	Z+10, r18	; 0x0a
     8ee:	33 87       	std	Z+11, r19	; 0x0b

	( pxList->uxNumberOfItems )++;
     8f0:	f9 01       	movw	r30, r18
     8f2:	80 81       	ld	r24, Z
     8f4:	8f 5f       	subi	r24, 0xFF	; 255
     8f6:	80 83       	st	Z, r24
}
     8f8:	df 91       	pop	r29
     8fa:	cf 91       	pop	r28
     8fc:	08 95       	ret

000008fe <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     8fe:	0f 93       	push	r16
     900:	1f 93       	push	r17
     902:	cf 93       	push	r28
     904:	df 93       	push	r29
     906:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     908:	08 81       	ld	r16, Y
     90a:	19 81       	ldd	r17, Y+1	; 0x01
     90c:	2a 81       	ldd	r18, Y+2	; 0x02
     90e:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     910:	0f 3f       	cpi	r16, 0xFF	; 255
     912:	4f ef       	ldi	r20, 0xFF	; 255
     914:	14 07       	cpc	r17, r20
     916:	24 07       	cpc	r18, r20
     918:	34 07       	cpc	r19, r20
     91a:	21 f4       	brne	.+8      	; 0x924 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     91c:	fc 01       	movw	r30, r24
     91e:	a1 85       	ldd	r26, Z+9	; 0x09
     920:	b2 85       	ldd	r27, Z+10	; 0x0a
     922:	11 c0       	rjmp	.+34     	; 0x946 <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     924:	dc 01       	movw	r26, r24
     926:	13 96       	adiw	r26, 0x03	; 3
     928:	01 c0       	rjmp	.+2      	; 0x92c <vListInsert+0x2e>
     92a:	df 01       	movw	r26, r30
     92c:	14 96       	adiw	r26, 0x04	; 4
     92e:	ed 91       	ld	r30, X+
     930:	fc 91       	ld	r31, X
     932:	15 97       	sbiw	r26, 0x05	; 5
     934:	40 81       	ld	r20, Z
     936:	51 81       	ldd	r21, Z+1	; 0x01
     938:	62 81       	ldd	r22, Z+2	; 0x02
     93a:	73 81       	ldd	r23, Z+3	; 0x03
     93c:	04 17       	cp	r16, r20
     93e:	15 07       	cpc	r17, r21
     940:	26 07       	cpc	r18, r22
     942:	37 07       	cpc	r19, r23
     944:	90 f7       	brcc	.-28     	; 0x92a <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     946:	14 96       	adiw	r26, 0x04	; 4
     948:	ed 91       	ld	r30, X+
     94a:	fc 91       	ld	r31, X
     94c:	15 97       	sbiw	r26, 0x05	; 5
     94e:	ec 83       	std	Y+4, r30	; 0x04
     950:	fd 83       	std	Y+5, r31	; 0x05
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     952:	c6 83       	std	Z+6, r28	; 0x06
     954:	d7 83       	std	Z+7, r29	; 0x07
	pxNewListItem->pxPrevious = pxIterator;
     956:	ae 83       	std	Y+6, r26	; 0x06
     958:	bf 83       	std	Y+7, r27	; 0x07
	pxIterator->pxNext = pxNewListItem;
     95a:	14 96       	adiw	r26, 0x04	; 4
     95c:	cd 93       	st	X+, r28
     95e:	dc 93       	st	X, r29
     960:	15 97       	sbiw	r26, 0x05	; 5

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     962:	8a 87       	std	Y+10, r24	; 0x0a
     964:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
     966:	fc 01       	movw	r30, r24
     968:	20 81       	ld	r18, Z
     96a:	2f 5f       	subi	r18, 0xFF	; 255
     96c:	20 83       	st	Z, r18
}
     96e:	df 91       	pop	r29
     970:	cf 91       	pop	r28
     972:	1f 91       	pop	r17
     974:	0f 91       	pop	r16
     976:	08 95       	ret

00000978 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     978:	cf 93       	push	r28
     97a:	df 93       	push	r29
     97c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     97e:	a2 85       	ldd	r26, Z+10	; 0x0a
     980:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     982:	c4 81       	ldd	r28, Z+4	; 0x04
     984:	d5 81       	ldd	r29, Z+5	; 0x05
     986:	86 81       	ldd	r24, Z+6	; 0x06
     988:	97 81       	ldd	r25, Z+7	; 0x07
     98a:	8e 83       	std	Y+6, r24	; 0x06
     98c:	9f 83       	std	Y+7, r25	; 0x07
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     98e:	c6 81       	ldd	r28, Z+6	; 0x06
     990:	d7 81       	ldd	r29, Z+7	; 0x07
     992:	84 81       	ldd	r24, Z+4	; 0x04
     994:	95 81       	ldd	r25, Z+5	; 0x05
     996:	8c 83       	std	Y+4, r24	; 0x04
     998:	9d 83       	std	Y+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     99a:	11 96       	adiw	r26, 0x01	; 1
     99c:	8d 91       	ld	r24, X+
     99e:	9c 91       	ld	r25, X
     9a0:	12 97       	sbiw	r26, 0x02	; 2
     9a2:	e8 17       	cp	r30, r24
     9a4:	f9 07       	cpc	r31, r25
     9a6:	31 f4       	brne	.+12     	; 0x9b4 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9a8:	86 81       	ldd	r24, Z+6	; 0x06
     9aa:	97 81       	ldd	r25, Z+7	; 0x07
     9ac:	11 96       	adiw	r26, 0x01	; 1
     9ae:	8d 93       	st	X+, r24
     9b0:	9c 93       	st	X, r25
     9b2:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     9b4:	12 86       	std	Z+10, r1	; 0x0a
     9b6:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     9b8:	8c 91       	ld	r24, X
     9ba:	81 50       	subi	r24, 0x01	; 1
     9bc:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     9be:	8c 91       	ld	r24, X
}
     9c0:	df 91       	pop	r29
     9c2:	cf 91       	pop	r28
     9c4:	08 95       	ret

000009c6 <_portSetInterruptMaskFromIsr>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     9c6:	e0 ea       	ldi	r30, 0xA0	; 160
     9c8:	f0 e0       	ldi	r31, 0x00	; 0
     9ca:	82 81       	ldd	r24, Z+2	; 0x02
     9cc:	92 81       	ldd	r25, Z+2	; 0x02
     9ce:	98 7f       	andi	r25, 0xF8	; 248
     9d0:	92 83       	std	Z+2, r25	; 0x02
     9d2:	08 95       	ret

000009d4 <pxPortInitialiseStack>:
     9d4:	cf 92       	push	r12
     9d6:	df 92       	push	r13
     9d8:	ef 92       	push	r14
     9da:	ff 92       	push	r15
     9dc:	31 e1       	ldi	r19, 0x11	; 17
     9de:	fc 01       	movw	r30, r24
     9e0:	30 83       	st	Z, r19
     9e2:	31 97       	sbiw	r30, 0x01	; 1
     9e4:	22 e2       	ldi	r18, 0x22	; 34
     9e6:	20 83       	st	Z, r18
     9e8:	31 97       	sbiw	r30, 0x01	; 1
     9ea:	a3 e3       	ldi	r26, 0x33	; 51
     9ec:	a0 83       	st	Z, r26
     9ee:	6b 01       	movw	r12, r22
     9f0:	e1 2c       	mov	r14, r1
     9f2:	f1 2c       	mov	r15, r1
     9f4:	31 97       	sbiw	r30, 0x01	; 1
     9f6:	60 83       	st	Z, r22
     9f8:	31 97       	sbiw	r30, 0x01	; 1
     9fa:	d0 82       	st	Z, r13
     9fc:	31 97       	sbiw	r30, 0x01	; 1
     9fe:	e0 82       	st	Z, r14
     a00:	31 97       	sbiw	r30, 0x01	; 1
     a02:	61 e3       	ldi	r22, 0x31	; 49
     a04:	60 83       	st	Z, r22
     a06:	31 97       	sbiw	r30, 0x01	; 1
     a08:	60 e8       	ldi	r22, 0x80	; 128
     a0a:	60 83       	st	Z, r22
     a0c:	31 97       	sbiw	r30, 0x01	; 1
     a0e:	67 e8       	ldi	r22, 0x87	; 135
     a10:	60 83       	st	Z, r22
     a12:	31 97       	sbiw	r30, 0x01	; 1
     a14:	10 82       	st	Z, r1
     a16:	31 97       	sbiw	r30, 0x01	; 1
     a18:	10 82       	st	Z, r1
     a1a:	31 97       	sbiw	r30, 0x01	; 1
     a1c:	62 e0       	ldi	r22, 0x02	; 2
     a1e:	60 83       	st	Z, r22
     a20:	31 97       	sbiw	r30, 0x01	; 1
     a22:	63 e0       	ldi	r22, 0x03	; 3
     a24:	60 83       	st	Z, r22
     a26:	31 97       	sbiw	r30, 0x01	; 1
     a28:	64 e0       	ldi	r22, 0x04	; 4
     a2a:	60 83       	st	Z, r22
     a2c:	31 97       	sbiw	r30, 0x01	; 1
     a2e:	65 e0       	ldi	r22, 0x05	; 5
     a30:	60 83       	st	Z, r22
     a32:	31 97       	sbiw	r30, 0x01	; 1
     a34:	66 e0       	ldi	r22, 0x06	; 6
     a36:	60 83       	st	Z, r22
     a38:	31 97       	sbiw	r30, 0x01	; 1
     a3a:	67 e0       	ldi	r22, 0x07	; 7
     a3c:	60 83       	st	Z, r22
     a3e:	31 97       	sbiw	r30, 0x01	; 1
     a40:	68 e0       	ldi	r22, 0x08	; 8
     a42:	60 83       	st	Z, r22
     a44:	31 97       	sbiw	r30, 0x01	; 1
     a46:	69 e0       	ldi	r22, 0x09	; 9
     a48:	60 83       	st	Z, r22
     a4a:	31 97       	sbiw	r30, 0x01	; 1
     a4c:	60 e1       	ldi	r22, 0x10	; 16
     a4e:	60 83       	st	Z, r22
     a50:	31 97       	sbiw	r30, 0x01	; 1
     a52:	30 83       	st	Z, r19
     a54:	31 97       	sbiw	r30, 0x01	; 1
     a56:	32 e1       	ldi	r19, 0x12	; 18
     a58:	30 83       	st	Z, r19
     a5a:	31 97       	sbiw	r30, 0x01	; 1
     a5c:	33 e1       	ldi	r19, 0x13	; 19
     a5e:	30 83       	st	Z, r19
     a60:	31 97       	sbiw	r30, 0x01	; 1
     a62:	34 e1       	ldi	r19, 0x14	; 20
     a64:	30 83       	st	Z, r19
     a66:	31 97       	sbiw	r30, 0x01	; 1
     a68:	35 e1       	ldi	r19, 0x15	; 21
     a6a:	30 83       	st	Z, r19
     a6c:	31 97       	sbiw	r30, 0x01	; 1
     a6e:	36 e1       	ldi	r19, 0x16	; 22
     a70:	30 83       	st	Z, r19
     a72:	31 97       	sbiw	r30, 0x01	; 1
     a74:	37 e1       	ldi	r19, 0x17	; 23
     a76:	30 83       	st	Z, r19
     a78:	31 97       	sbiw	r30, 0x01	; 1
     a7a:	38 e1       	ldi	r19, 0x18	; 24
     a7c:	30 83       	st	Z, r19
     a7e:	31 97       	sbiw	r30, 0x01	; 1
     a80:	39 e1       	ldi	r19, 0x19	; 25
     a82:	30 83       	st	Z, r19
     a84:	31 97       	sbiw	r30, 0x01	; 1
     a86:	30 e2       	ldi	r19, 0x20	; 32
     a88:	30 83       	st	Z, r19
     a8a:	31 97       	sbiw	r30, 0x01	; 1
     a8c:	31 e2       	ldi	r19, 0x21	; 33
     a8e:	30 83       	st	Z, r19
     a90:	31 97       	sbiw	r30, 0x01	; 1
     a92:	20 83       	st	Z, r18
     a94:	31 97       	sbiw	r30, 0x01	; 1
     a96:	23 e2       	ldi	r18, 0x23	; 35
     a98:	20 83       	st	Z, r18
     a9a:	6a 01       	movw	r12, r20
     a9c:	31 97       	sbiw	r30, 0x01	; 1
     a9e:	40 83       	st	Z, r20
     aa0:	31 97       	sbiw	r30, 0x01	; 1
     aa2:	d0 82       	st	Z, r13
     aa4:	31 97       	sbiw	r30, 0x01	; 1
     aa6:	26 e2       	ldi	r18, 0x26	; 38
     aa8:	20 83       	st	Z, r18
     aaa:	31 97       	sbiw	r30, 0x01	; 1
     aac:	27 e2       	ldi	r18, 0x27	; 39
     aae:	20 83       	st	Z, r18
     ab0:	31 97       	sbiw	r30, 0x01	; 1
     ab2:	28 e2       	ldi	r18, 0x28	; 40
     ab4:	20 83       	st	Z, r18
     ab6:	31 97       	sbiw	r30, 0x01	; 1
     ab8:	29 e2       	ldi	r18, 0x29	; 41
     aba:	20 83       	st	Z, r18
     abc:	31 97       	sbiw	r30, 0x01	; 1
     abe:	20 e3       	ldi	r18, 0x30	; 48
     ac0:	20 83       	st	Z, r18
     ac2:	88 97       	sbiw	r24, 0x28	; 40
     ac4:	ff 90       	pop	r15
     ac6:	ef 90       	pop	r14
     ac8:	df 90       	pop	r13
     aca:	cf 90       	pop	r12
     acc:	08 95       	ret

00000ace <xPortStartScheduler>:
     ace:	83 ef       	ldi	r24, 0xF3	; 243
     ad0:	91 e0       	ldi	r25, 0x01	; 1
     ad2:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
     ad6:	90 93 27 08 	sts	0x0827, r25	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
     ada:	65 e0       	ldi	r22, 0x05	; 5
     adc:	80 e0       	ldi	r24, 0x00	; 0
     ade:	98 e0       	ldi	r25, 0x08	; 8
     ae0:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <TC0_ConfigClockSource>
     ae4:	61 e0       	ldi	r22, 0x01	; 1
     ae6:	80 e0       	ldi	r24, 0x00	; 0
     ae8:	98 e0       	ldi	r25, 0x08	; 8
     aea:	0e 94 66 02 	call	0x4cc	; 0x4cc <TC0_SetOverflowIntLevel>
     aee:	a0 91 ee 2e 	lds	r26, 0x2EEE	; 0x802eee <pxCurrentTCB>
     af2:	b0 91 ef 2e 	lds	r27, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
     af6:	0d 90       	ld	r0, X+
     af8:	0d be       	out	0x3d, r0	; 61
     afa:	0d 90       	ld	r0, X+
     afc:	0e be       	out	0x3e, r0	; 62
     afe:	ef 91       	pop	r30
     b00:	df 91       	pop	r29
     b02:	cf 91       	pop	r28
     b04:	bf 91       	pop	r27
     b06:	af 91       	pop	r26
     b08:	9f 91       	pop	r25
     b0a:	8f 91       	pop	r24
     b0c:	7f 91       	pop	r23
     b0e:	6f 91       	pop	r22
     b10:	5f 91       	pop	r21
     b12:	4f 91       	pop	r20
     b14:	3f 91       	pop	r19
     b16:	2f 91       	pop	r18
     b18:	1f 91       	pop	r17
     b1a:	0f 91       	pop	r16
     b1c:	ff 90       	pop	r15
     b1e:	ef 90       	pop	r14
     b20:	df 90       	pop	r13
     b22:	cf 90       	pop	r12
     b24:	bf 90       	pop	r11
     b26:	af 90       	pop	r10
     b28:	9f 90       	pop	r9
     b2a:	8f 90       	pop	r8
     b2c:	7f 90       	pop	r7
     b2e:	6f 90       	pop	r6
     b30:	5f 90       	pop	r5
     b32:	4f 90       	pop	r4
     b34:	3f 90       	pop	r3
     b36:	2f 90       	pop	r2
     b38:	1f 90       	pop	r1
     b3a:	0f 90       	pop	r0
     b3c:	ff 91       	pop	r31
     b3e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b42:	ff 91       	pop	r31
     b44:	ff bf       	out	0x3f, r31	; 63
     b46:	ff 91       	pop	r31
     b48:	08 95       	ret
     b4a:	81 e0       	ldi	r24, 0x01	; 1
     b4c:	08 95       	ret

00000b4e <vPortYield>:
// 
//
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b4e:	ff 93       	push	r31
     b50:	ff b7       	in	r31, 0x3f	; 63
     b52:	ff 93       	push	r31
     b54:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b58:	ff 93       	push	r31
     b5a:	f8 7f       	andi	r31, 0xF8	; 248
     b5c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b60:	0f 92       	push	r0
     b62:	1f 92       	push	r1
     b64:	11 24       	eor	r1, r1
     b66:	2f 92       	push	r2
     b68:	3f 92       	push	r3
     b6a:	4f 92       	push	r4
     b6c:	5f 92       	push	r5
     b6e:	6f 92       	push	r6
     b70:	7f 92       	push	r7
     b72:	8f 92       	push	r8
     b74:	9f 92       	push	r9
     b76:	af 92       	push	r10
     b78:	bf 92       	push	r11
     b7a:	cf 92       	push	r12
     b7c:	df 92       	push	r13
     b7e:	ef 92       	push	r14
     b80:	ff 92       	push	r15
     b82:	0f 93       	push	r16
     b84:	1f 93       	push	r17
     b86:	2f 93       	push	r18
     b88:	3f 93       	push	r19
     b8a:	4f 93       	push	r20
     b8c:	5f 93       	push	r21
     b8e:	6f 93       	push	r22
     b90:	7f 93       	push	r23
     b92:	8f 93       	push	r24
     b94:	9f 93       	push	r25
     b96:	af 93       	push	r26
     b98:	bf 93       	push	r27
     b9a:	cf 93       	push	r28
     b9c:	df 93       	push	r29
     b9e:	ef 93       	push	r30
     ba0:	a0 91 ee 2e 	lds	r26, 0x2EEE	; 0x802eee <pxCurrentTCB>
     ba4:	b0 91 ef 2e 	lds	r27, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
     ba8:	0d b6       	in	r0, 0x3d	; 61
     baa:	0d 92       	st	X+, r0
     bac:	0e b6       	in	r0, 0x3e	; 62
     bae:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     bb0:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     bb4:	a0 91 ee 2e 	lds	r26, 0x2EEE	; 0x802eee <pxCurrentTCB>
     bb8:	b0 91 ef 2e 	lds	r27, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
     bbc:	0d 90       	ld	r0, X+
     bbe:	0d be       	out	0x3d, r0	; 61
     bc0:	0d 90       	ld	r0, X+
     bc2:	0e be       	out	0x3e, r0	; 62
     bc4:	ef 91       	pop	r30
     bc6:	df 91       	pop	r29
     bc8:	cf 91       	pop	r28
     bca:	bf 91       	pop	r27
     bcc:	af 91       	pop	r26
     bce:	9f 91       	pop	r25
     bd0:	8f 91       	pop	r24
     bd2:	7f 91       	pop	r23
     bd4:	6f 91       	pop	r22
     bd6:	5f 91       	pop	r21
     bd8:	4f 91       	pop	r20
     bda:	3f 91       	pop	r19
     bdc:	2f 91       	pop	r18
     bde:	1f 91       	pop	r17
     be0:	0f 91       	pop	r16
     be2:	ff 90       	pop	r15
     be4:	ef 90       	pop	r14
     be6:	df 90       	pop	r13
     be8:	cf 90       	pop	r12
     bea:	bf 90       	pop	r11
     bec:	af 90       	pop	r10
     bee:	9f 90       	pop	r9
     bf0:	8f 90       	pop	r8
     bf2:	7f 90       	pop	r7
     bf4:	6f 90       	pop	r6
     bf6:	5f 90       	pop	r5
     bf8:	4f 90       	pop	r4
     bfa:	3f 90       	pop	r3
     bfc:	2f 90       	pop	r2
     bfe:	1f 90       	pop	r1
     c00:	0f 90       	pop	r0
     c02:	ff 91       	pop	r31
     c04:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     c08:	ff 91       	pop	r31
     c0a:	ff bf       	out	0x3f, r31	; 63
     c0c:	ff 91       	pop	r31
	asm volatile ( "ret" );
     c0e:	08 95       	ret

00000c10 <portTaskSwitchContext>:
	//-----------------------------------------------------------
	//
	// The task switch is deferred until there is no more nesting.
	//
	void portTaskSwitchContext(signed portBASE_TYPE xSwitchRequired)
	{
     c10:	cf 93       	push	r28
		intTaskSwitchPending |= xSwitchRequired;					
     c12:	90 91 3e 30 	lds	r25, 0x303E	; 0x80303e <intTaskSwitchPending>
     c16:	89 2b       	or	r24, r25
     c18:	80 93 3e 30 	sts	0x303E, r24	; 0x80303e <intTaskSwitchPending>
																
		if(NOT_NESTING() && intTaskSwitchPending)					
     c1c:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c20:	91 30       	cpi	r25, 0x01	; 1
     c22:	41 f0       	breq	.+16     	; 0xc34 <portTaskSwitchContext+0x24>
     c24:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c28:	92 30       	cpi	r25, 0x02	; 2
     c2a:	21 f0       	breq	.+8      	; 0xc34 <portTaskSwitchContext+0x24>
     c2c:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c30:	94 30       	cpi	r25, 0x04	; 4
     c32:	59 f4       	brne	.+22     	; 0xc4a <portTaskSwitchContext+0x3a>
     c34:	88 23       	and	r24, r24
     c36:	49 f0       	breq	.+18     	; 0xc4a <portTaskSwitchContext+0x3a>
		{															
			register unsigned portBASE_TYPE uxSavedPmicCtrlReg; 				
			extern void vTaskSwitchContext(void);   				
																
			// Critical section used, because vTaskSwitchContext handles FreeRTOS internal data structures.
 			uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR(); 
     c38:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <_portSetInterruptMaskFromIsr>
     c3c:	c8 2f       	mov	r28, r24
			intTaskSwitchPending = 0;								
     c3e:	10 92 3e 30 	sts	0x303E, r1	; 0x80303e <intTaskSwitchPending>
			vTaskSwitchContext();                   				
     c42:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <vTaskSwitchContext>
			portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedPmicCtrlReg);
     c46:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		}                                          					
	}
     c4a:	cf 91       	pop	r28
     c4c:	08 95       	ret

00000c4e <__vector_14>:
	// the context is saved at the start of vPortYieldFromTick().  The tick
	// count is incremented after the context is saved.
	//
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
     c4e:	ff 93       	push	r31
     c50:	ff b7       	in	r31, 0x3f	; 63
     c52:	ff 93       	push	r31
     c54:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     c58:	ff 93       	push	r31
     c5a:	f8 7f       	andi	r31, 0xF8	; 248
     c5c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     c60:	0f 92       	push	r0
     c62:	1f 92       	push	r1
     c64:	11 24       	eor	r1, r1
     c66:	2f 92       	push	r2
     c68:	3f 92       	push	r3
     c6a:	4f 92       	push	r4
     c6c:	5f 92       	push	r5
     c6e:	6f 92       	push	r6
     c70:	7f 92       	push	r7
     c72:	8f 92       	push	r8
     c74:	9f 92       	push	r9
     c76:	af 92       	push	r10
     c78:	bf 92       	push	r11
     c7a:	cf 92       	push	r12
     c7c:	df 92       	push	r13
     c7e:	ef 92       	push	r14
     c80:	ff 92       	push	r15
     c82:	0f 93       	push	r16
     c84:	1f 93       	push	r17
     c86:	2f 93       	push	r18
     c88:	3f 93       	push	r19
     c8a:	4f 93       	push	r20
     c8c:	5f 93       	push	r21
     c8e:	6f 93       	push	r22
     c90:	7f 93       	push	r23
     c92:	8f 93       	push	r24
     c94:	9f 93       	push	r25
     c96:	af 93       	push	r26
     c98:	bf 93       	push	r27
     c9a:	cf 93       	push	r28
     c9c:	df 93       	push	r29
     c9e:	ef 93       	push	r30
     ca0:	a0 91 ee 2e 	lds	r26, 0x2EEE	; 0x802eee <pxCurrentTCB>
     ca4:	b0 91 ef 2e 	lds	r27, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
     ca8:	0d b6       	in	r0, 0x3d	; 61
     caa:	0d 92       	st	X+, r0
     cac:	0e b6       	in	r0, 0x3e	; 62
     cae:	0d 92       	st	X+, r0
	//
	static void portTaskIncrementTick( void )
	{
		register unsigned portBASE_TYPE uxSavedPmicCtrlReg;

 		uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR();
     cb0:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <_portSetInterruptMaskFromIsr>
     cb4:	c8 2f       	mov	r28, r24
		xTaskIncrementTick();
     cb6:	0e 94 ae 0b 	call	0x175c	; 0x175c <xTaskIncrementTick>
 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedPmicCtrlReg );
     cba:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
		portTaskIncrementTick();
		//always try a task switch, but only if on kernel interrupt level
		portEND_SWITCHING_ISR(pdTRUE); 
     cbe:	81 e0       	ldi	r24, 0x01	; 1
     cc0:	0e 94 08 06 	call	0xc10	; 0xc10 <portTaskSwitchContext>
     cc4:	a0 91 ee 2e 	lds	r26, 0x2EEE	; 0x802eee <pxCurrentTCB>
     cc8:	b0 91 ef 2e 	lds	r27, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
     ccc:	0d 90       	ld	r0, X+
     cce:	0d be       	out	0x3d, r0	; 61
     cd0:	0d 90       	ld	r0, X+
     cd2:	0e be       	out	0x3e, r0	; 62
     cd4:	ef 91       	pop	r30
     cd6:	df 91       	pop	r29
     cd8:	cf 91       	pop	r28
     cda:	bf 91       	pop	r27
     cdc:	af 91       	pop	r26
     cde:	9f 91       	pop	r25
     ce0:	8f 91       	pop	r24
     ce2:	7f 91       	pop	r23
     ce4:	6f 91       	pop	r22
     ce6:	5f 91       	pop	r21
     ce8:	4f 91       	pop	r20
     cea:	3f 91       	pop	r19
     cec:	2f 91       	pop	r18
     cee:	1f 91       	pop	r17
     cf0:	0f 91       	pop	r16
     cf2:	ff 90       	pop	r15
     cf4:	ef 90       	pop	r14
     cf6:	df 90       	pop	r13
     cf8:	cf 90       	pop	r12
     cfa:	bf 90       	pop	r11
     cfc:	af 90       	pop	r10
     cfe:	9f 90       	pop	r9
     d00:	8f 90       	pop	r8
     d02:	7f 90       	pop	r7
     d04:	6f 90       	pop	r6
     d06:	5f 90       	pop	r5
     d08:	4f 90       	pop	r4
     d0a:	3f 90       	pop	r3
     d0c:	2f 90       	pop	r2
     d0e:	1f 90       	pop	r1
     d10:	0f 90       	pop	r0
     d12:	ff 91       	pop	r31
     d14:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d18:	ff 91       	pop	r31
     d1a:	ff bf       	out	0x3f, r31	; 63
     d1c:	ff 91       	pop	r31
     d1e:	18 95       	reti

00000d20 <prvIsQueueEmpty>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
     d20:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d24:	ff 93       	push	r31
     d26:	f8 7f       	andi	r31, 0xF8	; 248
     d28:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d2c:	fc 01       	movw	r30, r24
     d2e:	96 8d       	ldd	r25, Z+30	; 0x1e
     d30:	ff 91       	pop	r31
     d32:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d36:	81 e0       	ldi	r24, 0x01	; 1
     d38:	91 11       	cpse	r25, r1
     d3a:	80 e0       	ldi	r24, 0x00	; 0
     d3c:	08 95       	ret

00000d3e <prvIsQueueFull>:
     d3e:	dc 01       	movw	r26, r24
     d40:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d44:	ff 93       	push	r31
     d46:	f8 7f       	andi	r31, 0xF8	; 248
     d48:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d4c:	5e 96       	adiw	r26, 0x1e	; 30
     d4e:	9c 91       	ld	r25, X
     d50:	5e 97       	sbiw	r26, 0x1e	; 30
     d52:	ff 91       	pop	r31
     d54:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d58:	81 e0       	ldi	r24, 0x01	; 1
     d5a:	5f 96       	adiw	r26, 0x1f	; 31
     d5c:	2c 91       	ld	r18, X
     d5e:	29 13       	cpse	r18, r25
     d60:	80 e0       	ldi	r24, 0x00	; 0
     d62:	08 95       	ret

00000d64 <prvCopyDataToQueue>:
     d64:	0f 93       	push	r16
     d66:	1f 93       	push	r17
     d68:	cf 93       	push	r28
     d6a:	df 93       	push	r29
     d6c:	ec 01       	movw	r28, r24
     d6e:	04 2f       	mov	r16, r20
     d70:	1e 8d       	ldd	r17, Y+30	; 0x1e
     d72:	48 a1       	ldd	r20, Y+32	; 0x20
     d74:	44 23       	and	r20, r20
     d76:	b9 f1       	breq	.+110    	; 0xde6 <prvCopyDataToQueue+0x82>
     d78:	01 11       	cpse	r16, r1
     d7a:	16 c0       	rjmp	.+44     	; 0xda8 <prvCopyDataToQueue+0x44>
     d7c:	50 e0       	ldi	r21, 0x00	; 0
     d7e:	8c 81       	ldd	r24, Y+4	; 0x04
     d80:	9d 81       	ldd	r25, Y+5	; 0x05
     d82:	0e 94 ba 21 	call	0x4374	; 0x4374 <memcpy>
     d86:	28 a1       	ldd	r18, Y+32	; 0x20
     d88:	8c 81       	ldd	r24, Y+4	; 0x04
     d8a:	9d 81       	ldd	r25, Y+5	; 0x05
     d8c:	82 0f       	add	r24, r18
     d8e:	91 1d       	adc	r25, r1
     d90:	8c 83       	std	Y+4, r24	; 0x04
     d92:	9d 83       	std	Y+5, r25	; 0x05
     d94:	2a 81       	ldd	r18, Y+2	; 0x02
     d96:	3b 81       	ldd	r19, Y+3	; 0x03
     d98:	82 17       	cp	r24, r18
     d9a:	93 07       	cpc	r25, r19
     d9c:	20 f1       	brcs	.+72     	; 0xde6 <prvCopyDataToQueue+0x82>
     d9e:	88 81       	ld	r24, Y
     da0:	99 81       	ldd	r25, Y+1	; 0x01
     da2:	8c 83       	std	Y+4, r24	; 0x04
     da4:	9d 83       	std	Y+5, r25	; 0x05
     da6:	1f c0       	rjmp	.+62     	; 0xde6 <prvCopyDataToQueue+0x82>
     da8:	50 e0       	ldi	r21, 0x00	; 0
     daa:	8e 81       	ldd	r24, Y+6	; 0x06
     dac:	9f 81       	ldd	r25, Y+7	; 0x07
     dae:	0e 94 ba 21 	call	0x4374	; 0x4374 <memcpy>
     db2:	88 a1       	ldd	r24, Y+32	; 0x20
     db4:	90 e0       	ldi	r25, 0x00	; 0
     db6:	91 95       	neg	r25
     db8:	81 95       	neg	r24
     dba:	91 09       	sbc	r25, r1
     dbc:	2e 81       	ldd	r18, Y+6	; 0x06
     dbe:	3f 81       	ldd	r19, Y+7	; 0x07
     dc0:	28 0f       	add	r18, r24
     dc2:	39 1f       	adc	r19, r25
     dc4:	2e 83       	std	Y+6, r18	; 0x06
     dc6:	3f 83       	std	Y+7, r19	; 0x07
     dc8:	48 81       	ld	r20, Y
     dca:	59 81       	ldd	r21, Y+1	; 0x01
     dcc:	24 17       	cp	r18, r20
     dce:	35 07       	cpc	r19, r21
     dd0:	30 f4       	brcc	.+12     	; 0xdde <prvCopyDataToQueue+0x7a>
     dd2:	2a 81       	ldd	r18, Y+2	; 0x02
     dd4:	3b 81       	ldd	r19, Y+3	; 0x03
     dd6:	82 0f       	add	r24, r18
     dd8:	93 1f       	adc	r25, r19
     dda:	8e 83       	std	Y+6, r24	; 0x06
     ddc:	9f 83       	std	Y+7, r25	; 0x07
     dde:	02 30       	cpi	r16, 0x02	; 2
     de0:	11 f4       	brne	.+4      	; 0xde6 <prvCopyDataToQueue+0x82>
     de2:	11 11       	cpse	r17, r1
     de4:	11 50       	subi	r17, 0x01	; 1
     de6:	1f 5f       	subi	r17, 0xFF	; 255
     de8:	1e 8f       	std	Y+30, r17	; 0x1e
     dea:	80 e0       	ldi	r24, 0x00	; 0
     dec:	df 91       	pop	r29
     dee:	cf 91       	pop	r28
     df0:	1f 91       	pop	r17
     df2:	0f 91       	pop	r16
     df4:	08 95       	ret

00000df6 <prvCopyDataFromQueue>:
     df6:	fc 01       	movw	r30, r24
     df8:	40 a1       	ldd	r20, Z+32	; 0x20
     dfa:	44 23       	and	r20, r20
     dfc:	a9 f0       	breq	.+42     	; 0xe28 <prvCopyDataFromQueue+0x32>
     dfe:	50 e0       	ldi	r21, 0x00	; 0
     e00:	26 81       	ldd	r18, Z+6	; 0x06
     e02:	37 81       	ldd	r19, Z+7	; 0x07
     e04:	24 0f       	add	r18, r20
     e06:	35 1f       	adc	r19, r21
     e08:	26 83       	std	Z+6, r18	; 0x06
     e0a:	37 83       	std	Z+7, r19	; 0x07
     e0c:	82 81       	ldd	r24, Z+2	; 0x02
     e0e:	93 81       	ldd	r25, Z+3	; 0x03
     e10:	28 17       	cp	r18, r24
     e12:	39 07       	cpc	r19, r25
     e14:	20 f0       	brcs	.+8      	; 0xe1e <prvCopyDataFromQueue+0x28>
     e16:	80 81       	ld	r24, Z
     e18:	91 81       	ldd	r25, Z+1	; 0x01
     e1a:	86 83       	std	Z+6, r24	; 0x06
     e1c:	97 83       	std	Z+7, r25	; 0x07
     e1e:	cb 01       	movw	r24, r22
     e20:	66 81       	ldd	r22, Z+6	; 0x06
     e22:	77 81       	ldd	r23, Z+7	; 0x07
     e24:	0e 94 ba 21 	call	0x4374	; 0x4374 <memcpy>
     e28:	08 95       	ret

00000e2a <prvUnlockQueue>:
     e2a:	ef 92       	push	r14
     e2c:	ff 92       	push	r15
     e2e:	0f 93       	push	r16
     e30:	1f 93       	push	r17
     e32:	cf 93       	push	r28
     e34:	8c 01       	movw	r16, r24
     e36:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e3a:	ff 93       	push	r31
     e3c:	f8 7f       	andi	r31, 0xF8	; 248
     e3e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e42:	fc 01       	movw	r30, r24
     e44:	c2 a1       	ldd	r28, Z+34	; 0x22
     e46:	1c 16       	cp	r1, r28
     e48:	ac f4       	brge	.+42     	; 0xe74 <prvUnlockQueue+0x4a>
     e4a:	83 89       	ldd	r24, Z+19	; 0x13
     e4c:	81 11       	cpse	r24, r1
     e4e:	06 c0       	rjmp	.+12     	; 0xe5c <prvUnlockQueue+0x32>
     e50:	11 c0       	rjmp	.+34     	; 0xe74 <prvUnlockQueue+0x4a>
     e52:	f8 01       	movw	r30, r16
     e54:	83 89       	ldd	r24, Z+19	; 0x13
     e56:	81 11       	cpse	r24, r1
     e58:	05 c0       	rjmp	.+10     	; 0xe64 <prvUnlockQueue+0x3a>
     e5a:	0c c0       	rjmp	.+24     	; 0xe74 <prvUnlockQueue+0x4a>
     e5c:	78 01       	movw	r14, r16
     e5e:	f3 e1       	ldi	r31, 0x13	; 19
     e60:	ef 0e       	add	r14, r31
     e62:	f1 1c       	adc	r15, r1
     e64:	c7 01       	movw	r24, r14
     e66:	0e 94 0b 0e 	call	0x1c16	; 0x1c16 <xTaskRemoveFromEventList>
     e6a:	81 11       	cpse	r24, r1
     e6c:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <vTaskMissedYield>
     e70:	c1 50       	subi	r28, 0x01	; 1
     e72:	79 f7       	brne	.-34     	; 0xe52 <prvUnlockQueue+0x28>
     e74:	8f ef       	ldi	r24, 0xFF	; 255
     e76:	f8 01       	movw	r30, r16
     e78:	82 a3       	std	Z+34, r24	; 0x22
     e7a:	ff 91       	pop	r31
     e7c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e80:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e84:	ff 93       	push	r31
     e86:	f8 7f       	andi	r31, 0xF8	; 248
     e88:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e8c:	f8 01       	movw	r30, r16
     e8e:	c1 a1       	ldd	r28, Z+33	; 0x21
     e90:	1c 16       	cp	r1, r28
     e92:	ac f4       	brge	.+42     	; 0xebe <prvUnlockQueue+0x94>
     e94:	80 85       	ldd	r24, Z+8	; 0x08
     e96:	81 11       	cpse	r24, r1
     e98:	06 c0       	rjmp	.+12     	; 0xea6 <prvUnlockQueue+0x7c>
     e9a:	11 c0       	rjmp	.+34     	; 0xebe <prvUnlockQueue+0x94>
     e9c:	f8 01       	movw	r30, r16
     e9e:	80 85       	ldd	r24, Z+8	; 0x08
     ea0:	81 11       	cpse	r24, r1
     ea2:	05 c0       	rjmp	.+10     	; 0xeae <prvUnlockQueue+0x84>
     ea4:	0c c0       	rjmp	.+24     	; 0xebe <prvUnlockQueue+0x94>
     ea6:	78 01       	movw	r14, r16
     ea8:	f8 e0       	ldi	r31, 0x08	; 8
     eaa:	ef 0e       	add	r14, r31
     eac:	f1 1c       	adc	r15, r1
     eae:	c7 01       	movw	r24, r14
     eb0:	0e 94 0b 0e 	call	0x1c16	; 0x1c16 <xTaskRemoveFromEventList>
     eb4:	81 11       	cpse	r24, r1
     eb6:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <vTaskMissedYield>
     eba:	c1 50       	subi	r28, 0x01	; 1
     ebc:	79 f7       	brne	.-34     	; 0xe9c <prvUnlockQueue+0x72>
     ebe:	8f ef       	ldi	r24, 0xFF	; 255
     ec0:	f8 01       	movw	r30, r16
     ec2:	81 a3       	std	Z+33, r24	; 0x21
     ec4:	ff 91       	pop	r31
     ec6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     eca:	cf 91       	pop	r28
     ecc:	1f 91       	pop	r17
     ece:	0f 91       	pop	r16
     ed0:	ff 90       	pop	r15
     ed2:	ef 90       	pop	r14
     ed4:	08 95       	ret

00000ed6 <xQueueGenericReset>:
     ed6:	cf 93       	push	r28
     ed8:	df 93       	push	r29
     eda:	ec 01       	movw	r28, r24
     edc:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ee0:	ff 93       	push	r31
     ee2:	f8 7f       	andi	r31, 0xF8	; 248
     ee4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ee8:	48 81       	ld	r20, Y
     eea:	59 81       	ldd	r21, Y+1	; 0x01
     eec:	28 a1       	ldd	r18, Y+32	; 0x20
     eee:	30 e0       	ldi	r19, 0x00	; 0
     ef0:	7f 8d       	ldd	r23, Y+31	; 0x1f
     ef2:	72 9f       	mul	r23, r18
     ef4:	c0 01       	movw	r24, r0
     ef6:	73 9f       	mul	r23, r19
     ef8:	90 0d       	add	r25, r0
     efa:	11 24       	eor	r1, r1
     efc:	fa 01       	movw	r30, r20
     efe:	e8 0f       	add	r30, r24
     f00:	f9 1f       	adc	r31, r25
     f02:	ea 83       	std	Y+2, r30	; 0x02
     f04:	fb 83       	std	Y+3, r31	; 0x03
     f06:	1e 8e       	std	Y+30, r1	; 0x1e
     f08:	4c 83       	std	Y+4, r20	; 0x04
     f0a:	5d 83       	std	Y+5, r21	; 0x05
     f0c:	82 1b       	sub	r24, r18
     f0e:	93 0b       	sbc	r25, r19
     f10:	84 0f       	add	r24, r20
     f12:	95 1f       	adc	r25, r21
     f14:	8e 83       	std	Y+6, r24	; 0x06
     f16:	9f 83       	std	Y+7, r25	; 0x07
     f18:	8f ef       	ldi	r24, 0xFF	; 255
     f1a:	89 a3       	std	Y+33, r24	; 0x21
     f1c:	8a a3       	std	Y+34, r24	; 0x22
     f1e:	61 11       	cpse	r22, r1
     f20:	0c c0       	rjmp	.+24     	; 0xf3a <xQueueGenericReset+0x64>
     f22:	88 85       	ldd	r24, Y+8	; 0x08
     f24:	88 23       	and	r24, r24
     f26:	89 f0       	breq	.+34     	; 0xf4a <xQueueGenericReset+0x74>
     f28:	ce 01       	movw	r24, r28
     f2a:	08 96       	adiw	r24, 0x08	; 8
     f2c:	0e 94 0b 0e 	call	0x1c16	; 0x1c16 <xTaskRemoveFromEventList>
     f30:	88 23       	and	r24, r24
     f32:	59 f0       	breq	.+22     	; 0xf4a <xQueueGenericReset+0x74>
     f34:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
     f38:	08 c0       	rjmp	.+16     	; 0xf4a <xQueueGenericReset+0x74>
     f3a:	ce 01       	movw	r24, r28
     f3c:	08 96       	adiw	r24, 0x08	; 8
     f3e:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
     f42:	ce 01       	movw	r24, r28
     f44:	43 96       	adiw	r24, 0x13	; 19
     f46:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
     f4a:	ff 91       	pop	r31
     f4c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f50:	81 e0       	ldi	r24, 0x01	; 1
     f52:	df 91       	pop	r29
     f54:	cf 91       	pop	r28
     f56:	08 95       	ret

00000f58 <xQueueGenericCreate>:
     f58:	ff 92       	push	r15
     f5a:	0f 93       	push	r16
     f5c:	1f 93       	push	r17
     f5e:	cf 93       	push	r28
     f60:	df 93       	push	r29
     f62:	08 2f       	mov	r16, r24
     f64:	16 2f       	mov	r17, r22
     f66:	f4 2e       	mov	r15, r20
     f68:	66 23       	and	r22, r22
     f6a:	c9 f0       	breq	.+50     	; 0xf9e <xQueueGenericCreate+0x46>
     f6c:	86 9f       	mul	r24, r22
     f6e:	c0 01       	movw	r24, r0
     f70:	11 24       	eor	r1, r1
     f72:	85 96       	adiw	r24, 0x25	; 37
     f74:	0e 94 22 04 	call	0x844	; 0x844 <pvPortMalloc>
     f78:	ec 01       	movw	r28, r24
     f7a:	00 97       	sbiw	r24, 0x00	; 0
     f7c:	49 f4       	brne	.+18     	; 0xf90 <xQueueGenericCreate+0x38>
     f7e:	16 c0       	rjmp	.+44     	; 0xfac <xQueueGenericCreate+0x54>
     f80:	0f 8f       	std	Y+31, r16	; 0x1f
     f82:	18 a3       	std	Y+32, r17	; 0x20
     f84:	61 e0       	ldi	r22, 0x01	; 1
     f86:	ce 01       	movw	r24, r28
     f88:	0e 94 6b 07 	call	0xed6	; 0xed6 <xQueueGenericReset>
     f8c:	fc a2       	std	Y+36, r15	; 0x24
     f8e:	0e c0       	rjmp	.+28     	; 0xfac <xQueueGenericCreate+0x54>
     f90:	85 96       	adiw	r24, 0x25	; 37
     f92:	88 83       	st	Y, r24
     f94:	99 83       	std	Y+1, r25	; 0x01
     f96:	f4 cf       	rjmp	.-24     	; 0xf80 <xQueueGenericCreate+0x28>
     f98:	c8 83       	st	Y, r28
     f9a:	d9 83       	std	Y+1, r29	; 0x01
     f9c:	f1 cf       	rjmp	.-30     	; 0xf80 <xQueueGenericCreate+0x28>
     f9e:	85 e2       	ldi	r24, 0x25	; 37
     fa0:	90 e0       	ldi	r25, 0x00	; 0
     fa2:	0e 94 22 04 	call	0x844	; 0x844 <pvPortMalloc>
     fa6:	ec 01       	movw	r28, r24
     fa8:	89 2b       	or	r24, r25
     faa:	b1 f7       	brne	.-20     	; 0xf98 <xQueueGenericCreate+0x40>
     fac:	ce 01       	movw	r24, r28
     fae:	df 91       	pop	r29
     fb0:	cf 91       	pop	r28
     fb2:	1f 91       	pop	r17
     fb4:	0f 91       	pop	r16
     fb6:	ff 90       	pop	r15
     fb8:	08 95       	ret

00000fba <xQueueGenericSend>:
     fba:	af 92       	push	r10
     fbc:	bf 92       	push	r11
     fbe:	cf 92       	push	r12
     fc0:	df 92       	push	r13
     fc2:	ef 92       	push	r14
     fc4:	ff 92       	push	r15
     fc6:	0f 93       	push	r16
     fc8:	1f 93       	push	r17
     fca:	cf 93       	push	r28
     fcc:	df 93       	push	r29
     fce:	cd b7       	in	r28, 0x3d	; 61
     fd0:	de b7       	in	r29, 0x3e	; 62
     fd2:	29 97       	sbiw	r28, 0x09	; 9
     fd4:	cd bf       	out	0x3d, r28	; 61
     fd6:	de bf       	out	0x3e, r29	; 62
     fd8:	7c 01       	movw	r14, r24
     fda:	5b 01       	movw	r10, r22
     fdc:	2e 83       	std	Y+6, r18	; 0x06
     fde:	3f 83       	std	Y+7, r19	; 0x07
     fe0:	48 87       	std	Y+8, r20	; 0x08
     fe2:	59 87       	std	Y+9, r21	; 0x09
     fe4:	10 e0       	ldi	r17, 0x00	; 0
     fe6:	6c 01       	movw	r12, r24
     fe8:	88 e0       	ldi	r24, 0x08	; 8
     fea:	c8 0e       	add	r12, r24
     fec:	d1 1c       	adc	r13, r1
     fee:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ff2:	ff 93       	push	r31
     ff4:	f8 7f       	andi	r31, 0xF8	; 248
     ff6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ffa:	f7 01       	movw	r30, r14
     ffc:	96 8d       	ldd	r25, Z+30	; 0x1e
     ffe:	87 8d       	ldd	r24, Z+31	; 0x1f
    1000:	98 17       	cp	r25, r24
    1002:	10 f0       	brcs	.+4      	; 0x1008 <xQueueGenericSend+0x4e>
    1004:	02 30       	cpi	r16, 0x02	; 2
    1006:	d1 f4       	brne	.+52     	; 0x103c <xQueueGenericSend+0x82>
    1008:	40 2f       	mov	r20, r16
    100a:	b5 01       	movw	r22, r10
    100c:	c7 01       	movw	r24, r14
    100e:	0e 94 b2 06 	call	0xd64	; 0xd64 <prvCopyDataToQueue>
    1012:	f7 01       	movw	r30, r14
    1014:	93 89       	ldd	r25, Z+19	; 0x13
    1016:	99 23       	and	r25, r25
    1018:	49 f0       	breq	.+18     	; 0x102c <xQueueGenericSend+0x72>
    101a:	c7 01       	movw	r24, r14
    101c:	43 96       	adiw	r24, 0x13	; 19
    101e:	0e 94 0b 0e 	call	0x1c16	; 0x1c16 <xTaskRemoveFromEventList>
    1022:	88 23       	and	r24, r24
    1024:	31 f0       	breq	.+12     	; 0x1032 <xQueueGenericSend+0x78>
    1026:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
    102a:	03 c0       	rjmp	.+6      	; 0x1032 <xQueueGenericSend+0x78>
    102c:	81 11       	cpse	r24, r1
    102e:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
    1032:	ff 91       	pop	r31
    1034:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1038:	81 e0       	ldi	r24, 0x01	; 1
    103a:	57 c0       	rjmp	.+174    	; 0x10ea <xQueueGenericSend+0x130>
    103c:	8e 81       	ldd	r24, Y+6	; 0x06
    103e:	9f 81       	ldd	r25, Y+7	; 0x07
    1040:	a8 85       	ldd	r26, Y+8	; 0x08
    1042:	b9 85       	ldd	r27, Y+9	; 0x09
    1044:	89 2b       	or	r24, r25
    1046:	8a 2b       	or	r24, r26
    1048:	8b 2b       	or	r24, r27
    104a:	29 f4       	brne	.+10     	; 0x1056 <xQueueGenericSend+0x9c>
    104c:	ff 91       	pop	r31
    104e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1052:	80 e0       	ldi	r24, 0x00	; 0
    1054:	4a c0       	rjmp	.+148    	; 0x10ea <xQueueGenericSend+0x130>
    1056:	11 11       	cpse	r17, r1
    1058:	05 c0       	rjmp	.+10     	; 0x1064 <xQueueGenericSend+0xaa>
    105a:	ce 01       	movw	r24, r28
    105c:	01 96       	adiw	r24, 0x01	; 1
    105e:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vTaskInternalSetTimeOutState>
    1062:	11 e0       	ldi	r17, 0x01	; 1
    1064:	ff 91       	pop	r31
    1066:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    106a:	0e 94 96 0b 	call	0x172c	; 0x172c <vTaskSuspendAll>
    106e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1072:	ff 93       	push	r31
    1074:	f8 7f       	andi	r31, 0xF8	; 248
    1076:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    107a:	f7 01       	movw	r30, r14
    107c:	81 a1       	ldd	r24, Z+33	; 0x21
    107e:	8f 3f       	cpi	r24, 0xFF	; 255
    1080:	09 f4       	brne	.+2      	; 0x1084 <xQueueGenericSend+0xca>
    1082:	11 a2       	std	Z+33, r1	; 0x21
    1084:	f7 01       	movw	r30, r14
    1086:	82 a1       	ldd	r24, Z+34	; 0x22
    1088:	8f 3f       	cpi	r24, 0xFF	; 255
    108a:	09 f4       	brne	.+2      	; 0x108e <xQueueGenericSend+0xd4>
    108c:	12 a2       	std	Z+34, r1	; 0x22
    108e:	ff 91       	pop	r31
    1090:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1094:	be 01       	movw	r22, r28
    1096:	6a 5f       	subi	r22, 0xFA	; 250
    1098:	7f 4f       	sbci	r23, 0xFF	; 255
    109a:	ce 01       	movw	r24, r28
    109c:	01 96       	adiw	r24, 0x01	; 1
    109e:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <xTaskCheckForTimeOut>
    10a2:	81 11       	cpse	r24, r1
    10a4:	1c c0       	rjmp	.+56     	; 0x10de <xQueueGenericSend+0x124>
    10a6:	c7 01       	movw	r24, r14
    10a8:	0e 94 9f 06 	call	0xd3e	; 0xd3e <prvIsQueueFull>
    10ac:	88 23       	and	r24, r24
    10ae:	89 f0       	breq	.+34     	; 0x10d2 <xQueueGenericSend+0x118>
    10b0:	4e 81       	ldd	r20, Y+6	; 0x06
    10b2:	5f 81       	ldd	r21, Y+7	; 0x07
    10b4:	68 85       	ldd	r22, Y+8	; 0x08
    10b6:	79 85       	ldd	r23, Y+9	; 0x09
    10b8:	c6 01       	movw	r24, r12
    10ba:	0e 94 ad 0d 	call	0x1b5a	; 0x1b5a <vTaskPlaceOnEventList>
    10be:	c7 01       	movw	r24, r14
    10c0:	0e 94 15 07 	call	0xe2a	; 0xe2a <prvUnlockQueue>
    10c4:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
    10c8:	81 11       	cpse	r24, r1
    10ca:	91 cf       	rjmp	.-222    	; 0xfee <xQueueGenericSend+0x34>
    10cc:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
    10d0:	8e cf       	rjmp	.-228    	; 0xfee <xQueueGenericSend+0x34>
    10d2:	c7 01       	movw	r24, r14
    10d4:	0e 94 15 07 	call	0xe2a	; 0xe2a <prvUnlockQueue>
    10d8:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
    10dc:	88 cf       	rjmp	.-240    	; 0xfee <xQueueGenericSend+0x34>
    10de:	c7 01       	movw	r24, r14
    10e0:	0e 94 15 07 	call	0xe2a	; 0xe2a <prvUnlockQueue>
    10e4:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
    10e8:	80 e0       	ldi	r24, 0x00	; 0
    10ea:	29 96       	adiw	r28, 0x09	; 9
    10ec:	cd bf       	out	0x3d, r28	; 61
    10ee:	de bf       	out	0x3e, r29	; 62
    10f0:	df 91       	pop	r29
    10f2:	cf 91       	pop	r28
    10f4:	1f 91       	pop	r17
    10f6:	0f 91       	pop	r16
    10f8:	ff 90       	pop	r15
    10fa:	ef 90       	pop	r14
    10fc:	df 90       	pop	r13
    10fe:	cf 90       	pop	r12
    1100:	bf 90       	pop	r11
    1102:	af 90       	pop	r10
    1104:	08 95       	ret

00001106 <xQueueGenericSendFromISR>:
    1106:	af 92       	push	r10
    1108:	bf 92       	push	r11
    110a:	cf 92       	push	r12
    110c:	df 92       	push	r13
    110e:	ff 92       	push	r15
    1110:	0f 93       	push	r16
    1112:	1f 93       	push	r17
    1114:	cf 93       	push	r28
    1116:	df 93       	push	r29
    1118:	ec 01       	movw	r28, r24
    111a:	6b 01       	movw	r12, r22
    111c:	5a 01       	movw	r10, r20
    111e:	02 2f       	mov	r16, r18
    1120:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <_portSetInterruptMaskFromIsr>
    1124:	f8 2e       	mov	r15, r24
    1126:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1128:	8f 8d       	ldd	r24, Y+31	; 0x1f
    112a:	98 17       	cp	r25, r24
    112c:	10 f0       	brcs	.+4      	; 0x1132 <xQueueGenericSendFromISR+0x2c>
    112e:	02 30       	cpi	r16, 0x02	; 2
    1130:	e1 f4       	brne	.+56     	; 0x116a <xQueueGenericSendFromISR+0x64>
    1132:	1a a1       	ldd	r17, Y+34	; 0x22
    1134:	40 2f       	mov	r20, r16
    1136:	b6 01       	movw	r22, r12
    1138:	ce 01       	movw	r24, r28
    113a:	0e 94 b2 06 	call	0xd64	; 0xd64 <prvCopyDataToQueue>
    113e:	1f 3f       	cpi	r17, 0xFF	; 255
    1140:	81 f4       	brne	.+32     	; 0x1162 <xQueueGenericSendFromISR+0x5c>
    1142:	8b 89       	ldd	r24, Y+19	; 0x13
    1144:	88 23       	and	r24, r24
    1146:	99 f0       	breq	.+38     	; 0x116e <xQueueGenericSendFromISR+0x68>
    1148:	ce 01       	movw	r24, r28
    114a:	43 96       	adiw	r24, 0x13	; 19
    114c:	0e 94 0b 0e 	call	0x1c16	; 0x1c16 <xTaskRemoveFromEventList>
    1150:	88 23       	and	r24, r24
    1152:	79 f0       	breq	.+30     	; 0x1172 <xQueueGenericSendFromISR+0x6c>
    1154:	a1 14       	cp	r10, r1
    1156:	b1 04       	cpc	r11, r1
    1158:	71 f0       	breq	.+28     	; 0x1176 <xQueueGenericSendFromISR+0x70>
    115a:	81 e0       	ldi	r24, 0x01	; 1
    115c:	f5 01       	movw	r30, r10
    115e:	80 83       	st	Z, r24
    1160:	0b c0       	rjmp	.+22     	; 0x1178 <xQueueGenericSendFromISR+0x72>
    1162:	1f 5f       	subi	r17, 0xFF	; 255
    1164:	1a a3       	std	Y+34, r17	; 0x22
    1166:	81 e0       	ldi	r24, 0x01	; 1
    1168:	07 c0       	rjmp	.+14     	; 0x1178 <xQueueGenericSendFromISR+0x72>
    116a:	80 e0       	ldi	r24, 0x00	; 0
    116c:	05 c0       	rjmp	.+10     	; 0x1178 <xQueueGenericSendFromISR+0x72>
    116e:	81 e0       	ldi	r24, 0x01	; 1
    1170:	03 c0       	rjmp	.+6      	; 0x1178 <xQueueGenericSendFromISR+0x72>
    1172:	81 e0       	ldi	r24, 0x01	; 1
    1174:	01 c0       	rjmp	.+2      	; 0x1178 <xQueueGenericSendFromISR+0x72>
    1176:	81 e0       	ldi	r24, 0x01	; 1
    1178:	f0 92 a2 00 	sts	0x00A2, r15	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    117c:	df 91       	pop	r29
    117e:	cf 91       	pop	r28
    1180:	1f 91       	pop	r17
    1182:	0f 91       	pop	r16
    1184:	ff 90       	pop	r15
    1186:	df 90       	pop	r13
    1188:	cf 90       	pop	r12
    118a:	bf 90       	pop	r11
    118c:	af 90       	pop	r10
    118e:	08 95       	ret

00001190 <xQueueReceive>:
    1190:	af 92       	push	r10
    1192:	bf 92       	push	r11
    1194:	cf 92       	push	r12
    1196:	df 92       	push	r13
    1198:	ef 92       	push	r14
    119a:	ff 92       	push	r15
    119c:	0f 93       	push	r16
    119e:	1f 93       	push	r17
    11a0:	cf 93       	push	r28
    11a2:	df 93       	push	r29
    11a4:	cd b7       	in	r28, 0x3d	; 61
    11a6:	de b7       	in	r29, 0x3e	; 62
    11a8:	29 97       	sbiw	r28, 0x09	; 9
    11aa:	cd bf       	out	0x3d, r28	; 61
    11ac:	de bf       	out	0x3e, r29	; 62
    11ae:	8c 01       	movw	r16, r24
    11b0:	5b 01       	movw	r10, r22
    11b2:	2e 83       	std	Y+6, r18	; 0x06
    11b4:	3f 83       	std	Y+7, r19	; 0x07
    11b6:	48 87       	std	Y+8, r20	; 0x08
    11b8:	59 87       	std	Y+9, r21	; 0x09
    11ba:	e1 2c       	mov	r14, r1
    11bc:	6c 01       	movw	r12, r24
    11be:	83 e1       	ldi	r24, 0x13	; 19
    11c0:	c8 0e       	add	r12, r24
    11c2:	d1 1c       	adc	r13, r1
    11c4:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11c8:	ff 93       	push	r31
    11ca:	f8 7f       	andi	r31, 0xF8	; 248
    11cc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11d0:	f8 01       	movw	r30, r16
    11d2:	f6 8c       	ldd	r15, Z+30	; 0x1e
    11d4:	ff 20       	and	r15, r15
    11d6:	b1 f0       	breq	.+44     	; 0x1204 <xQueueReceive+0x74>
    11d8:	b5 01       	movw	r22, r10
    11da:	c8 01       	movw	r24, r16
    11dc:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <prvCopyDataFromQueue>
    11e0:	fa 94       	dec	r15
    11e2:	f8 01       	movw	r30, r16
    11e4:	f6 8e       	std	Z+30, r15	; 0x1e
    11e6:	80 85       	ldd	r24, Z+8	; 0x08
    11e8:	88 23       	and	r24, r24
    11ea:	39 f0       	breq	.+14     	; 0x11fa <xQueueReceive+0x6a>
    11ec:	c8 01       	movw	r24, r16
    11ee:	08 96       	adiw	r24, 0x08	; 8
    11f0:	0e 94 0b 0e 	call	0x1c16	; 0x1c16 <xTaskRemoveFromEventList>
    11f4:	81 11       	cpse	r24, r1
    11f6:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
    11fa:	ff 91       	pop	r31
    11fc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1200:	81 e0       	ldi	r24, 0x01	; 1
    1202:	5e c0       	rjmp	.+188    	; 0x12c0 <xQueueReceive+0x130>
    1204:	8e 81       	ldd	r24, Y+6	; 0x06
    1206:	9f 81       	ldd	r25, Y+7	; 0x07
    1208:	a8 85       	ldd	r26, Y+8	; 0x08
    120a:	b9 85       	ldd	r27, Y+9	; 0x09
    120c:	89 2b       	or	r24, r25
    120e:	8a 2b       	or	r24, r26
    1210:	8b 2b       	or	r24, r27
    1212:	29 f4       	brne	.+10     	; 0x121e <xQueueReceive+0x8e>
    1214:	ff 91       	pop	r31
    1216:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    121a:	80 e0       	ldi	r24, 0x00	; 0
    121c:	51 c0       	rjmp	.+162    	; 0x12c0 <xQueueReceive+0x130>
    121e:	e1 10       	cpse	r14, r1
    1220:	06 c0       	rjmp	.+12     	; 0x122e <xQueueReceive+0x9e>
    1222:	ce 01       	movw	r24, r28
    1224:	01 96       	adiw	r24, 0x01	; 1
    1226:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vTaskInternalSetTimeOutState>
    122a:	ee 24       	eor	r14, r14
    122c:	e3 94       	inc	r14
    122e:	ff 91       	pop	r31
    1230:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1234:	0e 94 96 0b 	call	0x172c	; 0x172c <vTaskSuspendAll>
    1238:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    123c:	ff 93       	push	r31
    123e:	f8 7f       	andi	r31, 0xF8	; 248
    1240:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1244:	f8 01       	movw	r30, r16
    1246:	81 a1       	ldd	r24, Z+33	; 0x21
    1248:	8f 3f       	cpi	r24, 0xFF	; 255
    124a:	09 f4       	brne	.+2      	; 0x124e <xQueueReceive+0xbe>
    124c:	11 a2       	std	Z+33, r1	; 0x21
    124e:	f8 01       	movw	r30, r16
    1250:	82 a1       	ldd	r24, Z+34	; 0x22
    1252:	8f 3f       	cpi	r24, 0xFF	; 255
    1254:	09 f4       	brne	.+2      	; 0x1258 <xQueueReceive+0xc8>
    1256:	12 a2       	std	Z+34, r1	; 0x22
    1258:	ff 91       	pop	r31
    125a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    125e:	be 01       	movw	r22, r28
    1260:	6a 5f       	subi	r22, 0xFA	; 250
    1262:	7f 4f       	sbci	r23, 0xFF	; 255
    1264:	ce 01       	movw	r24, r28
    1266:	01 96       	adiw	r24, 0x01	; 1
    1268:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <xTaskCheckForTimeOut>
    126c:	81 11       	cpse	r24, r1
    126e:	1c c0       	rjmp	.+56     	; 0x12a8 <xQueueReceive+0x118>
    1270:	c8 01       	movw	r24, r16
    1272:	0e 94 90 06 	call	0xd20	; 0xd20 <prvIsQueueEmpty>
    1276:	88 23       	and	r24, r24
    1278:	89 f0       	breq	.+34     	; 0x129c <xQueueReceive+0x10c>
    127a:	4e 81       	ldd	r20, Y+6	; 0x06
    127c:	5f 81       	ldd	r21, Y+7	; 0x07
    127e:	68 85       	ldd	r22, Y+8	; 0x08
    1280:	79 85       	ldd	r23, Y+9	; 0x09
    1282:	c6 01       	movw	r24, r12
    1284:	0e 94 ad 0d 	call	0x1b5a	; 0x1b5a <vTaskPlaceOnEventList>
    1288:	c8 01       	movw	r24, r16
    128a:	0e 94 15 07 	call	0xe2a	; 0xe2a <prvUnlockQueue>
    128e:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
    1292:	81 11       	cpse	r24, r1
    1294:	97 cf       	rjmp	.-210    	; 0x11c4 <xQueueReceive+0x34>
    1296:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
    129a:	94 cf       	rjmp	.-216    	; 0x11c4 <xQueueReceive+0x34>
    129c:	c8 01       	movw	r24, r16
    129e:	0e 94 15 07 	call	0xe2a	; 0xe2a <prvUnlockQueue>
    12a2:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
    12a6:	8e cf       	rjmp	.-228    	; 0x11c4 <xQueueReceive+0x34>
    12a8:	c8 01       	movw	r24, r16
    12aa:	0e 94 15 07 	call	0xe2a	; 0xe2a <prvUnlockQueue>
    12ae:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
    12b2:	c8 01       	movw	r24, r16
    12b4:	0e 94 90 06 	call	0xd20	; 0xd20 <prvIsQueueEmpty>
    12b8:	88 23       	and	r24, r24
    12ba:	09 f4       	brne	.+2      	; 0x12be <xQueueReceive+0x12e>
    12bc:	83 cf       	rjmp	.-250    	; 0x11c4 <xQueueReceive+0x34>
    12be:	80 e0       	ldi	r24, 0x00	; 0
    12c0:	29 96       	adiw	r28, 0x09	; 9
    12c2:	cd bf       	out	0x3d, r28	; 61
    12c4:	de bf       	out	0x3e, r29	; 62
    12c6:	df 91       	pop	r29
    12c8:	cf 91       	pop	r28
    12ca:	1f 91       	pop	r17
    12cc:	0f 91       	pop	r16
    12ce:	ff 90       	pop	r15
    12d0:	ef 90       	pop	r14
    12d2:	df 90       	pop	r13
    12d4:	cf 90       	pop	r12
    12d6:	bf 90       	pop	r11
    12d8:	af 90       	pop	r10
    12da:	08 95       	ret

000012dc <uxQueueMessagesWaiting>:
    12dc:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12e0:	ff 93       	push	r31
    12e2:	f8 7f       	andi	r31, 0xF8	; 248
    12e4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12e8:	fc 01       	movw	r30, r24
    12ea:	86 8d       	ldd	r24, Z+30	; 0x1e
    12ec:	ff 91       	pop	r31
    12ee:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12f2:	08 95       	ret

000012f4 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    12f4:	cf 93       	push	r28
    12f6:	df 93       	push	r29
    12f8:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    12fa:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12fe:	ff 93       	push	r31
    1300:	f8 7f       	andi	r31, 0xF8	; 248
    1302:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1306:	89 a1       	ldd	r24, Y+33	; 0x21
    1308:	8f 3f       	cpi	r24, 0xFF	; 255
    130a:	09 f4       	brne	.+2      	; 0x130e <vQueueWaitForMessageRestricted+0x1a>
    130c:	19 a2       	std	Y+33, r1	; 0x21
    130e:	8a a1       	ldd	r24, Y+34	; 0x22
    1310:	8f 3f       	cpi	r24, 0xFF	; 255
    1312:	09 f4       	brne	.+2      	; 0x1316 <vQueueWaitForMessageRestricted+0x22>
    1314:	1a a2       	std	Y+34, r1	; 0x22
    1316:	ff 91       	pop	r31
    1318:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    131c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    131e:	81 11       	cpse	r24, r1
    1320:	04 c0       	rjmp	.+8      	; 0x132a <vQueueWaitForMessageRestricted+0x36>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1322:	ce 01       	movw	r24, r28
    1324:	43 96       	adiw	r24, 0x13	; 19
    1326:	0e 94 ea 0d 	call	0x1bd4	; 0x1bd4 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    132a:	ce 01       	movw	r24, r28
    132c:	0e 94 15 07 	call	0xe2a	; 0xe2a <prvUnlockQueue>
	}
    1330:	df 91       	pop	r29
    1332:	cf 91       	pop	r28
    1334:	08 95       	ret

00001336 <prvResetNextTaskUnblockTime>:
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
		}
		taskEXIT_CRITICAL();

		return ulReturn;
	}
    1336:	e0 91 aa 2e 	lds	r30, 0x2EAA	; 0x802eaa <pxDelayedTaskList>
    133a:	f0 91 ab 2e 	lds	r31, 0x2EAB	; 0x802eab <pxDelayedTaskList+0x1>
    133e:	80 81       	ld	r24, Z
    1340:	81 11       	cpse	r24, r1
    1342:	0c c0       	rjmp	.+24     	; 0x135c <prvResetNextTaskUnblockTime+0x26>
    1344:	8f ef       	ldi	r24, 0xFF	; 255
    1346:	9f ef       	ldi	r25, 0xFF	; 255
    1348:	dc 01       	movw	r26, r24
    134a:	80 93 83 2e 	sts	0x2E83, r24	; 0x802e83 <xNextTaskUnblockTime>
    134e:	90 93 84 2e 	sts	0x2E84, r25	; 0x802e84 <xNextTaskUnblockTime+0x1>
    1352:	a0 93 85 2e 	sts	0x2E85, r26	; 0x802e85 <xNextTaskUnblockTime+0x2>
    1356:	b0 93 86 2e 	sts	0x2E86, r27	; 0x802e86 <xNextTaskUnblockTime+0x3>
    135a:	08 95       	ret
    135c:	e0 91 aa 2e 	lds	r30, 0x2EAA	; 0x802eaa <pxDelayedTaskList>
    1360:	f0 91 ab 2e 	lds	r31, 0x2EAB	; 0x802eab <pxDelayedTaskList+0x1>
    1364:	07 80       	ldd	r0, Z+7	; 0x07
    1366:	f0 85       	ldd	r31, Z+8	; 0x08
    1368:	e0 2d       	mov	r30, r0
    136a:	00 84       	ldd	r0, Z+8	; 0x08
    136c:	f1 85       	ldd	r31, Z+9	; 0x09
    136e:	e0 2d       	mov	r30, r0
    1370:	82 81       	ldd	r24, Z+2	; 0x02
    1372:	93 81       	ldd	r25, Z+3	; 0x03
    1374:	a4 81       	ldd	r26, Z+4	; 0x04
    1376:	b5 81       	ldd	r27, Z+5	; 0x05
    1378:	80 93 83 2e 	sts	0x2E83, r24	; 0x802e83 <xNextTaskUnblockTime>
    137c:	90 93 84 2e 	sts	0x2E84, r25	; 0x802e84 <xNextTaskUnblockTime+0x1>
    1380:	a0 93 85 2e 	sts	0x2E85, r26	; 0x802e85 <xNextTaskUnblockTime+0x2>
    1384:	b0 93 86 2e 	sts	0x2E86, r27	; 0x802e86 <xNextTaskUnblockTime+0x3>
    1388:	08 95       	ret

0000138a <prvAddCurrentTaskToDelayedList>:
    138a:	8f 92       	push	r8
    138c:	9f 92       	push	r9
    138e:	af 92       	push	r10
    1390:	bf 92       	push	r11
    1392:	cf 92       	push	r12
    1394:	df 92       	push	r13
    1396:	ef 92       	push	r14
    1398:	ff 92       	push	r15
    139a:	cf 93       	push	r28
    139c:	6b 01       	movw	r12, r22
    139e:	7c 01       	movw	r14, r24
    13a0:	c4 2f       	mov	r28, r20
    13a2:	80 90 8d 2e 	lds	r8, 0x2E8D	; 0x802e8d <xTickCount>
    13a6:	90 90 8e 2e 	lds	r9, 0x2E8E	; 0x802e8e <xTickCount+0x1>
    13aa:	a0 90 8f 2e 	lds	r10, 0x2E8F	; 0x802e8f <xTickCount+0x2>
    13ae:	b0 90 90 2e 	lds	r11, 0x2E90	; 0x802e90 <xTickCount+0x3>
    13b2:	80 91 ee 2e 	lds	r24, 0x2EEE	; 0x802eee <pxCurrentTCB>
    13b6:	90 91 ef 2e 	lds	r25, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    13ba:	02 96       	adiw	r24, 0x02	; 2
    13bc:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
    13c0:	8f ef       	ldi	r24, 0xFF	; 255
    13c2:	c8 16       	cp	r12, r24
    13c4:	d8 06       	cpc	r13, r24
    13c6:	e8 06       	cpc	r14, r24
    13c8:	f8 06       	cpc	r15, r24
    13ca:	69 f4       	brne	.+26     	; 0x13e6 <prvAddCurrentTaskToDelayedList+0x5c>
    13cc:	cc 23       	and	r28, r28
    13ce:	59 f0       	breq	.+22     	; 0x13e6 <prvAddCurrentTaskToDelayedList+0x5c>
    13d0:	60 91 ee 2e 	lds	r22, 0x2EEE	; 0x802eee <pxCurrentTCB>
    13d4:	70 91 ef 2e 	lds	r23, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    13d8:	6e 5f       	subi	r22, 0xFE	; 254
    13da:	7f 4f       	sbci	r23, 0xFF	; 255
    13dc:	82 e9       	ldi	r24, 0x92	; 146
    13de:	9e e2       	ldi	r25, 0x2E	; 46
    13e0:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    13e4:	3f c0       	rjmp	.+126    	; 0x1464 <prvAddCurrentTaskToDelayedList+0xda>
    13e6:	c8 0c       	add	r12, r8
    13e8:	d9 1c       	adc	r13, r9
    13ea:	ea 1c       	adc	r14, r10
    13ec:	fb 1c       	adc	r15, r11
    13ee:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    13f2:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    13f6:	c2 82       	std	Z+2, r12	; 0x02
    13f8:	d3 82       	std	Z+3, r13	; 0x03
    13fa:	e4 82       	std	Z+4, r14	; 0x04
    13fc:	f5 82       	std	Z+5, r15	; 0x05
    13fe:	c8 14       	cp	r12, r8
    1400:	d9 04       	cpc	r13, r9
    1402:	ea 04       	cpc	r14, r10
    1404:	fb 04       	cpc	r15, r11
    1406:	68 f4       	brcc	.+26     	; 0x1422 <prvAddCurrentTaskToDelayedList+0x98>
    1408:	60 91 ee 2e 	lds	r22, 0x2EEE	; 0x802eee <pxCurrentTCB>
    140c:	70 91 ef 2e 	lds	r23, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1410:	80 91 a8 2e 	lds	r24, 0x2EA8	; 0x802ea8 <pxOverflowDelayedTaskList>
    1414:	90 91 a9 2e 	lds	r25, 0x2EA9	; 0x802ea9 <pxOverflowDelayedTaskList+0x1>
    1418:	6e 5f       	subi	r22, 0xFE	; 254
    141a:	7f 4f       	sbci	r23, 0xFF	; 255
    141c:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListInsert>
    1420:	21 c0       	rjmp	.+66     	; 0x1464 <prvAddCurrentTaskToDelayedList+0xda>
    1422:	60 91 ee 2e 	lds	r22, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1426:	70 91 ef 2e 	lds	r23, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    142a:	80 91 aa 2e 	lds	r24, 0x2EAA	; 0x802eaa <pxDelayedTaskList>
    142e:	90 91 ab 2e 	lds	r25, 0x2EAB	; 0x802eab <pxDelayedTaskList+0x1>
    1432:	6e 5f       	subi	r22, 0xFE	; 254
    1434:	7f 4f       	sbci	r23, 0xFF	; 255
    1436:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListInsert>
    143a:	80 91 83 2e 	lds	r24, 0x2E83	; 0x802e83 <xNextTaskUnblockTime>
    143e:	90 91 84 2e 	lds	r25, 0x2E84	; 0x802e84 <xNextTaskUnblockTime+0x1>
    1442:	a0 91 85 2e 	lds	r26, 0x2E85	; 0x802e85 <xNextTaskUnblockTime+0x2>
    1446:	b0 91 86 2e 	lds	r27, 0x2E86	; 0x802e86 <xNextTaskUnblockTime+0x3>
    144a:	c8 16       	cp	r12, r24
    144c:	d9 06       	cpc	r13, r25
    144e:	ea 06       	cpc	r14, r26
    1450:	fb 06       	cpc	r15, r27
    1452:	40 f4       	brcc	.+16     	; 0x1464 <prvAddCurrentTaskToDelayedList+0xda>
    1454:	c0 92 83 2e 	sts	0x2E83, r12	; 0x802e83 <xNextTaskUnblockTime>
    1458:	d0 92 84 2e 	sts	0x2E84, r13	; 0x802e84 <xNextTaskUnblockTime+0x1>
    145c:	e0 92 85 2e 	sts	0x2E85, r14	; 0x802e85 <xNextTaskUnblockTime+0x2>
    1460:	f0 92 86 2e 	sts	0x2E86, r15	; 0x802e86 <xNextTaskUnblockTime+0x3>
    1464:	cf 91       	pop	r28
    1466:	ff 90       	pop	r15
    1468:	ef 90       	pop	r14
    146a:	df 90       	pop	r13
    146c:	cf 90       	pop	r12
    146e:	bf 90       	pop	r11
    1470:	af 90       	pop	r10
    1472:	9f 90       	pop	r9
    1474:	8f 90       	pop	r8
    1476:	08 95       	ret

00001478 <prvIdleTask>:
    1478:	c2 ec       	ldi	r28, 0xC2	; 194
    147a:	de e2       	ldi	r29, 0x2E	; 46
    147c:	88 81       	ld	r24, Y
    147e:	82 30       	cpi	r24, 0x02	; 2
    1480:	10 f0       	brcs	.+4      	; 0x1486 <prvIdleTask+0xe>
    1482:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
    1486:	0e 94 f7 14 	call	0x29ee	; 0x29ee <vApplicationIdleHook>
    148a:	f8 cf       	rjmp	.-16     	; 0x147c <prvIdleTask+0x4>

0000148c <xTaskCreate>:
    148c:	4f 92       	push	r4
    148e:	5f 92       	push	r5
    1490:	6f 92       	push	r6
    1492:	7f 92       	push	r7
    1494:	8f 92       	push	r8
    1496:	9f 92       	push	r9
    1498:	af 92       	push	r10
    149a:	bf 92       	push	r11
    149c:	cf 92       	push	r12
    149e:	df 92       	push	r13
    14a0:	ef 92       	push	r14
    14a2:	ff 92       	push	r15
    14a4:	0f 93       	push	r16
    14a6:	cf 93       	push	r28
    14a8:	df 93       	push	r29
    14aa:	4c 01       	movw	r8, r24
    14ac:	6b 01       	movw	r12, r22
    14ae:	5a 01       	movw	r10, r20
    14b0:	29 01       	movw	r4, r18
    14b2:	ca 01       	movw	r24, r20
    14b4:	0e 94 22 04 	call	0x844	; 0x844 <pvPortMalloc>
    14b8:	3c 01       	movw	r6, r24
    14ba:	89 2b       	or	r24, r25
    14bc:	09 f4       	brne	.+2      	; 0x14c0 <xTaskCreate+0x34>
    14be:	ea c0       	rjmp	.+468    	; 0x1694 <xTaskCreate+0x208>
    14c0:	8c e2       	ldi	r24, 0x2C	; 44
    14c2:	90 e0       	ldi	r25, 0x00	; 0
    14c4:	0e 94 22 04 	call	0x844	; 0x844 <pvPortMalloc>
    14c8:	ec 01       	movw	r28, r24
    14ca:	89 2b       	or	r24, r25
    14cc:	b1 f0       	breq	.+44     	; 0x14fa <xTaskCreate+0x6e>
    14ce:	6b 8e       	std	Y+27, r6	; 0x1b
    14d0:	7c 8e       	std	Y+28, r7	; 0x1c
    14d2:	a5 01       	movw	r20, r10
    14d4:	65 ea       	ldi	r22, 0xA5	; 165
    14d6:	70 e0       	ldi	r23, 0x00	; 0
    14d8:	c3 01       	movw	r24, r6
    14da:	0e 94 c3 21 	call	0x4386	; 0x4386 <memset>
    14de:	21 e0       	ldi	r18, 0x01	; 1
    14e0:	a2 1a       	sub	r10, r18
    14e2:	b1 08       	sbc	r11, r1
    14e4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    14e6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    14e8:	a8 0e       	add	r10, r24
    14ea:	b9 1e       	adc	r11, r25
    14ec:	d6 01       	movw	r26, r12
    14ee:	8c 91       	ld	r24, X
    14f0:	8d 8f       	std	Y+29, r24	; 0x1d
    14f2:	8c 91       	ld	r24, X
    14f4:	81 11       	cpse	r24, r1
    14f6:	05 c0       	rjmp	.+10     	; 0x1502 <xTaskCreate+0x76>
    14f8:	18 c0       	rjmp	.+48     	; 0x152a <xTaskCreate+0x9e>
    14fa:	c3 01       	movw	r24, r6
    14fc:	0e 94 48 04 	call	0x890	; 0x890 <vPortFree>
    1500:	c9 c0       	rjmp	.+402    	; 0x1694 <xTaskCreate+0x208>
    1502:	ae 01       	movw	r20, r28
    1504:	42 5e       	subi	r20, 0xE2	; 226
    1506:	5f 4f       	sbci	r21, 0xFF	; 255
    1508:	f6 01       	movw	r30, r12
    150a:	31 96       	adiw	r30, 0x01	; 1
    150c:	b8 e0       	ldi	r27, 0x08	; 8
    150e:	cb 0e       	add	r12, r27
    1510:	d1 1c       	adc	r13, r1
    1512:	cf 01       	movw	r24, r30
    1514:	21 91       	ld	r18, Z+
    1516:	da 01       	movw	r26, r20
    1518:	2d 93       	st	X+, r18
    151a:	ad 01       	movw	r20, r26
    151c:	dc 01       	movw	r26, r24
    151e:	8c 91       	ld	r24, X
    1520:	88 23       	and	r24, r24
    1522:	19 f0       	breq	.+6      	; 0x152a <xTaskCreate+0x9e>
    1524:	ec 15       	cp	r30, r12
    1526:	fd 05       	cpc	r31, r13
    1528:	a1 f7       	brne	.-24     	; 0x1512 <xTaskCreate+0x86>
    152a:	1c a2       	std	Y+36, r1	; 0x24
    152c:	04 30       	cpi	r16, 0x04	; 4
    152e:	08 f0       	brcs	.+2      	; 0x1532 <xTaskCreate+0xa6>
    1530:	03 e0       	ldi	r16, 0x03	; 3
    1532:	0a 8f       	std	Y+26, r16	; 0x1a
    1534:	6e 01       	movw	r12, r28
    1536:	b2 e0       	ldi	r27, 0x02	; 2
    1538:	cb 0e       	add	r12, r27
    153a:	d1 1c       	adc	r13, r1
    153c:	c6 01       	movw	r24, r12
    153e:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <vListInitialiseItem>
    1542:	ce 01       	movw	r24, r28
    1544:	0e 96       	adiw	r24, 0x0e	; 14
    1546:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <vListInitialiseItem>
    154a:	ca 87       	std	Y+10, r28	; 0x0a
    154c:	db 87       	std	Y+11, r29	; 0x0b
    154e:	84 e0       	ldi	r24, 0x04	; 4
    1550:	90 e0       	ldi	r25, 0x00	; 0
    1552:	a0 e0       	ldi	r26, 0x00	; 0
    1554:	b0 e0       	ldi	r27, 0x00	; 0
    1556:	80 1b       	sub	r24, r16
    1558:	91 09       	sbc	r25, r1
    155a:	a1 09       	sbc	r26, r1
    155c:	b1 09       	sbc	r27, r1
    155e:	8e 87       	std	Y+14, r24	; 0x0e
    1560:	9f 87       	std	Y+15, r25	; 0x0f
    1562:	a8 8b       	std	Y+16, r26	; 0x10
    1564:	b9 8b       	std	Y+17, r27	; 0x11
    1566:	ce 8b       	std	Y+22, r28	; 0x16
    1568:	df 8b       	std	Y+23, r29	; 0x17
    156a:	1f a2       	std	Y+39, r1	; 0x27
    156c:	18 a6       	std	Y+40, r1	; 0x28
    156e:	19 a6       	std	Y+41, r1	; 0x29
    1570:	1a a6       	std	Y+42, r1	; 0x2a
    1572:	1b a6       	std	Y+43, r1	; 0x2b
    1574:	a2 01       	movw	r20, r4
    1576:	b4 01       	movw	r22, r8
    1578:	c5 01       	movw	r24, r10
    157a:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <pxPortInitialiseStack>
    157e:	88 83       	st	Y, r24
    1580:	99 83       	std	Y+1, r25	; 0x01
    1582:	e1 14       	cp	r14, r1
    1584:	f1 04       	cpc	r15, r1
    1586:	19 f0       	breq	.+6      	; 0x158e <xTaskCreate+0x102>
    1588:	f7 01       	movw	r30, r14
    158a:	c0 83       	st	Z, r28
    158c:	d1 83       	std	Z+1, r29	; 0x01
    158e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1592:	ff 93       	push	r31
    1594:	f8 7f       	andi	r31, 0xF8	; 248
    1596:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    159a:	80 91 91 2e 	lds	r24, 0x2E91	; 0x802e91 <uxCurrentNumberOfTasks>
    159e:	8f 5f       	subi	r24, 0xFF	; 255
    15a0:	80 93 91 2e 	sts	0x2E91, r24	; 0x802e91 <uxCurrentNumberOfTasks>
    15a4:	80 91 ee 2e 	lds	r24, 0x2EEE	; 0x802eee <pxCurrentTCB>
    15a8:	90 91 ef 2e 	lds	r25, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    15ac:	89 2b       	or	r24, r25
    15ae:	a9 f5       	brne	.+106    	; 0x161a <xTaskCreate+0x18e>
    15b0:	c0 93 ee 2e 	sts	0x2EEE, r28	; 0x802eee <pxCurrentTCB>
    15b4:	d0 93 ef 2e 	sts	0x2EEF, r29	; 0x802eef <pxCurrentTCB+0x1>
    15b8:	80 91 91 2e 	lds	r24, 0x2E91	; 0x802e91 <uxCurrentNumberOfTasks>
    15bc:	81 30       	cpi	r24, 0x01	; 1
    15be:	e9 f5       	brne	.+122    	; 0x163a <xTaskCreate+0x1ae>
    15c0:	82 ec       	ldi	r24, 0xC2	; 194
    15c2:	9e e2       	ldi	r25, 0x2E	; 46
    15c4:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
    15c8:	8d ec       	ldi	r24, 0xCD	; 205
    15ca:	9e e2       	ldi	r25, 0x2E	; 46
    15cc:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
    15d0:	88 ed       	ldi	r24, 0xD8	; 216
    15d2:	9e e2       	ldi	r25, 0x2E	; 46
    15d4:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
    15d8:	83 ee       	ldi	r24, 0xE3	; 227
    15da:	9e e2       	ldi	r25, 0x2E	; 46
    15dc:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
    15e0:	87 eb       	ldi	r24, 0xB7	; 183
    15e2:	9e e2       	ldi	r25, 0x2E	; 46
    15e4:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
    15e8:	8c ea       	ldi	r24, 0xAC	; 172
    15ea:	9e e2       	ldi	r25, 0x2E	; 46
    15ec:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
    15f0:	8d e9       	ldi	r24, 0x9D	; 157
    15f2:	9e e2       	ldi	r25, 0x2E	; 46
    15f4:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
    15f8:	82 e9       	ldi	r24, 0x92	; 146
    15fa:	9e e2       	ldi	r25, 0x2E	; 46
    15fc:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
    1600:	87 eb       	ldi	r24, 0xB7	; 183
    1602:	9e e2       	ldi	r25, 0x2E	; 46
    1604:	80 93 aa 2e 	sts	0x2EAA, r24	; 0x802eaa <pxDelayedTaskList>
    1608:	90 93 ab 2e 	sts	0x2EAB, r25	; 0x802eab <pxDelayedTaskList+0x1>
    160c:	8c ea       	ldi	r24, 0xAC	; 172
    160e:	9e e2       	ldi	r25, 0x2E	; 46
    1610:	80 93 a8 2e 	sts	0x2EA8, r24	; 0x802ea8 <pxOverflowDelayedTaskList>
    1614:	90 93 a9 2e 	sts	0x2EA9, r25	; 0x802ea9 <pxOverflowDelayedTaskList+0x1>
    1618:	10 c0       	rjmp	.+32     	; 0x163a <xTaskCreate+0x1ae>
    161a:	80 91 8b 2e 	lds	r24, 0x2E8B	; 0x802e8b <xSchedulerRunning>
    161e:	81 11       	cpse	r24, r1
    1620:	0c c0       	rjmp	.+24     	; 0x163a <xTaskCreate+0x1ae>
    1622:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1626:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    162a:	92 8d       	ldd	r25, Z+26	; 0x1a
    162c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    162e:	89 17       	cp	r24, r25
    1630:	20 f0       	brcs	.+8      	; 0x163a <xTaskCreate+0x1ae>
    1632:	c0 93 ee 2e 	sts	0x2EEE, r28	; 0x802eee <pxCurrentTCB>
    1636:	d0 93 ef 2e 	sts	0x2EEF, r29	; 0x802eef <pxCurrentTCB+0x1>
    163a:	80 91 87 2e 	lds	r24, 0x2E87	; 0x802e87 <uxTaskNumber>
    163e:	8f 5f       	subi	r24, 0xFF	; 255
    1640:	80 93 87 2e 	sts	0x2E87, r24	; 0x802e87 <uxTaskNumber>
    1644:	8d a3       	std	Y+37, r24	; 0x25
    1646:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1648:	90 91 8c 2e 	lds	r25, 0x2E8C	; 0x802e8c <uxTopReadyPriority>
    164c:	98 17       	cp	r25, r24
    164e:	10 f4       	brcc	.+4      	; 0x1654 <xTaskCreate+0x1c8>
    1650:	80 93 8c 2e 	sts	0x2E8C, r24	; 0x802e8c <uxTopReadyPriority>
    1654:	fb e0       	ldi	r31, 0x0B	; 11
    1656:	8f 9f       	mul	r24, r31
    1658:	c0 01       	movw	r24, r0
    165a:	11 24       	eor	r1, r1
    165c:	b6 01       	movw	r22, r12
    165e:	8e 53       	subi	r24, 0x3E	; 62
    1660:	91 4d       	sbci	r25, 0xD1	; 209
    1662:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    1666:	ff 91       	pop	r31
    1668:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    166c:	80 91 8b 2e 	lds	r24, 0x2E8B	; 0x802e8b <xSchedulerRunning>
    1670:	88 23       	and	r24, r24
    1672:	61 f0       	breq	.+24     	; 0x168c <xTaskCreate+0x200>
    1674:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1678:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    167c:	92 8d       	ldd	r25, Z+26	; 0x1a
    167e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1680:	98 17       	cp	r25, r24
    1682:	30 f4       	brcc	.+12     	; 0x1690 <xTaskCreate+0x204>
    1684:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
    1688:	81 e0       	ldi	r24, 0x01	; 1
    168a:	05 c0       	rjmp	.+10     	; 0x1696 <xTaskCreate+0x20a>
    168c:	81 e0       	ldi	r24, 0x01	; 1
    168e:	03 c0       	rjmp	.+6      	; 0x1696 <xTaskCreate+0x20a>
    1690:	81 e0       	ldi	r24, 0x01	; 1
    1692:	01 c0       	rjmp	.+2      	; 0x1696 <xTaskCreate+0x20a>
    1694:	8f ef       	ldi	r24, 0xFF	; 255
    1696:	df 91       	pop	r29
    1698:	cf 91       	pop	r28
    169a:	0f 91       	pop	r16
    169c:	ff 90       	pop	r15
    169e:	ef 90       	pop	r14
    16a0:	df 90       	pop	r13
    16a2:	cf 90       	pop	r12
    16a4:	bf 90       	pop	r11
    16a6:	af 90       	pop	r10
    16a8:	9f 90       	pop	r9
    16aa:	8f 90       	pop	r8
    16ac:	7f 90       	pop	r7
    16ae:	6f 90       	pop	r6
    16b0:	5f 90       	pop	r5
    16b2:	4f 90       	pop	r4
    16b4:	08 95       	ret

000016b6 <vTaskStartScheduler>:
    16b6:	ef 92       	push	r14
    16b8:	ff 92       	push	r15
    16ba:	0f 93       	push	r16
    16bc:	0f 2e       	mov	r0, r31
    16be:	f1 e8       	ldi	r31, 0x81	; 129
    16c0:	ef 2e       	mov	r14, r31
    16c2:	fe e2       	ldi	r31, 0x2E	; 46
    16c4:	ff 2e       	mov	r15, r31
    16c6:	f0 2d       	mov	r31, r0
    16c8:	00 e0       	ldi	r16, 0x00	; 0
    16ca:	20 e0       	ldi	r18, 0x00	; 0
    16cc:	30 e0       	ldi	r19, 0x00	; 0
    16ce:	48 ec       	ldi	r20, 0xC8	; 200
    16d0:	50 e0       	ldi	r21, 0x00	; 0
    16d2:	61 e0       	ldi	r22, 0x01	; 1
    16d4:	70 e2       	ldi	r23, 0x20	; 32
    16d6:	8c e3       	ldi	r24, 0x3C	; 60
    16d8:	9a e0       	ldi	r25, 0x0A	; 10
    16da:	0e 94 46 0a 	call	0x148c	; 0x148c <xTaskCreate>
    16de:	81 30       	cpi	r24, 0x01	; 1
    16e0:	09 f5       	brne	.+66     	; 0x1724 <vTaskStartScheduler+0x6e>
    16e2:	0e 94 c9 10 	call	0x2192	; 0x2192 <xTimerCreateTimerTask>
    16e6:	81 30       	cpi	r24, 0x01	; 1
    16e8:	e9 f4       	brne	.+58     	; 0x1724 <vTaskStartScheduler+0x6e>
    16ea:	e0 ea       	ldi	r30, 0xA0	; 160
    16ec:	f0 e0       	ldi	r31, 0x00	; 0
    16ee:	82 81       	ldd	r24, Z+2	; 0x02
    16f0:	88 7f       	andi	r24, 0xF8	; 248
    16f2:	82 83       	std	Z+2, r24	; 0x02
    16f4:	8f ef       	ldi	r24, 0xFF	; 255
    16f6:	9f ef       	ldi	r25, 0xFF	; 255
    16f8:	dc 01       	movw	r26, r24
    16fa:	80 93 83 2e 	sts	0x2E83, r24	; 0x802e83 <xNextTaskUnblockTime>
    16fe:	90 93 84 2e 	sts	0x2E84, r25	; 0x802e84 <xNextTaskUnblockTime+0x1>
    1702:	a0 93 85 2e 	sts	0x2E85, r26	; 0x802e85 <xNextTaskUnblockTime+0x2>
    1706:	b0 93 86 2e 	sts	0x2E86, r27	; 0x802e86 <xNextTaskUnblockTime+0x3>
    170a:	81 e0       	ldi	r24, 0x01	; 1
    170c:	80 93 8b 2e 	sts	0x2E8B, r24	; 0x802e8b <xSchedulerRunning>
    1710:	10 92 8d 2e 	sts	0x2E8D, r1	; 0x802e8d <xTickCount>
    1714:	10 92 8e 2e 	sts	0x2E8E, r1	; 0x802e8e <xTickCount+0x1>
    1718:	10 92 8f 2e 	sts	0x2E8F, r1	; 0x802e8f <xTickCount+0x2>
    171c:	10 92 90 2e 	sts	0x2E90, r1	; 0x802e90 <xTickCount+0x3>
    1720:	0e 94 67 05 	call	0xace	; 0xace <xPortStartScheduler>
    1724:	0f 91       	pop	r16
    1726:	ff 90       	pop	r15
    1728:	ef 90       	pop	r14
    172a:	08 95       	ret

0000172c <vTaskSuspendAll>:
    172c:	80 91 80 2e 	lds	r24, 0x2E80	; 0x802e80 <uxSchedulerSuspended>
    1730:	8f 5f       	subi	r24, 0xFF	; 255
    1732:	80 93 80 2e 	sts	0x2E80, r24	; 0x802e80 <uxSchedulerSuspended>
    1736:	08 95       	ret

00001738 <xTaskGetTickCount>:
    1738:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    173c:	ff 93       	push	r31
    173e:	f8 7f       	andi	r31, 0xF8	; 248
    1740:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1744:	60 91 8d 2e 	lds	r22, 0x2E8D	; 0x802e8d <xTickCount>
    1748:	70 91 8e 2e 	lds	r23, 0x2E8E	; 0x802e8e <xTickCount+0x1>
    174c:	80 91 8f 2e 	lds	r24, 0x2E8F	; 0x802e8f <xTickCount+0x2>
    1750:	90 91 90 2e 	lds	r25, 0x2E90	; 0x802e90 <xTickCount+0x3>
    1754:	ff 91       	pop	r31
    1756:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    175a:	08 95       	ret

0000175c <xTaskIncrementTick>:
    175c:	af 92       	push	r10
    175e:	bf 92       	push	r11
    1760:	cf 92       	push	r12
    1762:	df 92       	push	r13
    1764:	ef 92       	push	r14
    1766:	ff 92       	push	r15
    1768:	0f 93       	push	r16
    176a:	1f 93       	push	r17
    176c:	cf 93       	push	r28
    176e:	df 93       	push	r29
    1770:	80 91 80 2e 	lds	r24, 0x2E80	; 0x802e80 <uxSchedulerSuspended>
    1774:	81 11       	cpse	r24, r1
    1776:	ad c0       	rjmp	.+346    	; 0x18d2 <xTaskIncrementTick+0x176>
    1778:	c0 90 8d 2e 	lds	r12, 0x2E8D	; 0x802e8d <xTickCount>
    177c:	d0 90 8e 2e 	lds	r13, 0x2E8E	; 0x802e8e <xTickCount+0x1>
    1780:	e0 90 8f 2e 	lds	r14, 0x2E8F	; 0x802e8f <xTickCount+0x2>
    1784:	f0 90 90 2e 	lds	r15, 0x2E90	; 0x802e90 <xTickCount+0x3>
    1788:	8f ef       	ldi	r24, 0xFF	; 255
    178a:	c8 1a       	sub	r12, r24
    178c:	d8 0a       	sbc	r13, r24
    178e:	e8 0a       	sbc	r14, r24
    1790:	f8 0a       	sbc	r15, r24
    1792:	c0 92 8d 2e 	sts	0x2E8D, r12	; 0x802e8d <xTickCount>
    1796:	d0 92 8e 2e 	sts	0x2E8E, r13	; 0x802e8e <xTickCount+0x1>
    179a:	e0 92 8f 2e 	sts	0x2E8F, r14	; 0x802e8f <xTickCount+0x2>
    179e:	f0 92 90 2e 	sts	0x2E90, r15	; 0x802e90 <xTickCount+0x3>
    17a2:	c1 14       	cp	r12, r1
    17a4:	d1 04       	cpc	r13, r1
    17a6:	e1 04       	cpc	r14, r1
    17a8:	f1 04       	cpc	r15, r1
    17aa:	b9 f4       	brne	.+46     	; 0x17da <xTaskIncrementTick+0x7e>
    17ac:	80 91 aa 2e 	lds	r24, 0x2EAA	; 0x802eaa <pxDelayedTaskList>
    17b0:	90 91 ab 2e 	lds	r25, 0x2EAB	; 0x802eab <pxDelayedTaskList+0x1>
    17b4:	20 91 a8 2e 	lds	r18, 0x2EA8	; 0x802ea8 <pxOverflowDelayedTaskList>
    17b8:	30 91 a9 2e 	lds	r19, 0x2EA9	; 0x802ea9 <pxOverflowDelayedTaskList+0x1>
    17bc:	20 93 aa 2e 	sts	0x2EAA, r18	; 0x802eaa <pxDelayedTaskList>
    17c0:	30 93 ab 2e 	sts	0x2EAB, r19	; 0x802eab <pxDelayedTaskList+0x1>
    17c4:	80 93 a8 2e 	sts	0x2EA8, r24	; 0x802ea8 <pxOverflowDelayedTaskList>
    17c8:	90 93 a9 2e 	sts	0x2EA9, r25	; 0x802ea9 <pxOverflowDelayedTaskList+0x1>
    17cc:	80 91 88 2e 	lds	r24, 0x2E88	; 0x802e88 <xNumOfOverflows>
    17d0:	8f 5f       	subi	r24, 0xFF	; 255
    17d2:	80 93 88 2e 	sts	0x2E88, r24	; 0x802e88 <xNumOfOverflows>
    17d6:	0e 94 9b 09 	call	0x1336	; 0x1336 <prvResetNextTaskUnblockTime>
    17da:	80 91 83 2e 	lds	r24, 0x2E83	; 0x802e83 <xNextTaskUnblockTime>
    17de:	90 91 84 2e 	lds	r25, 0x2E84	; 0x802e84 <xNextTaskUnblockTime+0x1>
    17e2:	a0 91 85 2e 	lds	r26, 0x2E85	; 0x802e85 <xNextTaskUnblockTime+0x2>
    17e6:	b0 91 86 2e 	lds	r27, 0x2E86	; 0x802e86 <xNextTaskUnblockTime+0x3>
    17ea:	c8 16       	cp	r12, r24
    17ec:	d9 06       	cpc	r13, r25
    17ee:	ea 06       	cpc	r14, r26
    17f0:	fb 06       	cpc	r15, r27
    17f2:	10 f4       	brcc	.+4      	; 0x17f8 <xTaskIncrementTick+0x9c>
    17f4:	b1 2c       	mov	r11, r1
    17f6:	5c c0       	rjmp	.+184    	; 0x18b0 <xTaskIncrementTick+0x154>
    17f8:	b1 2c       	mov	r11, r1
    17fa:	0f 2e       	mov	r0, r31
    17fc:	fb e0       	ldi	r31, 0x0B	; 11
    17fe:	af 2e       	mov	r10, r31
    1800:	f0 2d       	mov	r31, r0
    1802:	e0 91 aa 2e 	lds	r30, 0x2EAA	; 0x802eaa <pxDelayedTaskList>
    1806:	f0 91 ab 2e 	lds	r31, 0x2EAB	; 0x802eab <pxDelayedTaskList+0x1>
    180a:	80 81       	ld	r24, Z
    180c:	81 11       	cpse	r24, r1
    180e:	0c c0       	rjmp	.+24     	; 0x1828 <xTaskIncrementTick+0xcc>
    1810:	8f ef       	ldi	r24, 0xFF	; 255
    1812:	9f ef       	ldi	r25, 0xFF	; 255
    1814:	dc 01       	movw	r26, r24
    1816:	80 93 83 2e 	sts	0x2E83, r24	; 0x802e83 <xNextTaskUnblockTime>
    181a:	90 93 84 2e 	sts	0x2E84, r25	; 0x802e84 <xNextTaskUnblockTime+0x1>
    181e:	a0 93 85 2e 	sts	0x2E85, r26	; 0x802e85 <xNextTaskUnblockTime+0x2>
    1822:	b0 93 86 2e 	sts	0x2E86, r27	; 0x802e86 <xNextTaskUnblockTime+0x3>
    1826:	44 c0       	rjmp	.+136    	; 0x18b0 <xTaskIncrementTick+0x154>
    1828:	e0 91 aa 2e 	lds	r30, 0x2EAA	; 0x802eaa <pxDelayedTaskList>
    182c:	f0 91 ab 2e 	lds	r31, 0x2EAB	; 0x802eab <pxDelayedTaskList+0x1>
    1830:	07 80       	ldd	r0, Z+7	; 0x07
    1832:	f0 85       	ldd	r31, Z+8	; 0x08
    1834:	e0 2d       	mov	r30, r0
    1836:	c0 85       	ldd	r28, Z+8	; 0x08
    1838:	d1 85       	ldd	r29, Z+9	; 0x09
    183a:	8a 81       	ldd	r24, Y+2	; 0x02
    183c:	9b 81       	ldd	r25, Y+3	; 0x03
    183e:	ac 81       	ldd	r26, Y+4	; 0x04
    1840:	bd 81       	ldd	r27, Y+5	; 0x05
    1842:	c8 16       	cp	r12, r24
    1844:	d9 06       	cpc	r13, r25
    1846:	ea 06       	cpc	r14, r26
    1848:	fb 06       	cpc	r15, r27
    184a:	48 f4       	brcc	.+18     	; 0x185e <xTaskIncrementTick+0x102>
    184c:	80 93 83 2e 	sts	0x2E83, r24	; 0x802e83 <xNextTaskUnblockTime>
    1850:	90 93 84 2e 	sts	0x2E84, r25	; 0x802e84 <xNextTaskUnblockTime+0x1>
    1854:	a0 93 85 2e 	sts	0x2E85, r26	; 0x802e85 <xNextTaskUnblockTime+0x2>
    1858:	b0 93 86 2e 	sts	0x2E86, r27	; 0x802e86 <xNextTaskUnblockTime+0x3>
    185c:	29 c0       	rjmp	.+82     	; 0x18b0 <xTaskIncrementTick+0x154>
    185e:	8e 01       	movw	r16, r28
    1860:	0e 5f       	subi	r16, 0xFE	; 254
    1862:	1f 4f       	sbci	r17, 0xFF	; 255
    1864:	c8 01       	movw	r24, r16
    1866:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
    186a:	88 8d       	ldd	r24, Y+24	; 0x18
    186c:	99 8d       	ldd	r25, Y+25	; 0x19
    186e:	89 2b       	or	r24, r25
    1870:	21 f0       	breq	.+8      	; 0x187a <xTaskIncrementTick+0x11e>
    1872:	ce 01       	movw	r24, r28
    1874:	0e 96       	adiw	r24, 0x0e	; 14
    1876:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
    187a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    187c:	90 91 8c 2e 	lds	r25, 0x2E8C	; 0x802e8c <uxTopReadyPriority>
    1880:	98 17       	cp	r25, r24
    1882:	10 f4       	brcc	.+4      	; 0x1888 <xTaskIncrementTick+0x12c>
    1884:	80 93 8c 2e 	sts	0x2E8C, r24	; 0x802e8c <uxTopReadyPriority>
    1888:	a8 9e       	mul	r10, r24
    188a:	c0 01       	movw	r24, r0
    188c:	11 24       	eor	r1, r1
    188e:	b8 01       	movw	r22, r16
    1890:	8e 53       	subi	r24, 0x3E	; 62
    1892:	91 4d       	sbci	r25, 0xD1	; 209
    1894:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    1898:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    189c:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    18a0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    18a4:	98 17       	cp	r25, r24
    18a6:	08 f4       	brcc	.+2      	; 0x18aa <xTaskIncrementTick+0x14e>
    18a8:	ac cf       	rjmp	.-168    	; 0x1802 <xTaskIncrementTick+0xa6>
    18aa:	bb 24       	eor	r11, r11
    18ac:	b3 94       	inc	r11
    18ae:	a9 cf       	rjmp	.-174    	; 0x1802 <xTaskIncrementTick+0xa6>
    18b0:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    18b4:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    18b8:	e2 8d       	ldd	r30, Z+26	; 0x1a
    18ba:	8b e0       	ldi	r24, 0x0B	; 11
    18bc:	e8 9f       	mul	r30, r24
    18be:	f0 01       	movw	r30, r0
    18c0:	11 24       	eor	r1, r1
    18c2:	ee 53       	subi	r30, 0x3E	; 62
    18c4:	f1 4d       	sbci	r31, 0xD1	; 209
    18c6:	80 81       	ld	r24, Z
    18c8:	82 30       	cpi	r24, 0x02	; 2
    18ca:	48 f0       	brcs	.+18     	; 0x18de <xTaskIncrementTick+0x182>
    18cc:	bb 24       	eor	r11, r11
    18ce:	b3 94       	inc	r11
    18d0:	06 c0       	rjmp	.+12     	; 0x18de <xTaskIncrementTick+0x182>
    18d2:	80 91 8a 2e 	lds	r24, 0x2E8A	; 0x802e8a <uxPendedTicks>
    18d6:	8f 5f       	subi	r24, 0xFF	; 255
    18d8:	80 93 8a 2e 	sts	0x2E8A, r24	; 0x802e8a <uxPendedTicks>
    18dc:	b1 2c       	mov	r11, r1
    18de:	80 91 89 2e 	lds	r24, 0x2E89	; 0x802e89 <xYieldPending>
    18e2:	88 23       	and	r24, r24
    18e4:	11 f0       	breq	.+4      	; 0x18ea <xTaskIncrementTick+0x18e>
    18e6:	bb 24       	eor	r11, r11
    18e8:	b3 94       	inc	r11
    18ea:	8b 2d       	mov	r24, r11
    18ec:	df 91       	pop	r29
    18ee:	cf 91       	pop	r28
    18f0:	1f 91       	pop	r17
    18f2:	0f 91       	pop	r16
    18f4:	ff 90       	pop	r15
    18f6:	ef 90       	pop	r14
    18f8:	df 90       	pop	r13
    18fa:	cf 90       	pop	r12
    18fc:	bf 90       	pop	r11
    18fe:	af 90       	pop	r10
    1900:	08 95       	ret

00001902 <xTaskResumeAll>:
    1902:	cf 92       	push	r12
    1904:	df 92       	push	r13
    1906:	ef 92       	push	r14
    1908:	ff 92       	push	r15
    190a:	0f 93       	push	r16
    190c:	1f 93       	push	r17
    190e:	cf 93       	push	r28
    1910:	df 93       	push	r29
    1912:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1916:	ff 93       	push	r31
    1918:	f8 7f       	andi	r31, 0xF8	; 248
    191a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    191e:	80 91 80 2e 	lds	r24, 0x2E80	; 0x802e80 <uxSchedulerSuspended>
    1922:	81 50       	subi	r24, 0x01	; 1
    1924:	80 93 80 2e 	sts	0x2E80, r24	; 0x802e80 <uxSchedulerSuspended>
    1928:	80 91 80 2e 	lds	r24, 0x2E80	; 0x802e80 <uxSchedulerSuspended>
    192c:	81 11       	cpse	r24, r1
    192e:	5c c0       	rjmp	.+184    	; 0x19e8 <xTaskResumeAll+0xe6>
    1930:	80 91 91 2e 	lds	r24, 0x2E91	; 0x802e91 <uxCurrentNumberOfTasks>
    1934:	81 11       	cpse	r24, r1
    1936:	2c c0       	rjmp	.+88     	; 0x1990 <xTaskResumeAll+0x8e>
    1938:	5a c0       	rjmp	.+180    	; 0x19ee <xTaskResumeAll+0xec>
    193a:	d7 01       	movw	r26, r14
    193c:	17 96       	adiw	r26, 0x07	; 7
    193e:	ed 91       	ld	r30, X+
    1940:	fc 91       	ld	r31, X
    1942:	18 97       	sbiw	r26, 0x08	; 8
    1944:	c0 85       	ldd	r28, Z+8	; 0x08
    1946:	d1 85       	ldd	r29, Z+9	; 0x09
    1948:	ce 01       	movw	r24, r28
    194a:	0e 96       	adiw	r24, 0x0e	; 14
    194c:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
    1950:	8e 01       	movw	r16, r28
    1952:	0e 5f       	subi	r16, 0xFE	; 254
    1954:	1f 4f       	sbci	r17, 0xFF	; 255
    1956:	c8 01       	movw	r24, r16
    1958:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
    195c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    195e:	90 91 8c 2e 	lds	r25, 0x2E8C	; 0x802e8c <uxTopReadyPriority>
    1962:	98 17       	cp	r25, r24
    1964:	10 f4       	brcc	.+4      	; 0x196a <xTaskResumeAll+0x68>
    1966:	80 93 8c 2e 	sts	0x2E8C, r24	; 0x802e8c <uxTopReadyPriority>
    196a:	d8 9e       	mul	r13, r24
    196c:	c0 01       	movw	r24, r0
    196e:	11 24       	eor	r1, r1
    1970:	b8 01       	movw	r22, r16
    1972:	8e 53       	subi	r24, 0x3E	; 62
    1974:	91 4d       	sbci	r25, 0xD1	; 209
    1976:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    197a:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    197e:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1982:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1984:	82 8d       	ldd	r24, Z+26	; 0x1a
    1986:	98 17       	cp	r25, r24
    1988:	88 f0       	brcs	.+34     	; 0x19ac <xTaskResumeAll+0xaa>
    198a:	c0 92 89 2e 	sts	0x2E89, r12	; 0x802e89 <xYieldPending>
    198e:	0e c0       	rjmp	.+28     	; 0x19ac <xTaskResumeAll+0xaa>
    1990:	c0 e0       	ldi	r28, 0x00	; 0
    1992:	d0 e0       	ldi	r29, 0x00	; 0
    1994:	0f 2e       	mov	r0, r31
    1996:	fd e9       	ldi	r31, 0x9D	; 157
    1998:	ef 2e       	mov	r14, r31
    199a:	fe e2       	ldi	r31, 0x2E	; 46
    199c:	ff 2e       	mov	r15, r31
    199e:	f0 2d       	mov	r31, r0
    19a0:	0f 2e       	mov	r0, r31
    19a2:	fb e0       	ldi	r31, 0x0B	; 11
    19a4:	df 2e       	mov	r13, r31
    19a6:	f0 2d       	mov	r31, r0
    19a8:	cc 24       	eor	r12, r12
    19aa:	c3 94       	inc	r12
    19ac:	f7 01       	movw	r30, r14
    19ae:	80 81       	ld	r24, Z
    19b0:	81 11       	cpse	r24, r1
    19b2:	c3 cf       	rjmp	.-122    	; 0x193a <xTaskResumeAll+0x38>
    19b4:	cd 2b       	or	r28, r29
    19b6:	11 f0       	breq	.+4      	; 0x19bc <xTaskResumeAll+0xba>
    19b8:	0e 94 9b 09 	call	0x1336	; 0x1336 <prvResetNextTaskUnblockTime>
    19bc:	c0 91 8a 2e 	lds	r28, 0x2E8A	; 0x802e8a <uxPendedTicks>
    19c0:	cc 23       	and	r28, r28
    19c2:	51 f0       	breq	.+20     	; 0x19d8 <xTaskResumeAll+0xd6>
    19c4:	d1 e0       	ldi	r29, 0x01	; 1
    19c6:	0e 94 ae 0b 	call	0x175c	; 0x175c <xTaskIncrementTick>
    19ca:	81 11       	cpse	r24, r1
    19cc:	d0 93 89 2e 	sts	0x2E89, r29	; 0x802e89 <xYieldPending>
    19d0:	c1 50       	subi	r28, 0x01	; 1
    19d2:	c9 f7       	brne	.-14     	; 0x19c6 <xTaskResumeAll+0xc4>
    19d4:	10 92 8a 2e 	sts	0x2E8A, r1	; 0x802e8a <uxPendedTicks>
    19d8:	80 91 89 2e 	lds	r24, 0x2E89	; 0x802e89 <xYieldPending>
    19dc:	88 23       	and	r24, r24
    19de:	31 f0       	breq	.+12     	; 0x19ec <xTaskResumeAll+0xea>
    19e0:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
    19e4:	81 e0       	ldi	r24, 0x01	; 1
    19e6:	03 c0       	rjmp	.+6      	; 0x19ee <xTaskResumeAll+0xec>
    19e8:	80 e0       	ldi	r24, 0x00	; 0
    19ea:	01 c0       	rjmp	.+2      	; 0x19ee <xTaskResumeAll+0xec>
    19ec:	80 e0       	ldi	r24, 0x00	; 0
    19ee:	ff 91       	pop	r31
    19f0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    19f4:	df 91       	pop	r29
    19f6:	cf 91       	pop	r28
    19f8:	1f 91       	pop	r17
    19fa:	0f 91       	pop	r16
    19fc:	ff 90       	pop	r15
    19fe:	ef 90       	pop	r14
    1a00:	df 90       	pop	r13
    1a02:	cf 90       	pop	r12
    1a04:	08 95       	ret

00001a06 <vTaskDelay>:
    1a06:	cf 92       	push	r12
    1a08:	df 92       	push	r13
    1a0a:	ef 92       	push	r14
    1a0c:	ff 92       	push	r15
    1a0e:	6b 01       	movw	r12, r22
    1a10:	7c 01       	movw	r14, r24
    1a12:	67 2b       	or	r22, r23
    1a14:	68 2b       	or	r22, r24
    1a16:	69 2b       	or	r22, r25
    1a18:	59 f0       	breq	.+22     	; 0x1a30 <vTaskDelay+0x2a>
    1a1a:	0e 94 96 0b 	call	0x172c	; 0x172c <vTaskSuspendAll>
    1a1e:	40 e0       	ldi	r20, 0x00	; 0
    1a20:	c7 01       	movw	r24, r14
    1a22:	b6 01       	movw	r22, r12
    1a24:	0e 94 c5 09 	call	0x138a	; 0x138a <prvAddCurrentTaskToDelayedList>
    1a28:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
    1a2c:	81 11       	cpse	r24, r1
    1a2e:	02 c0       	rjmp	.+4      	; 0x1a34 <vTaskDelay+0x2e>
    1a30:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
    1a34:	ff 90       	pop	r15
    1a36:	ef 90       	pop	r14
    1a38:	df 90       	pop	r13
    1a3a:	cf 90       	pop	r12
    1a3c:	08 95       	ret

00001a3e <vTaskSwitchContext>:
    1a3e:	80 91 80 2e 	lds	r24, 0x2E80	; 0x802e80 <uxSchedulerSuspended>
    1a42:	88 23       	and	r24, r24
    1a44:	21 f0       	breq	.+8      	; 0x1a4e <vTaskSwitchContext+0x10>
    1a46:	81 e0       	ldi	r24, 0x01	; 1
    1a48:	80 93 89 2e 	sts	0x2E89, r24	; 0x802e89 <xYieldPending>
    1a4c:	08 95       	ret
    1a4e:	10 92 89 2e 	sts	0x2E89, r1	; 0x802e89 <xYieldPending>
    1a52:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1a56:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1a5a:	03 8c       	ldd	r0, Z+27	; 0x1b
    1a5c:	f4 8d       	ldd	r31, Z+28	; 0x1c
    1a5e:	e0 2d       	mov	r30, r0
    1a60:	80 81       	ld	r24, Z
    1a62:	91 81       	ldd	r25, Z+1	; 0x01
    1a64:	a2 81       	ldd	r26, Z+2	; 0x02
    1a66:	b3 81       	ldd	r27, Z+3	; 0x03
    1a68:	85 3a       	cpi	r24, 0xA5	; 165
    1a6a:	95 4a       	sbci	r25, 0xA5	; 165
    1a6c:	a5 4a       	sbci	r26, 0xA5	; 165
    1a6e:	b5 4a       	sbci	r27, 0xA5	; 165
    1a70:	d9 f4       	brne	.+54     	; 0x1aa8 <vTaskSwitchContext+0x6a>
    1a72:	84 81       	ldd	r24, Z+4	; 0x04
    1a74:	95 81       	ldd	r25, Z+5	; 0x05
    1a76:	a6 81       	ldd	r26, Z+6	; 0x06
    1a78:	b7 81       	ldd	r27, Z+7	; 0x07
    1a7a:	85 3a       	cpi	r24, 0xA5	; 165
    1a7c:	95 4a       	sbci	r25, 0xA5	; 165
    1a7e:	a5 4a       	sbci	r26, 0xA5	; 165
    1a80:	b5 4a       	sbci	r27, 0xA5	; 165
    1a82:	91 f4       	brne	.+36     	; 0x1aa8 <vTaskSwitchContext+0x6a>
    1a84:	80 85       	ldd	r24, Z+8	; 0x08
    1a86:	91 85       	ldd	r25, Z+9	; 0x09
    1a88:	a2 85       	ldd	r26, Z+10	; 0x0a
    1a8a:	b3 85       	ldd	r27, Z+11	; 0x0b
    1a8c:	85 3a       	cpi	r24, 0xA5	; 165
    1a8e:	95 4a       	sbci	r25, 0xA5	; 165
    1a90:	a5 4a       	sbci	r26, 0xA5	; 165
    1a92:	b5 4a       	sbci	r27, 0xA5	; 165
    1a94:	49 f4       	brne	.+18     	; 0x1aa8 <vTaskSwitchContext+0x6a>
    1a96:	84 85       	ldd	r24, Z+12	; 0x0c
    1a98:	95 85       	ldd	r25, Z+13	; 0x0d
    1a9a:	a6 85       	ldd	r26, Z+14	; 0x0e
    1a9c:	b7 85       	ldd	r27, Z+15	; 0x0f
    1a9e:	85 3a       	cpi	r24, 0xA5	; 165
    1aa0:	95 4a       	sbci	r25, 0xA5	; 165
    1aa2:	a5 4a       	sbci	r26, 0xA5	; 165
    1aa4:	b5 4a       	sbci	r27, 0xA5	; 165
    1aa6:	61 f0       	breq	.+24     	; 0x1ac0 <vTaskSwitchContext+0x82>
    1aa8:	60 91 ee 2e 	lds	r22, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1aac:	70 91 ef 2e 	lds	r23, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1ab0:	80 91 ee 2e 	lds	r24, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1ab4:	90 91 ef 2e 	lds	r25, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1ab8:	63 5e       	subi	r22, 0xE3	; 227
    1aba:	7f 4f       	sbci	r23, 0xFF	; 255
    1abc:	0e 94 73 02 	call	0x4e6	; 0x4e6 <vApplicationStackOverflowHook>
    1ac0:	80 91 8c 2e 	lds	r24, 0x2E8C	; 0x802e8c <uxTopReadyPriority>
    1ac4:	28 2f       	mov	r18, r24
    1ac6:	30 e0       	ldi	r19, 0x00	; 0
    1ac8:	9b e0       	ldi	r25, 0x0B	; 11
    1aca:	89 9f       	mul	r24, r25
    1acc:	f0 01       	movw	r30, r0
    1ace:	11 24       	eor	r1, r1
    1ad0:	ee 53       	subi	r30, 0x3E	; 62
    1ad2:	f1 4d       	sbci	r31, 0xD1	; 209
    1ad4:	90 81       	ld	r25, Z
    1ad6:	91 11       	cpse	r25, r1
    1ad8:	0e c0       	rjmp	.+28     	; 0x1af6 <vTaskSwitchContext+0xb8>
    1ada:	4b e0       	ldi	r20, 0x0B	; 11
    1adc:	81 50       	subi	r24, 0x01	; 1
    1ade:	28 2f       	mov	r18, r24
    1ae0:	30 e0       	ldi	r19, 0x00	; 0
    1ae2:	42 9f       	mul	r20, r18
    1ae4:	f0 01       	movw	r30, r0
    1ae6:	43 9f       	mul	r20, r19
    1ae8:	f0 0d       	add	r31, r0
    1aea:	11 24       	eor	r1, r1
    1aec:	ee 53       	subi	r30, 0x3E	; 62
    1aee:	f1 4d       	sbci	r31, 0xD1	; 209
    1af0:	90 81       	ld	r25, Z
    1af2:	99 23       	and	r25, r25
    1af4:	99 f3       	breq	.-26     	; 0x1adc <vTaskSwitchContext+0x9e>
    1af6:	9b e0       	ldi	r25, 0x0B	; 11
    1af8:	92 9f       	mul	r25, r18
    1afa:	a0 01       	movw	r20, r0
    1afc:	93 9f       	mul	r25, r19
    1afe:	50 0d       	add	r21, r0
    1b00:	11 24       	eor	r1, r1
    1b02:	da 01       	movw	r26, r20
    1b04:	ae 53       	subi	r26, 0x3E	; 62
    1b06:	b1 4d       	sbci	r27, 0xD1	; 209
    1b08:	11 96       	adiw	r26, 0x01	; 1
    1b0a:	ed 91       	ld	r30, X+
    1b0c:	fc 91       	ld	r31, X
    1b0e:	12 97       	sbiw	r26, 0x02	; 2
    1b10:	04 80       	ldd	r0, Z+4	; 0x04
    1b12:	f5 81       	ldd	r31, Z+5	; 0x05
    1b14:	e0 2d       	mov	r30, r0
    1b16:	11 96       	adiw	r26, 0x01	; 1
    1b18:	ed 93       	st	X+, r30
    1b1a:	fc 93       	st	X, r31
    1b1c:	12 97       	sbiw	r26, 0x02	; 2
    1b1e:	4b 53       	subi	r20, 0x3B	; 59
    1b20:	51 4d       	sbci	r21, 0xD1	; 209
    1b22:	e4 17       	cp	r30, r20
    1b24:	f5 07       	cpc	r31, r21
    1b26:	29 f4       	brne	.+10     	; 0x1b32 <vTaskSwitchContext+0xf4>
    1b28:	44 81       	ldd	r20, Z+4	; 0x04
    1b2a:	55 81       	ldd	r21, Z+5	; 0x05
    1b2c:	fd 01       	movw	r30, r26
    1b2e:	41 83       	std	Z+1, r20	; 0x01
    1b30:	52 83       	std	Z+2, r21	; 0x02
    1b32:	9b e0       	ldi	r25, 0x0B	; 11
    1b34:	92 9f       	mul	r25, r18
    1b36:	f0 01       	movw	r30, r0
    1b38:	93 9f       	mul	r25, r19
    1b3a:	f0 0d       	add	r31, r0
    1b3c:	11 24       	eor	r1, r1
    1b3e:	ee 53       	subi	r30, 0x3E	; 62
    1b40:	f1 4d       	sbci	r31, 0xD1	; 209
    1b42:	01 80       	ldd	r0, Z+1	; 0x01
    1b44:	f2 81       	ldd	r31, Z+2	; 0x02
    1b46:	e0 2d       	mov	r30, r0
    1b48:	20 85       	ldd	r18, Z+8	; 0x08
    1b4a:	31 85       	ldd	r19, Z+9	; 0x09
    1b4c:	20 93 ee 2e 	sts	0x2EEE, r18	; 0x802eee <pxCurrentTCB>
    1b50:	30 93 ef 2e 	sts	0x2EEF, r19	; 0x802eef <pxCurrentTCB+0x1>
    1b54:	80 93 8c 2e 	sts	0x2E8C, r24	; 0x802e8c <uxTopReadyPriority>
    1b58:	08 95       	ret

00001b5a <vTaskPlaceOnEventList>:
    1b5a:	cf 92       	push	r12
    1b5c:	df 92       	push	r13
    1b5e:	ef 92       	push	r14
    1b60:	ff 92       	push	r15
    1b62:	6a 01       	movw	r12, r20
    1b64:	7b 01       	movw	r14, r22
    1b66:	60 91 ee 2e 	lds	r22, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1b6a:	70 91 ef 2e 	lds	r23, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1b6e:	62 5f       	subi	r22, 0xF2	; 242
    1b70:	7f 4f       	sbci	r23, 0xFF	; 255
    1b72:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListInsert>
    1b76:	41 e0       	ldi	r20, 0x01	; 1
    1b78:	c7 01       	movw	r24, r14
    1b7a:	b6 01       	movw	r22, r12
    1b7c:	0e 94 c5 09 	call	0x138a	; 0x138a <prvAddCurrentTaskToDelayedList>
    1b80:	ff 90       	pop	r15
    1b82:	ef 90       	pop	r14
    1b84:	df 90       	pop	r13
    1b86:	cf 90       	pop	r12
    1b88:	08 95       	ret

00001b8a <vTaskPlaceOnUnorderedEventList>:
    1b8a:	cf 92       	push	r12
    1b8c:	df 92       	push	r13
    1b8e:	ef 92       	push	r14
    1b90:	ff 92       	push	r15
    1b92:	0f 93       	push	r16
    1b94:	1f 93       	push	r17
    1b96:	68 01       	movw	r12, r16
    1b98:	79 01       	movw	r14, r18
    1b9a:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1b9e:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1ba2:	70 68       	ori	r23, 0x80	; 128
    1ba4:	46 87       	std	Z+14, r20	; 0x0e
    1ba6:	57 87       	std	Z+15, r21	; 0x0f
    1ba8:	60 8b       	std	Z+16, r22	; 0x10
    1baa:	71 8b       	std	Z+17, r23	; 0x11
    1bac:	60 91 ee 2e 	lds	r22, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1bb0:	70 91 ef 2e 	lds	r23, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1bb4:	62 5f       	subi	r22, 0xF2	; 242
    1bb6:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb8:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    1bbc:	41 e0       	ldi	r20, 0x01	; 1
    1bbe:	c7 01       	movw	r24, r14
    1bc0:	b6 01       	movw	r22, r12
    1bc2:	0e 94 c5 09 	call	0x138a	; 0x138a <prvAddCurrentTaskToDelayedList>
    1bc6:	1f 91       	pop	r17
    1bc8:	0f 91       	pop	r16
    1bca:	ff 90       	pop	r15
    1bcc:	ef 90       	pop	r14
    1bce:	df 90       	pop	r13
    1bd0:	cf 90       	pop	r12
    1bd2:	08 95       	ret

00001bd4 <vTaskPlaceOnEventListRestricted>:
    1bd4:	cf 92       	push	r12
    1bd6:	df 92       	push	r13
    1bd8:	ef 92       	push	r14
    1bda:	ff 92       	push	r15
    1bdc:	cf 93       	push	r28
    1bde:	6a 01       	movw	r12, r20
    1be0:	7b 01       	movw	r14, r22
    1be2:	c2 2f       	mov	r28, r18
    1be4:	60 91 ee 2e 	lds	r22, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1be8:	70 91 ef 2e 	lds	r23, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1bec:	62 5f       	subi	r22, 0xF2	; 242
    1bee:	7f 4f       	sbci	r23, 0xFF	; 255
    1bf0:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    1bf4:	cc 23       	and	r28, r28
    1bf6:	21 f0       	breq	.+8      	; 0x1c00 <vTaskPlaceOnEventListRestricted+0x2c>
    1bf8:	cc 24       	eor	r12, r12
    1bfa:	ca 94       	dec	r12
    1bfc:	dc 2c       	mov	r13, r12
    1bfe:	76 01       	movw	r14, r12
    1c00:	4c 2f       	mov	r20, r28
    1c02:	c7 01       	movw	r24, r14
    1c04:	b6 01       	movw	r22, r12
    1c06:	0e 94 c5 09 	call	0x138a	; 0x138a <prvAddCurrentTaskToDelayedList>
    1c0a:	cf 91       	pop	r28
    1c0c:	ff 90       	pop	r15
    1c0e:	ef 90       	pop	r14
    1c10:	df 90       	pop	r13
    1c12:	cf 90       	pop	r12
    1c14:	08 95       	ret

00001c16 <xTaskRemoveFromEventList>:
    1c16:	0f 93       	push	r16
    1c18:	1f 93       	push	r17
    1c1a:	cf 93       	push	r28
    1c1c:	df 93       	push	r29
    1c1e:	dc 01       	movw	r26, r24
    1c20:	17 96       	adiw	r26, 0x07	; 7
    1c22:	ed 91       	ld	r30, X+
    1c24:	fc 91       	ld	r31, X
    1c26:	18 97       	sbiw	r26, 0x08	; 8
    1c28:	c0 85       	ldd	r28, Z+8	; 0x08
    1c2a:	d1 85       	ldd	r29, Z+9	; 0x09
    1c2c:	8e 01       	movw	r16, r28
    1c2e:	02 5f       	subi	r16, 0xF2	; 242
    1c30:	1f 4f       	sbci	r17, 0xFF	; 255
    1c32:	c8 01       	movw	r24, r16
    1c34:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
    1c38:	80 91 80 2e 	lds	r24, 0x2E80	; 0x802e80 <uxSchedulerSuspended>
    1c3c:	81 11       	cpse	r24, r1
    1c3e:	16 c0       	rjmp	.+44     	; 0x1c6c <xTaskRemoveFromEventList+0x56>
    1c40:	0c 50       	subi	r16, 0x0C	; 12
    1c42:	11 09       	sbc	r17, r1
    1c44:	c8 01       	movw	r24, r16
    1c46:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
    1c4a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c4c:	90 91 8c 2e 	lds	r25, 0x2E8C	; 0x802e8c <uxTopReadyPriority>
    1c50:	98 17       	cp	r25, r24
    1c52:	10 f4       	brcc	.+4      	; 0x1c58 <xTaskRemoveFromEventList+0x42>
    1c54:	80 93 8c 2e 	sts	0x2E8C, r24	; 0x802e8c <uxTopReadyPriority>
    1c58:	bb e0       	ldi	r27, 0x0B	; 11
    1c5a:	8b 9f       	mul	r24, r27
    1c5c:	c0 01       	movw	r24, r0
    1c5e:	11 24       	eor	r1, r1
    1c60:	b8 01       	movw	r22, r16
    1c62:	8e 53       	subi	r24, 0x3E	; 62
    1c64:	91 4d       	sbci	r25, 0xD1	; 209
    1c66:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    1c6a:	05 c0       	rjmp	.+10     	; 0x1c76 <xTaskRemoveFromEventList+0x60>
    1c6c:	b8 01       	movw	r22, r16
    1c6e:	8d e9       	ldi	r24, 0x9D	; 157
    1c70:	9e e2       	ldi	r25, 0x2E	; 46
    1c72:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    1c76:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1c7a:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1c7e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1c80:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c82:	89 17       	cp	r24, r25
    1c84:	20 f4       	brcc	.+8      	; 0x1c8e <xTaskRemoveFromEventList+0x78>
    1c86:	81 e0       	ldi	r24, 0x01	; 1
    1c88:	80 93 89 2e 	sts	0x2E89, r24	; 0x802e89 <xYieldPending>
    1c8c:	01 c0       	rjmp	.+2      	; 0x1c90 <xTaskRemoveFromEventList+0x7a>
    1c8e:	80 e0       	ldi	r24, 0x00	; 0
    1c90:	df 91       	pop	r29
    1c92:	cf 91       	pop	r28
    1c94:	1f 91       	pop	r17
    1c96:	0f 91       	pop	r16
    1c98:	08 95       	ret

00001c9a <vTaskRemoveFromUnorderedEventList>:
    1c9a:	0f 93       	push	r16
    1c9c:	1f 93       	push	r17
    1c9e:	cf 93       	push	r28
    1ca0:	df 93       	push	r29
    1ca2:	70 68       	ori	r23, 0x80	; 128
    1ca4:	fc 01       	movw	r30, r24
    1ca6:	40 83       	st	Z, r20
    1ca8:	51 83       	std	Z+1, r21	; 0x01
    1caa:	62 83       	std	Z+2, r22	; 0x02
    1cac:	73 83       	std	Z+3, r23	; 0x03
    1cae:	c0 85       	ldd	r28, Z+8	; 0x08
    1cb0:	d1 85       	ldd	r29, Z+9	; 0x09
    1cb2:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
    1cb6:	8e 01       	movw	r16, r28
    1cb8:	0e 5f       	subi	r16, 0xFE	; 254
    1cba:	1f 4f       	sbci	r17, 0xFF	; 255
    1cbc:	c8 01       	movw	r24, r16
    1cbe:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
    1cc2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1cc4:	90 91 8c 2e 	lds	r25, 0x2E8C	; 0x802e8c <uxTopReadyPriority>
    1cc8:	98 17       	cp	r25, r24
    1cca:	10 f4       	brcc	.+4      	; 0x1cd0 <vTaskRemoveFromUnorderedEventList+0x36>
    1ccc:	80 93 8c 2e 	sts	0x2E8C, r24	; 0x802e8c <uxTopReadyPriority>
    1cd0:	fb e0       	ldi	r31, 0x0B	; 11
    1cd2:	8f 9f       	mul	r24, r31
    1cd4:	c0 01       	movw	r24, r0
    1cd6:	11 24       	eor	r1, r1
    1cd8:	b8 01       	movw	r22, r16
    1cda:	8e 53       	subi	r24, 0x3E	; 62
    1cdc:	91 4d       	sbci	r25, 0xD1	; 209
    1cde:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
    1ce2:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1ce6:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1cea:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1cec:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cee:	89 17       	cp	r24, r25
    1cf0:	18 f4       	brcc	.+6      	; 0x1cf8 <vTaskRemoveFromUnorderedEventList+0x5e>
    1cf2:	81 e0       	ldi	r24, 0x01	; 1
    1cf4:	80 93 89 2e 	sts	0x2E89, r24	; 0x802e89 <xYieldPending>
    1cf8:	df 91       	pop	r29
    1cfa:	cf 91       	pop	r28
    1cfc:	1f 91       	pop	r17
    1cfe:	0f 91       	pop	r16
    1d00:	08 95       	ret

00001d02 <vTaskInternalSetTimeOutState>:
    1d02:	20 91 88 2e 	lds	r18, 0x2E88	; 0x802e88 <xNumOfOverflows>
    1d06:	fc 01       	movw	r30, r24
    1d08:	20 83       	st	Z, r18
    1d0a:	40 91 8d 2e 	lds	r20, 0x2E8D	; 0x802e8d <xTickCount>
    1d0e:	50 91 8e 2e 	lds	r21, 0x2E8E	; 0x802e8e <xTickCount+0x1>
    1d12:	60 91 8f 2e 	lds	r22, 0x2E8F	; 0x802e8f <xTickCount+0x2>
    1d16:	70 91 90 2e 	lds	r23, 0x2E90	; 0x802e90 <xTickCount+0x3>
    1d1a:	41 83       	std	Z+1, r20	; 0x01
    1d1c:	52 83       	std	Z+2, r21	; 0x02
    1d1e:	63 83       	std	Z+3, r22	; 0x03
    1d20:	74 83       	std	Z+4, r23	; 0x04
    1d22:	08 95       	ret

00001d24 <xTaskCheckForTimeOut>:
    1d24:	cf 92       	push	r12
    1d26:	df 92       	push	r13
    1d28:	ef 92       	push	r14
    1d2a:	ff 92       	push	r15
    1d2c:	0f 93       	push	r16
    1d2e:	1f 93       	push	r17
    1d30:	cf 93       	push	r28
    1d32:	df 93       	push	r29
    1d34:	db 01       	movw	r26, r22
    1d36:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1d3a:	ff 93       	push	r31
    1d3c:	f8 7f       	andi	r31, 0xF8	; 248
    1d3e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1d42:	40 91 8d 2e 	lds	r20, 0x2E8D	; 0x802e8d <xTickCount>
    1d46:	50 91 8e 2e 	lds	r21, 0x2E8E	; 0x802e8e <xTickCount+0x1>
    1d4a:	60 91 8f 2e 	lds	r22, 0x2E8F	; 0x802e8f <xTickCount+0x2>
    1d4e:	70 91 90 2e 	lds	r23, 0x2E90	; 0x802e90 <xTickCount+0x3>
    1d52:	0d 91       	ld	r16, X+
    1d54:	1d 91       	ld	r17, X+
    1d56:	2d 91       	ld	r18, X+
    1d58:	3c 91       	ld	r19, X
    1d5a:	13 97       	sbiw	r26, 0x03	; 3
    1d5c:	0f 3f       	cpi	r16, 0xFF	; 255
    1d5e:	cf ef       	ldi	r28, 0xFF	; 255
    1d60:	1c 07       	cpc	r17, r28
    1d62:	2c 07       	cpc	r18, r28
    1d64:	3c 07       	cpc	r19, r28
    1d66:	69 f1       	breq	.+90     	; 0x1dc2 <xTaskCheckForTimeOut+0x9e>
    1d68:	fc 01       	movw	r30, r24
    1d6a:	c1 80       	ldd	r12, Z+1	; 0x01
    1d6c:	d2 80       	ldd	r13, Z+2	; 0x02
    1d6e:	e3 80       	ldd	r14, Z+3	; 0x03
    1d70:	f4 80       	ldd	r15, Z+4	; 0x04
    1d72:	e0 91 88 2e 	lds	r30, 0x2E88	; 0x802e88 <xNumOfOverflows>
    1d76:	ec 01       	movw	r28, r24
    1d78:	f8 81       	ld	r31, Y
    1d7a:	fe 17       	cp	r31, r30
    1d7c:	29 f0       	breq	.+10     	; 0x1d88 <xTaskCheckForTimeOut+0x64>
    1d7e:	4c 15       	cp	r20, r12
    1d80:	5d 05       	cpc	r21, r13
    1d82:	6e 05       	cpc	r22, r14
    1d84:	7f 05       	cpc	r23, r15
    1d86:	f8 f4       	brcc	.+62     	; 0x1dc6 <xTaskCheckForTimeOut+0xa2>
    1d88:	4c 19       	sub	r20, r12
    1d8a:	5d 09       	sbc	r21, r13
    1d8c:	6e 09       	sbc	r22, r14
    1d8e:	7f 09       	sbc	r23, r15
    1d90:	40 17       	cp	r20, r16
    1d92:	51 07       	cpc	r21, r17
    1d94:	62 07       	cpc	r22, r18
    1d96:	73 07       	cpc	r23, r19
    1d98:	68 f4       	brcc	.+26     	; 0x1db4 <xTaskCheckForTimeOut+0x90>
    1d9a:	fd 01       	movw	r30, r26
    1d9c:	04 1b       	sub	r16, r20
    1d9e:	15 0b       	sbc	r17, r21
    1da0:	26 0b       	sbc	r18, r22
    1da2:	37 0b       	sbc	r19, r23
    1da4:	00 83       	st	Z, r16
    1da6:	11 83       	std	Z+1, r17	; 0x01
    1da8:	22 83       	std	Z+2, r18	; 0x02
    1daa:	33 83       	std	Z+3, r19	; 0x03
    1dac:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <vTaskInternalSetTimeOutState>
    1db0:	80 e0       	ldi	r24, 0x00	; 0
    1db2:	0a c0       	rjmp	.+20     	; 0x1dc8 <xTaskCheckForTimeOut+0xa4>
    1db4:	1d 92       	st	X+, r1
    1db6:	1d 92       	st	X+, r1
    1db8:	1d 92       	st	X+, r1
    1dba:	1c 92       	st	X, r1
    1dbc:	13 97       	sbiw	r26, 0x03	; 3
    1dbe:	81 e0       	ldi	r24, 0x01	; 1
    1dc0:	03 c0       	rjmp	.+6      	; 0x1dc8 <xTaskCheckForTimeOut+0xa4>
    1dc2:	80 e0       	ldi	r24, 0x00	; 0
    1dc4:	01 c0       	rjmp	.+2      	; 0x1dc8 <xTaskCheckForTimeOut+0xa4>
    1dc6:	81 e0       	ldi	r24, 0x01	; 1
    1dc8:	ff 91       	pop	r31
    1dca:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1dce:	df 91       	pop	r29
    1dd0:	cf 91       	pop	r28
    1dd2:	1f 91       	pop	r17
    1dd4:	0f 91       	pop	r16
    1dd6:	ff 90       	pop	r15
    1dd8:	ef 90       	pop	r14
    1dda:	df 90       	pop	r13
    1ddc:	cf 90       	pop	r12
    1dde:	08 95       	ret

00001de0 <vTaskMissedYield>:
    1de0:	81 e0       	ldi	r24, 0x01	; 1
    1de2:	80 93 89 2e 	sts	0x2E89, r24	; 0x802e89 <xYieldPending>
    1de6:	08 95       	ret

00001de8 <xTaskGetSchedulerState>:
    1de8:	80 91 8b 2e 	lds	r24, 0x2E8B	; 0x802e8b <xSchedulerRunning>
    1dec:	88 23       	and	r24, r24
    1dee:	31 f0       	breq	.+12     	; 0x1dfc <xTaskGetSchedulerState+0x14>
    1df0:	80 91 80 2e 	lds	r24, 0x2E80	; 0x802e80 <uxSchedulerSuspended>
    1df4:	88 23       	and	r24, r24
    1df6:	21 f0       	breq	.+8      	; 0x1e00 <xTaskGetSchedulerState+0x18>
    1df8:	80 e0       	ldi	r24, 0x00	; 0
    1dfa:	08 95       	ret
    1dfc:	81 e0       	ldi	r24, 0x01	; 1
    1dfe:	08 95       	ret
    1e00:	82 e0       	ldi	r24, 0x02	; 2
    1e02:	08 95       	ret

00001e04 <uxTaskResetEventItemValue>:
    1e04:	cf 92       	push	r12
    1e06:	df 92       	push	r13
    1e08:	ef 92       	push	r14
    1e0a:	ff 92       	push	r15
    1e0c:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1e10:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1e14:	66 85       	ldd	r22, Z+14	; 0x0e
    1e16:	77 85       	ldd	r23, Z+15	; 0x0f
    1e18:	80 89       	ldd	r24, Z+16	; 0x10
    1e1a:	91 89       	ldd	r25, Z+17	; 0x11
    1e1c:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1e20:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1e24:	a0 91 ee 2e 	lds	r26, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1e28:	b0 91 ef 2e 	lds	r27, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1e2c:	5a 96       	adiw	r26, 0x1a	; 26
    1e2e:	2c 91       	ld	r18, X
    1e30:	c1 2c       	mov	r12, r1
    1e32:	d1 2c       	mov	r13, r1
    1e34:	76 01       	movw	r14, r12
    1e36:	68 94       	set
    1e38:	c2 f8       	bld	r12, 2
    1e3a:	c2 1a       	sub	r12, r18
    1e3c:	d1 08       	sbc	r13, r1
    1e3e:	e1 08       	sbc	r14, r1
    1e40:	f1 08       	sbc	r15, r1
    1e42:	c6 86       	std	Z+14, r12	; 0x0e
    1e44:	d7 86       	std	Z+15, r13	; 0x0f
    1e46:	e0 8a       	std	Z+16, r14	; 0x10
    1e48:	f1 8a       	std	Z+17, r15	; 0x11
    1e4a:	ff 90       	pop	r15
    1e4c:	ef 90       	pop	r14
    1e4e:	df 90       	pop	r13
    1e50:	cf 90       	pop	r12
    1e52:	08 95       	ret

00001e54 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    1e54:	4f 92       	push	r4
    1e56:	5f 92       	push	r5
    1e58:	6f 92       	push	r6
    1e5a:	7f 92       	push	r7
    1e5c:	8f 92       	push	r8
    1e5e:	9f 92       	push	r9
    1e60:	af 92       	push	r10
    1e62:	bf 92       	push	r11
    1e64:	cf 92       	push	r12
    1e66:	df 92       	push	r13
    1e68:	ef 92       	push	r14
    1e6a:	ff 92       	push	r15
    1e6c:	0f 93       	push	r16
    1e6e:	1f 93       	push	r17
    1e70:	49 01       	movw	r8, r18
    1e72:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    1e74:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1e78:	ff 93       	push	r31
    1e7a:	f8 7f       	andi	r31, 0xF8	; 248
    1e7c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1e80:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1e84:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1e88:	23 a5       	ldd	r18, Z+43	; 0x2b
    1e8a:	22 30       	cpi	r18, 0x02	; 2
    1e8c:	41 f1       	breq	.+80     	; 0x1ede <xTaskNotifyWait+0x8a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    1e8e:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1e92:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1e96:	47 a0       	ldd	r4, Z+39	; 0x27
    1e98:	50 a4       	ldd	r5, Z+40	; 0x28
    1e9a:	61 a4       	ldd	r6, Z+41	; 0x29
    1e9c:	72 a4       	ldd	r7, Z+42	; 0x2a
    1e9e:	dc 01       	movw	r26, r24
    1ea0:	cb 01       	movw	r24, r22
    1ea2:	80 95       	com	r24
    1ea4:	90 95       	com	r25
    1ea6:	a0 95       	com	r26
    1ea8:	b0 95       	com	r27
    1eaa:	84 21       	and	r24, r4
    1eac:	95 21       	and	r25, r5
    1eae:	a6 21       	and	r26, r6
    1eb0:	b7 21       	and	r27, r7
    1eb2:	87 a3       	std	Z+39, r24	; 0x27
    1eb4:	90 a7       	std	Z+40, r25	; 0x28
    1eb6:	a1 a7       	std	Z+41, r26	; 0x29
    1eb8:	b2 a7       	std	Z+42, r27	; 0x2a

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1eba:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1ebe:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1ec2:	81 e0       	ldi	r24, 0x01	; 1
    1ec4:	83 a7       	std	Z+43, r24	; 0x2b

				if( xTicksToWait > ( TickType_t ) 0 )
    1ec6:	c1 14       	cp	r12, r1
    1ec8:	d1 04       	cpc	r13, r1
    1eca:	e1 04       	cpc	r14, r1
    1ecc:	f1 04       	cpc	r15, r1
    1ece:	39 f0       	breq	.+14     	; 0x1ede <xTaskNotifyWait+0x8a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1ed0:	41 e0       	ldi	r20, 0x01	; 1
    1ed2:	c7 01       	movw	r24, r14
    1ed4:	b6 01       	movw	r22, r12
    1ed6:	0e 94 c5 09 	call	0x138a	; 0x138a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1eda:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1ede:	ff 91       	pop	r31
    1ee0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>

		taskENTER_CRITICAL();
    1ee4:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1ee8:	ff 93       	push	r31
    1eea:	f8 7f       	andi	r31, 0xF8	; 248
    1eec:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1ef0:	01 15       	cp	r16, r1
    1ef2:	11 05       	cpc	r17, r1
    1ef4:	69 f0       	breq	.+26     	; 0x1f10 <xTaskNotifyWait+0xbc>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    1ef6:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1efa:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1efe:	87 a1       	ldd	r24, Z+39	; 0x27
    1f00:	90 a5       	ldd	r25, Z+40	; 0x28
    1f02:	a1 a5       	ldd	r26, Z+41	; 0x29
    1f04:	b2 a5       	ldd	r27, Z+42	; 0x2a
    1f06:	f8 01       	movw	r30, r16
    1f08:	80 83       	st	Z, r24
    1f0a:	91 83       	std	Z+1, r25	; 0x01
    1f0c:	a2 83       	std	Z+2, r26	; 0x02
    1f0e:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1f10:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1f14:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1f18:	83 a5       	ldd	r24, Z+43	; 0x2b
    1f1a:	82 30       	cpi	r24, 0x02	; 2
    1f1c:	b1 f4       	brne	.+44     	; 0x1f4a <xTaskNotifyWait+0xf6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    1f1e:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1f22:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1f26:	87 a1       	ldd	r24, Z+39	; 0x27
    1f28:	90 a5       	ldd	r25, Z+40	; 0x28
    1f2a:	a1 a5       	ldd	r26, Z+41	; 0x29
    1f2c:	b2 a5       	ldd	r27, Z+42	; 0x2a
    1f2e:	80 94       	com	r8
    1f30:	90 94       	com	r9
    1f32:	a0 94       	com	r10
    1f34:	b0 94       	com	r11
    1f36:	88 22       	and	r8, r24
    1f38:	99 22       	and	r9, r25
    1f3a:	aa 22       	and	r10, r26
    1f3c:	bb 22       	and	r11, r27
    1f3e:	87 a2       	std	Z+39, r8	; 0x27
    1f40:	90 a6       	std	Z+40, r9	; 0x28
    1f42:	a1 a6       	std	Z+41, r10	; 0x29
    1f44:	b2 a6       	std	Z+42, r11	; 0x2a
				xReturn = pdTRUE;
    1f46:	81 e0       	ldi	r24, 0x01	; 1
    1f48:	01 c0       	rjmp	.+2      	; 0x1f4c <xTaskNotifyWait+0xf8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    1f4a:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1f4c:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    1f50:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    1f54:	13 a6       	std	Z+43, r1	; 0x2b
		}
		taskEXIT_CRITICAL();
    1f56:	ff 91       	pop	r31
    1f58:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>

		return xReturn;
	}
    1f5c:	1f 91       	pop	r17
    1f5e:	0f 91       	pop	r16
    1f60:	ff 90       	pop	r15
    1f62:	ef 90       	pop	r14
    1f64:	df 90       	pop	r13
    1f66:	cf 90       	pop	r12
    1f68:	bf 90       	pop	r11
    1f6a:	af 90       	pop	r10
    1f6c:	9f 90       	pop	r9
    1f6e:	8f 90       	pop	r8
    1f70:	7f 90       	pop	r7
    1f72:	6f 90       	pop	r6
    1f74:	5f 90       	pop	r5
    1f76:	4f 90       	pop	r4
    1f78:	08 95       	ret

00001f7a <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    1f7a:	cf 92       	push	r12
    1f7c:	df 92       	push	r13
    1f7e:	ef 92       	push	r14
    1f80:	ff 92       	push	r15
    1f82:	0f 93       	push	r16
    1f84:	1f 93       	push	r17
    1f86:	cf 93       	push	r28
    1f88:	df 93       	push	r29
    1f8a:	dc 01       	movw	r26, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    1f8c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f90:	ff 93       	push	r31
    1f92:	f8 7f       	andi	r31, 0xF8	; 248
    1f94:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		{
			if( pulPreviousNotificationValue != NULL )
    1f98:	01 15       	cp	r16, r1
    1f9a:	11 05       	cpc	r17, r1
    1f9c:	59 f0       	breq	.+22     	; 0x1fb4 <xTaskGenericNotify+0x3a>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1f9e:	97 96       	adiw	r26, 0x27	; 39
    1fa0:	cd 90       	ld	r12, X+
    1fa2:	dd 90       	ld	r13, X+
    1fa4:	ed 90       	ld	r14, X+
    1fa6:	fc 90       	ld	r15, X
    1fa8:	9a 97       	sbiw	r26, 0x2a	; 42
    1faa:	f8 01       	movw	r30, r16
    1fac:	c0 82       	st	Z, r12
    1fae:	d1 82       	std	Z+1, r13	; 0x01
    1fb0:	e2 82       	std	Z+2, r14	; 0x02
    1fb2:	f3 82       	std	Z+3, r15	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1fb4:	9b 96       	adiw	r26, 0x2b	; 43
    1fb6:	8c 91       	ld	r24, X
    1fb8:	9b 97       	sbiw	r26, 0x2b	; 43

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1fba:	92 e0       	ldi	r25, 0x02	; 2
    1fbc:	9b 96       	adiw	r26, 0x2b	; 43
    1fbe:	9c 93       	st	X, r25
    1fc0:	9b 97       	sbiw	r26, 0x2b	; 43

			switch( eAction )
    1fc2:	22 30       	cpi	r18, 0x02	; 2
    1fc4:	d1 f0       	breq	.+52     	; 0x1ffa <xTaskGenericNotify+0x80>
    1fc6:	18 f4       	brcc	.+6      	; 0x1fce <xTaskGenericNotify+0x54>
    1fc8:	21 30       	cpi	r18, 0x01	; 1
    1fca:	31 f0       	breq	.+12     	; 0x1fd8 <xTaskGenericNotify+0x5e>
    1fcc:	36 c0       	rjmp	.+108    	; 0x203a <xTaskGenericNotify+0xc0>
    1fce:	23 30       	cpi	r18, 0x03	; 3
    1fd0:	29 f1       	breq	.+74     	; 0x201c <xTaskGenericNotify+0xa2>
    1fd2:	24 30       	cpi	r18, 0x04	; 4
    1fd4:	51 f1       	breq	.+84     	; 0x202a <xTaskGenericNotify+0xb0>
    1fd6:	31 c0       	rjmp	.+98     	; 0x203a <xTaskGenericNotify+0xc0>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1fd8:	97 96       	adiw	r26, 0x27	; 39
    1fda:	0d 91       	ld	r16, X+
    1fdc:	1d 91       	ld	r17, X+
    1fde:	2d 91       	ld	r18, X+
    1fe0:	3c 91       	ld	r19, X
    1fe2:	9a 97       	sbiw	r26, 0x2a	; 42
    1fe4:	40 2b       	or	r20, r16
    1fe6:	51 2b       	or	r21, r17
    1fe8:	62 2b       	or	r22, r18
    1fea:	73 2b       	or	r23, r19
    1fec:	97 96       	adiw	r26, 0x27	; 39
    1fee:	4d 93       	st	X+, r20
    1ff0:	5d 93       	st	X+, r21
    1ff2:	6d 93       	st	X+, r22
    1ff4:	7c 93       	st	X, r23
    1ff6:	9a 97       	sbiw	r26, 0x2a	; 42
					break;
    1ff8:	20 c0       	rjmp	.+64     	; 0x203a <xTaskGenericNotify+0xc0>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1ffa:	97 96       	adiw	r26, 0x27	; 39
    1ffc:	4d 91       	ld	r20, X+
    1ffe:	5d 91       	ld	r21, X+
    2000:	6d 91       	ld	r22, X+
    2002:	7c 91       	ld	r23, X
    2004:	9a 97       	sbiw	r26, 0x2a	; 42
    2006:	4f 5f       	subi	r20, 0xFF	; 255
    2008:	5f 4f       	sbci	r21, 0xFF	; 255
    200a:	6f 4f       	sbci	r22, 0xFF	; 255
    200c:	7f 4f       	sbci	r23, 0xFF	; 255
    200e:	97 96       	adiw	r26, 0x27	; 39
    2010:	4d 93       	st	X+, r20
    2012:	5d 93       	st	X+, r21
    2014:	6d 93       	st	X+, r22
    2016:	7c 93       	st	X, r23
    2018:	9a 97       	sbiw	r26, 0x2a	; 42
					break;
    201a:	0f c0       	rjmp	.+30     	; 0x203a <xTaskGenericNotify+0xc0>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    201c:	97 96       	adiw	r26, 0x27	; 39
    201e:	4d 93       	st	X+, r20
    2020:	5d 93       	st	X+, r21
    2022:	6d 93       	st	X+, r22
    2024:	7c 93       	st	X, r23
    2026:	9a 97       	sbiw	r26, 0x2a	; 42
					break;
    2028:	08 c0       	rjmp	.+16     	; 0x203a <xTaskGenericNotify+0xc0>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    202a:	82 30       	cpi	r24, 0x02	; 2
    202c:	59 f1       	breq	.+86     	; 0x2084 <xTaskGenericNotify+0x10a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    202e:	97 96       	adiw	r26, 0x27	; 39
    2030:	4d 93       	st	X+, r20
    2032:	5d 93       	st	X+, r21
    2034:	6d 93       	st	X+, r22
    2036:	7c 93       	st	X, r23
    2038:	9a 97       	sbiw	r26, 0x2a	; 42

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    203a:	81 30       	cpi	r24, 0x01	; 1
    203c:	29 f5       	brne	.+74     	; 0x2088 <xTaskGenericNotify+0x10e>
    203e:	ed 01       	movw	r28, r26
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2040:	8d 01       	movw	r16, r26
    2042:	0e 5f       	subi	r16, 0xFE	; 254
    2044:	1f 4f       	sbci	r17, 0xFF	; 255
    2046:	c8 01       	movw	r24, r16
    2048:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    204c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    204e:	90 91 8c 2e 	lds	r25, 0x2E8C	; 0x802e8c <uxTopReadyPriority>
    2052:	98 17       	cp	r25, r24
    2054:	10 f4       	brcc	.+4      	; 0x205a <xTaskGenericNotify+0xe0>
    2056:	80 93 8c 2e 	sts	0x2E8C, r24	; 0x802e8c <uxTopReadyPriority>
    205a:	fb e0       	ldi	r31, 0x0B	; 11
    205c:	8f 9f       	mul	r24, r31
    205e:	c0 01       	movw	r24, r0
    2060:	11 24       	eor	r1, r1
    2062:	b8 01       	movw	r22, r16
    2064:	8e 53       	subi	r24, 0x3E	; 62
    2066:	91 4d       	sbci	r25, 0xD1	; 209
    2068:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    206c:	e0 91 ee 2e 	lds	r30, 0x2EEE	; 0x802eee <pxCurrentTCB>
    2070:	f0 91 ef 2e 	lds	r31, 0x2EEF	; 0x802eef <pxCurrentTCB+0x1>
    2074:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2076:	82 8d       	ldd	r24, Z+26	; 0x1a
    2078:	89 17       	cp	r24, r25
    207a:	40 f4       	brcc	.+16     	; 0x208c <xTaskGenericNotify+0x112>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    207c:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
    2080:	81 e0       	ldi	r24, 0x01	; 1
    2082:	05 c0       	rjmp	.+10     	; 0x208e <xTaskGenericNotify+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2084:	80 e0       	ldi	r24, 0x00	; 0
    2086:	03 c0       	rjmp	.+6      	; 0x208e <xTaskGenericNotify+0x114>
    2088:	81 e0       	ldi	r24, 0x01	; 1
    208a:	01 c0       	rjmp	.+2      	; 0x208e <xTaskGenericNotify+0x114>
    208c:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    208e:	ff 91       	pop	r31
    2090:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>

		return xReturn;
	}
    2094:	df 91       	pop	r29
    2096:	cf 91       	pop	r28
    2098:	1f 91       	pop	r17
    209a:	0f 91       	pop	r16
    209c:	ff 90       	pop	r15
    209e:	ef 90       	pop	r14
    20a0:	df 90       	pop	r13
    20a2:	cf 90       	pop	r12
    20a4:	08 95       	ret

000020a6 <prvInsertTimerInActiveList>:

	taskENTER_CRITICAL();
	{
		pxTimer->pvTimerID = pvNewID;
	}
	taskEXIT_CRITICAL();
    20a6:	cf 92       	push	r12
    20a8:	df 92       	push	r13
    20aa:	ef 92       	push	r14
    20ac:	ff 92       	push	r15
    20ae:	0f 93       	push	r16
    20b0:	1f 93       	push	r17
    20b2:	fc 01       	movw	r30, r24
    20b4:	42 83       	std	Z+2, r20	; 0x02
    20b6:	53 83       	std	Z+3, r21	; 0x03
    20b8:	64 83       	std	Z+4, r22	; 0x04
    20ba:	75 83       	std	Z+5, r23	; 0x05
    20bc:	82 87       	std	Z+10, r24	; 0x0a
    20be:	93 87       	std	Z+11, r25	; 0x0b
    20c0:	04 17       	cp	r16, r20
    20c2:	15 07       	cpc	r17, r21
    20c4:	26 07       	cpc	r18, r22
    20c6:	37 07       	cpc	r19, r23
    20c8:	c0 f0       	brcs	.+48     	; 0x20fa <prvInsertTimerInActiveList+0x54>
    20ca:	0c 19       	sub	r16, r12
    20cc:	1d 09       	sbc	r17, r13
    20ce:	2e 09       	sbc	r18, r14
    20d0:	3f 09       	sbc	r19, r15
    20d2:	86 85       	ldd	r24, Z+14	; 0x0e
    20d4:	97 85       	ldd	r25, Z+15	; 0x0f
    20d6:	a0 89       	ldd	r26, Z+16	; 0x10
    20d8:	b1 89       	ldd	r27, Z+17	; 0x11
    20da:	08 17       	cp	r16, r24
    20dc:	19 07       	cpc	r17, r25
    20de:	2a 07       	cpc	r18, r26
    20e0:	3b 07       	cpc	r19, r27
    20e2:	00 f5       	brcc	.+64     	; 0x2124 <prvInsertTimerInActiveList+0x7e>
    20e4:	bf 01       	movw	r22, r30
    20e6:	6e 5f       	subi	r22, 0xFE	; 254
    20e8:	7f 4f       	sbci	r23, 0xFF	; 255
    20ea:	80 91 f8 2e 	lds	r24, 0x2EF8	; 0x802ef8 <pxOverflowTimerList>
    20ee:	90 91 f9 2e 	lds	r25, 0x2EF9	; 0x802ef9 <pxOverflowTimerList+0x1>
    20f2:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListInsert>
    20f6:	80 e0       	ldi	r24, 0x00	; 0
    20f8:	18 c0       	rjmp	.+48     	; 0x212a <prvInsertTimerInActiveList+0x84>
    20fa:	0c 15       	cp	r16, r12
    20fc:	1d 05       	cpc	r17, r13
    20fe:	2e 05       	cpc	r18, r14
    2100:	3f 05       	cpc	r19, r15
    2102:	28 f4       	brcc	.+10     	; 0x210e <prvInsertTimerInActiveList+0x68>
    2104:	4c 15       	cp	r20, r12
    2106:	5d 05       	cpc	r21, r13
    2108:	6e 05       	cpc	r22, r14
    210a:	7f 05       	cpc	r23, r15
    210c:	68 f4       	brcc	.+26     	; 0x2128 <prvInsertTimerInActiveList+0x82>
    210e:	bf 01       	movw	r22, r30
    2110:	6e 5f       	subi	r22, 0xFE	; 254
    2112:	7f 4f       	sbci	r23, 0xFF	; 255
    2114:	80 91 fa 2e 	lds	r24, 0x2EFA	; 0x802efa <pxCurrentTimerList>
    2118:	90 91 fb 2e 	lds	r25, 0x2EFB	; 0x802efb <pxCurrentTimerList+0x1>
    211c:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListInsert>
    2120:	80 e0       	ldi	r24, 0x00	; 0
    2122:	03 c0       	rjmp	.+6      	; 0x212a <prvInsertTimerInActiveList+0x84>
    2124:	81 e0       	ldi	r24, 0x01	; 1
    2126:	01 c0       	rjmp	.+2      	; 0x212a <prvInsertTimerInActiveList+0x84>
    2128:	81 e0       	ldi	r24, 0x01	; 1
    212a:	1f 91       	pop	r17
    212c:	0f 91       	pop	r16
    212e:	ff 90       	pop	r15
    2130:	ef 90       	pop	r14
    2132:	df 90       	pop	r13
    2134:	cf 90       	pop	r12
    2136:	08 95       	ret

00002138 <prvCheckForValidListAndQueue>:
    2138:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    213c:	ff 93       	push	r31
    213e:	f8 7f       	andi	r31, 0xF8	; 248
    2140:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    2144:	80 91 f6 2e 	lds	r24, 0x2EF6	; 0x802ef6 <xTimerQueue>
    2148:	90 91 f7 2e 	lds	r25, 0x2EF7	; 0x802ef7 <xTimerQueue+0x1>
    214c:	89 2b       	or	r24, r25
    214e:	e9 f4       	brne	.+58     	; 0x218a <prvCheckForValidListAndQueue+0x52>
    2150:	87 e0       	ldi	r24, 0x07	; 7
    2152:	9f e2       	ldi	r25, 0x2F	; 47
    2154:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
    2158:	8c ef       	ldi	r24, 0xFC	; 252
    215a:	9e e2       	ldi	r25, 0x2E	; 46
    215c:	0e 94 49 04 	call	0x892	; 0x892 <vListInitialise>
    2160:	87 e0       	ldi	r24, 0x07	; 7
    2162:	9f e2       	ldi	r25, 0x2F	; 47
    2164:	80 93 fa 2e 	sts	0x2EFA, r24	; 0x802efa <pxCurrentTimerList>
    2168:	90 93 fb 2e 	sts	0x2EFB, r25	; 0x802efb <pxCurrentTimerList+0x1>
    216c:	8c ef       	ldi	r24, 0xFC	; 252
    216e:	9e e2       	ldi	r25, 0x2E	; 46
    2170:	80 93 f8 2e 	sts	0x2EF8, r24	; 0x802ef8 <pxOverflowTimerList>
    2174:	90 93 f9 2e 	sts	0x2EF9, r25	; 0x802ef9 <pxOverflowTimerList+0x1>
    2178:	40 e0       	ldi	r20, 0x00	; 0
    217a:	69 e0       	ldi	r22, 0x09	; 9
    217c:	85 e0       	ldi	r24, 0x05	; 5
    217e:	0e 94 ac 07 	call	0xf58	; 0xf58 <xQueueGenericCreate>
    2182:	80 93 f6 2e 	sts	0x2EF6, r24	; 0x802ef6 <xTimerQueue>
    2186:	90 93 f7 2e 	sts	0x2EF7, r25	; 0x802ef7 <xTimerQueue+0x1>
    218a:	ff 91       	pop	r31
    218c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    2190:	08 95       	ret

00002192 <xTimerCreateTimerTask>:
    2192:	ef 92       	push	r14
    2194:	ff 92       	push	r15
    2196:	0f 93       	push	r16
    2198:	0e 94 9c 10 	call	0x2138	; 0x2138 <prvCheckForValidListAndQueue>
    219c:	80 91 f6 2e 	lds	r24, 0x2EF6	; 0x802ef6 <xTimerQueue>
    21a0:	90 91 f7 2e 	lds	r25, 0x2EF7	; 0x802ef7 <xTimerQueue+0x1>
    21a4:	89 2b       	or	r24, r25
    21a6:	91 f0       	breq	.+36     	; 0x21cc <xTimerCreateTimerTask+0x3a>
    21a8:	0f 2e       	mov	r0, r31
    21aa:	f4 ef       	ldi	r31, 0xF4	; 244
    21ac:	ef 2e       	mov	r14, r31
    21ae:	fe e2       	ldi	r31, 0x2E	; 46
    21b0:	ff 2e       	mov	r15, r31
    21b2:	f0 2d       	mov	r31, r0
    21b4:	03 e0       	ldi	r16, 0x03	; 3
    21b6:	20 e0       	ldi	r18, 0x00	; 0
    21b8:	30 e0       	ldi	r19, 0x00	; 0
    21ba:	48 ec       	ldi	r20, 0xC8	; 200
    21bc:	50 e0       	ldi	r21, 0x00	; 0
    21be:	66 e0       	ldi	r22, 0x06	; 6
    21c0:	70 e2       	ldi	r23, 0x20	; 32
    21c2:	8c ed       	ldi	r24, 0xDC	; 220
    21c4:	91 e1       	ldi	r25, 0x11	; 17
    21c6:	0e 94 46 0a 	call	0x148c	; 0x148c <xTaskCreate>
    21ca:	01 c0       	rjmp	.+2      	; 0x21ce <xTimerCreateTimerTask+0x3c>
    21cc:	80 e0       	ldi	r24, 0x00	; 0
    21ce:	0f 91       	pop	r16
    21d0:	ff 90       	pop	r15
    21d2:	ef 90       	pop	r14
    21d4:	08 95       	ret

000021d6 <xTimerGenericCommand>:
    21d6:	8f 92       	push	r8
    21d8:	9f 92       	push	r9
    21da:	af 92       	push	r10
    21dc:	bf 92       	push	r11
    21de:	cf 92       	push	r12
    21e0:	df 92       	push	r13
    21e2:	ef 92       	push	r14
    21e4:	ff 92       	push	r15
    21e6:	0f 93       	push	r16
    21e8:	1f 93       	push	r17
    21ea:	cf 93       	push	r28
    21ec:	df 93       	push	r29
    21ee:	cd b7       	in	r28, 0x3d	; 61
    21f0:	de b7       	in	r29, 0x3e	; 62
    21f2:	29 97       	sbiw	r28, 0x09	; 9
    21f4:	cd bf       	out	0x3d, r28	; 61
    21f6:	de bf       	out	0x3e, r29	; 62
    21f8:	e0 91 f6 2e 	lds	r30, 0x2EF6	; 0x802ef6 <xTimerQueue>
    21fc:	f0 91 f7 2e 	lds	r31, 0x2EF7	; 0x802ef7 <xTimerQueue+0x1>
    2200:	30 97       	sbiw	r30, 0x00	; 0
    2202:	89 f1       	breq	.+98     	; 0x2266 <xTimerGenericCommand+0x90>
    2204:	69 83       	std	Y+1, r22	; 0x01
    2206:	2a 83       	std	Y+2, r18	; 0x02
    2208:	3b 83       	std	Y+3, r19	; 0x03
    220a:	4c 83       	std	Y+4, r20	; 0x04
    220c:	5d 83       	std	Y+5, r21	; 0x05
    220e:	8e 83       	std	Y+6, r24	; 0x06
    2210:	9f 83       	std	Y+7, r25	; 0x07
    2212:	66 30       	cpi	r22, 0x06	; 6
    2214:	fc f4       	brge	.+62     	; 0x2254 <xTimerGenericCommand+0x7e>
    2216:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <xTaskGetSchedulerState>
    221a:	82 30       	cpi	r24, 0x02	; 2
    221c:	69 f4       	brne	.+26     	; 0x2238 <xTimerGenericCommand+0x62>
    221e:	00 e0       	ldi	r16, 0x00	; 0
    2220:	a7 01       	movw	r20, r14
    2222:	96 01       	movw	r18, r12
    2224:	be 01       	movw	r22, r28
    2226:	6f 5f       	subi	r22, 0xFF	; 255
    2228:	7f 4f       	sbci	r23, 0xFF	; 255
    222a:	80 91 f6 2e 	lds	r24, 0x2EF6	; 0x802ef6 <xTimerQueue>
    222e:	90 91 f7 2e 	lds	r25, 0x2EF7	; 0x802ef7 <xTimerQueue+0x1>
    2232:	0e 94 dd 07 	call	0xfba	; 0xfba <xQueueGenericSend>
    2236:	18 c0       	rjmp	.+48     	; 0x2268 <xTimerGenericCommand+0x92>
    2238:	00 e0       	ldi	r16, 0x00	; 0
    223a:	20 e0       	ldi	r18, 0x00	; 0
    223c:	30 e0       	ldi	r19, 0x00	; 0
    223e:	a9 01       	movw	r20, r18
    2240:	be 01       	movw	r22, r28
    2242:	6f 5f       	subi	r22, 0xFF	; 255
    2244:	7f 4f       	sbci	r23, 0xFF	; 255
    2246:	80 91 f6 2e 	lds	r24, 0x2EF6	; 0x802ef6 <xTimerQueue>
    224a:	90 91 f7 2e 	lds	r25, 0x2EF7	; 0x802ef7 <xTimerQueue+0x1>
    224e:	0e 94 dd 07 	call	0xfba	; 0xfba <xQueueGenericSend>
    2252:	0a c0       	rjmp	.+20     	; 0x2268 <xTimerGenericCommand+0x92>
    2254:	20 e0       	ldi	r18, 0x00	; 0
    2256:	a8 01       	movw	r20, r16
    2258:	be 01       	movw	r22, r28
    225a:	6f 5f       	subi	r22, 0xFF	; 255
    225c:	7f 4f       	sbci	r23, 0xFF	; 255
    225e:	cf 01       	movw	r24, r30
    2260:	0e 94 83 08 	call	0x1106	; 0x1106 <xQueueGenericSendFromISR>
    2264:	01 c0       	rjmp	.+2      	; 0x2268 <xTimerGenericCommand+0x92>
    2266:	80 e0       	ldi	r24, 0x00	; 0
    2268:	29 96       	adiw	r28, 0x09	; 9
    226a:	cd bf       	out	0x3d, r28	; 61
    226c:	de bf       	out	0x3e, r29	; 62
    226e:	df 91       	pop	r29
    2270:	cf 91       	pop	r28
    2272:	1f 91       	pop	r17
    2274:	0f 91       	pop	r16
    2276:	ff 90       	pop	r15
    2278:	ef 90       	pop	r14
    227a:	df 90       	pop	r13
    227c:	cf 90       	pop	r12
    227e:	bf 90       	pop	r11
    2280:	af 90       	pop	r10
    2282:	9f 90       	pop	r9
    2284:	8f 90       	pop	r8
    2286:	08 95       	ret

00002288 <prvSampleTimeNow>:
    2288:	2f 92       	push	r2
    228a:	3f 92       	push	r3
    228c:	4f 92       	push	r4
    228e:	5f 92       	push	r5
    2290:	6f 92       	push	r6
    2292:	7f 92       	push	r7
    2294:	8f 92       	push	r8
    2296:	9f 92       	push	r9
    2298:	af 92       	push	r10
    229a:	bf 92       	push	r11
    229c:	cf 92       	push	r12
    229e:	df 92       	push	r13
    22a0:	ef 92       	push	r14
    22a2:	ff 92       	push	r15
    22a4:	0f 93       	push	r16
    22a6:	1f 93       	push	r17
    22a8:	cf 93       	push	r28
    22aa:	df 93       	push	r29
    22ac:	1c 01       	movw	r2, r24
    22ae:	0e 94 9c 0b 	call	0x1738	; 0x1738 <xTaskGetTickCount>
    22b2:	2b 01       	movw	r4, r22
    22b4:	3c 01       	movw	r6, r24
    22b6:	80 91 f0 2e 	lds	r24, 0x2EF0	; 0x802ef0 <xLastTime.4745>
    22ba:	90 91 f1 2e 	lds	r25, 0x2EF1	; 0x802ef1 <xLastTime.4745+0x1>
    22be:	a0 91 f2 2e 	lds	r26, 0x2EF2	; 0x802ef2 <xLastTime.4745+0x2>
    22c2:	b0 91 f3 2e 	lds	r27, 0x2EF3	; 0x802ef3 <xLastTime.4745+0x3>
    22c6:	48 16       	cp	r4, r24
    22c8:	59 06       	cpc	r5, r25
    22ca:	6a 06       	cpc	r6, r26
    22cc:	7b 06       	cpc	r7, r27
    22ce:	08 f0       	brcs	.+2      	; 0x22d2 <prvSampleTimeNow+0x4a>
    22d0:	54 c0       	rjmp	.+168    	; 0x237a <prvSampleTimeNow+0xf2>
    22d2:	3c c0       	rjmp	.+120    	; 0x234c <prvSampleTimeNow+0xc4>
    22d4:	07 80       	ldd	r0, Z+7	; 0x07
    22d6:	f0 85       	ldd	r31, Z+8	; 0x08
    22d8:	e0 2d       	mov	r30, r0
    22da:	80 80       	ld	r8, Z
    22dc:	91 80       	ldd	r9, Z+1	; 0x01
    22de:	a2 80       	ldd	r10, Z+2	; 0x02
    22e0:	b3 80       	ldd	r11, Z+3	; 0x03
    22e2:	c0 85       	ldd	r28, Z+8	; 0x08
    22e4:	d1 85       	ldd	r29, Z+9	; 0x09
    22e6:	8e 01       	movw	r16, r28
    22e8:	0e 5f       	subi	r16, 0xFE	; 254
    22ea:	1f 4f       	sbci	r17, 0xFF	; 255
    22ec:	c8 01       	movw	r24, r16
    22ee:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
    22f2:	ed 89       	ldd	r30, Y+21	; 0x15
    22f4:	fe 89       	ldd	r31, Y+22	; 0x16
    22f6:	ce 01       	movw	r24, r28
    22f8:	19 95       	eicall
    22fa:	8a 89       	ldd	r24, Y+18	; 0x12
    22fc:	81 30       	cpi	r24, 0x01	; 1
    22fe:	31 f5       	brne	.+76     	; 0x234c <prvSampleTimeNow+0xc4>
    2300:	8e 85       	ldd	r24, Y+14	; 0x0e
    2302:	9f 85       	ldd	r25, Y+15	; 0x0f
    2304:	a8 89       	ldd	r26, Y+16	; 0x10
    2306:	b9 89       	ldd	r27, Y+17	; 0x11
    2308:	88 0d       	add	r24, r8
    230a:	99 1d       	adc	r25, r9
    230c:	aa 1d       	adc	r26, r10
    230e:	bb 1d       	adc	r27, r11
    2310:	88 16       	cp	r8, r24
    2312:	99 06       	cpc	r9, r25
    2314:	aa 06       	cpc	r10, r26
    2316:	bb 06       	cpc	r11, r27
    2318:	70 f4       	brcc	.+28     	; 0x2336 <prvSampleTimeNow+0xae>
    231a:	8a 83       	std	Y+2, r24	; 0x02
    231c:	9b 83       	std	Y+3, r25	; 0x03
    231e:	ac 83       	std	Y+4, r26	; 0x04
    2320:	bd 83       	std	Y+5, r27	; 0x05
    2322:	ca 87       	std	Y+10, r28	; 0x0a
    2324:	db 87       	std	Y+11, r29	; 0x0b
    2326:	b8 01       	movw	r22, r16
    2328:	80 91 fa 2e 	lds	r24, 0x2EFA	; 0x802efa <pxCurrentTimerList>
    232c:	90 91 fb 2e 	lds	r25, 0x2EFB	; 0x802efb <pxCurrentTimerList+0x1>
    2330:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListInsert>
    2334:	0b c0       	rjmp	.+22     	; 0x234c <prvSampleTimeNow+0xc4>
    2336:	c1 2c       	mov	r12, r1
    2338:	d1 2c       	mov	r13, r1
    233a:	76 01       	movw	r14, r12
    233c:	00 e0       	ldi	r16, 0x00	; 0
    233e:	10 e0       	ldi	r17, 0x00	; 0
    2340:	a5 01       	movw	r20, r10
    2342:	94 01       	movw	r18, r8
    2344:	60 e0       	ldi	r22, 0x00	; 0
    2346:	ce 01       	movw	r24, r28
    2348:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <xTimerGenericCommand>
    234c:	e0 91 fa 2e 	lds	r30, 0x2EFA	; 0x802efa <pxCurrentTimerList>
    2350:	f0 91 fb 2e 	lds	r31, 0x2EFB	; 0x802efb <pxCurrentTimerList+0x1>
    2354:	80 81       	ld	r24, Z
    2356:	81 11       	cpse	r24, r1
    2358:	bd cf       	rjmp	.-134    	; 0x22d4 <prvSampleTimeNow+0x4c>
    235a:	80 91 f8 2e 	lds	r24, 0x2EF8	; 0x802ef8 <pxOverflowTimerList>
    235e:	90 91 f9 2e 	lds	r25, 0x2EF9	; 0x802ef9 <pxOverflowTimerList+0x1>
    2362:	80 93 fa 2e 	sts	0x2EFA, r24	; 0x802efa <pxCurrentTimerList>
    2366:	90 93 fb 2e 	sts	0x2EFB, r25	; 0x802efb <pxCurrentTimerList+0x1>
    236a:	e0 93 f8 2e 	sts	0x2EF8, r30	; 0x802ef8 <pxOverflowTimerList>
    236e:	f0 93 f9 2e 	sts	0x2EF9, r31	; 0x802ef9 <pxOverflowTimerList+0x1>
    2372:	81 e0       	ldi	r24, 0x01	; 1
    2374:	f1 01       	movw	r30, r2
    2376:	80 83       	st	Z, r24
    2378:	02 c0       	rjmp	.+4      	; 0x237e <prvSampleTimeNow+0xf6>
    237a:	f1 01       	movw	r30, r2
    237c:	10 82       	st	Z, r1
    237e:	40 92 f0 2e 	sts	0x2EF0, r4	; 0x802ef0 <xLastTime.4745>
    2382:	50 92 f1 2e 	sts	0x2EF1, r5	; 0x802ef1 <xLastTime.4745+0x1>
    2386:	60 92 f2 2e 	sts	0x2EF2, r6	; 0x802ef2 <xLastTime.4745+0x2>
    238a:	70 92 f3 2e 	sts	0x2EF3, r7	; 0x802ef3 <xLastTime.4745+0x3>
    238e:	c3 01       	movw	r24, r6
    2390:	b2 01       	movw	r22, r4
    2392:	df 91       	pop	r29
    2394:	cf 91       	pop	r28
    2396:	1f 91       	pop	r17
    2398:	0f 91       	pop	r16
    239a:	ff 90       	pop	r15
    239c:	ef 90       	pop	r14
    239e:	df 90       	pop	r13
    23a0:	cf 90       	pop	r12
    23a2:	bf 90       	pop	r11
    23a4:	af 90       	pop	r10
    23a6:	9f 90       	pop	r9
    23a8:	8f 90       	pop	r8
    23aa:	7f 90       	pop	r7
    23ac:	6f 90       	pop	r6
    23ae:	5f 90       	pop	r5
    23b0:	4f 90       	pop	r4
    23b2:	3f 90       	pop	r3
    23b4:	2f 90       	pop	r2
    23b6:	08 95       	ret

000023b8 <prvTimerTask>:
    23b8:	cf 93       	push	r28
    23ba:	df 93       	push	r29
    23bc:	cd b7       	in	r28, 0x3d	; 61
    23be:	de b7       	in	r29, 0x3e	; 62
    23c0:	2e 97       	sbiw	r28, 0x0e	; 14
    23c2:	cd bf       	out	0x3d, r28	; 61
    23c4:	de bf       	out	0x3e, r29	; 62
    23c6:	ce 01       	movw	r24, r28
    23c8:	01 96       	adiw	r24, 0x01	; 1
    23ca:	1c 01       	movw	r2, r24
    23cc:	a8 2e       	mov	r10, r24
    23ce:	b3 2c       	mov	r11, r3
    23d0:	e0 91 fa 2e 	lds	r30, 0x2EFA	; 0x802efa <pxCurrentTimerList>
    23d4:	f0 91 fb 2e 	lds	r31, 0x2EFB	; 0x802efb <pxCurrentTimerList+0x1>
    23d8:	80 81       	ld	r24, Z
    23da:	88 23       	and	r24, r24
    23dc:	09 f4       	brne	.+2      	; 0x23e0 <prvTimerTask+0x28>
    23de:	03 c1       	rjmp	.+518    	; 0x25e6 <prvTimerTask+0x22e>
    23e0:	07 80       	ldd	r0, Z+7	; 0x07
    23e2:	f0 85       	ldd	r31, Z+8	; 0x08
    23e4:	e0 2d       	mov	r30, r0
    23e6:	40 80       	ld	r4, Z
    23e8:	51 80       	ldd	r5, Z+1	; 0x01
    23ea:	62 80       	ldd	r6, Z+2	; 0x02
    23ec:	73 80       	ldd	r7, Z+3	; 0x03
    23ee:	0e 94 96 0b 	call	0x172c	; 0x172c <vTaskSuspendAll>
    23f2:	c1 01       	movw	r24, r2
    23f4:	0e 94 44 11 	call	0x2288	; 0x2288 <prvSampleTimeNow>
    23f8:	6b 87       	std	Y+11, r22	; 0x0b
    23fa:	7c 87       	std	Y+12, r23	; 0x0c
    23fc:	8d 87       	std	Y+13, r24	; 0x0d
    23fe:	9e 87       	std	Y+14, r25	; 0x0e
    2400:	89 81       	ldd	r24, Y+1	; 0x01
    2402:	81 11       	cpse	r24, r1
    2404:	5e c0       	rjmp	.+188    	; 0x24c2 <prvTimerTask+0x10a>
    2406:	8b 85       	ldd	r24, Y+11	; 0x0b
    2408:	9c 85       	ldd	r25, Y+12	; 0x0c
    240a:	ad 85       	ldd	r26, Y+13	; 0x0d
    240c:	be 85       	ldd	r27, Y+14	; 0x0e
    240e:	84 15       	cp	r24, r4
    2410:	95 05       	cpc	r25, r5
    2412:	a6 05       	cpc	r26, r6
    2414:	b7 05       	cpc	r27, r7
    2416:	e8 f1       	brcs	.+122    	; 0x2492 <prvTimerTask+0xda>
    2418:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
    241c:	e0 91 fa 2e 	lds	r30, 0x2EFA	; 0x802efa <pxCurrentTimerList>
    2420:	f0 91 fb 2e 	lds	r31, 0x2EFB	; 0x802efb <pxCurrentTimerList+0x1>
    2424:	07 80       	ldd	r0, Z+7	; 0x07
    2426:	f0 85       	ldd	r31, Z+8	; 0x08
    2428:	e0 2d       	mov	r30, r0
    242a:	80 84       	ldd	r8, Z+8	; 0x08
    242c:	91 84       	ldd	r9, Z+9	; 0x09
    242e:	c4 01       	movw	r24, r8
    2430:	02 96       	adiw	r24, 0x02	; 2
    2432:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
    2436:	d4 01       	movw	r26, r8
    2438:	52 96       	adiw	r26, 0x12	; 18
    243a:	8c 91       	ld	r24, X
    243c:	52 97       	sbiw	r26, 0x12	; 18
    243e:	81 30       	cpi	r24, 0x01	; 1
    2440:	01 f5       	brne	.+64     	; 0x2482 <prvTimerTask+0xca>
    2442:	1e 96       	adiw	r26, 0x0e	; 14
    2444:	4d 91       	ld	r20, X+
    2446:	5d 91       	ld	r21, X+
    2448:	6d 91       	ld	r22, X+
    244a:	7c 91       	ld	r23, X
    244c:	51 97       	sbiw	r26, 0x11	; 17
    244e:	44 0d       	add	r20, r4
    2450:	55 1d       	adc	r21, r5
    2452:	66 1d       	adc	r22, r6
    2454:	77 1d       	adc	r23, r7
    2456:	73 01       	movw	r14, r6
    2458:	62 01       	movw	r12, r4
    245a:	0b 85       	ldd	r16, Y+11	; 0x0b
    245c:	1c 85       	ldd	r17, Y+12	; 0x0c
    245e:	2d 85       	ldd	r18, Y+13	; 0x0d
    2460:	3e 85       	ldd	r19, Y+14	; 0x0e
    2462:	c4 01       	movw	r24, r8
    2464:	0e 94 53 10 	call	0x20a6	; 0x20a6 <prvInsertTimerInActiveList>
    2468:	88 23       	and	r24, r24
    246a:	59 f0       	breq	.+22     	; 0x2482 <prvTimerTask+0xca>
    246c:	c1 2c       	mov	r12, r1
    246e:	d1 2c       	mov	r13, r1
    2470:	76 01       	movw	r14, r12
    2472:	00 e0       	ldi	r16, 0x00	; 0
    2474:	10 e0       	ldi	r17, 0x00	; 0
    2476:	a3 01       	movw	r20, r6
    2478:	92 01       	movw	r18, r4
    247a:	60 e0       	ldi	r22, 0x00	; 0
    247c:	c4 01       	movw	r24, r8
    247e:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <xTimerGenericCommand>
    2482:	d4 01       	movw	r26, r8
    2484:	55 96       	adiw	r26, 0x15	; 21
    2486:	ed 91       	ld	r30, X+
    2488:	fc 91       	ld	r31, X
    248a:	56 97       	sbiw	r26, 0x16	; 22
    248c:	c4 01       	movw	r24, r8
    248e:	19 95       	eicall
    2490:	9c c0       	rjmp	.+312    	; 0x25ca <prvTimerTask+0x212>
    2492:	20 e0       	ldi	r18, 0x00	; 0
    2494:	b3 01       	movw	r22, r6
    2496:	a2 01       	movw	r20, r4
    2498:	8b 85       	ldd	r24, Y+11	; 0x0b
    249a:	9c 85       	ldd	r25, Y+12	; 0x0c
    249c:	ad 85       	ldd	r26, Y+13	; 0x0d
    249e:	be 85       	ldd	r27, Y+14	; 0x0e
    24a0:	48 1b       	sub	r20, r24
    24a2:	59 0b       	sbc	r21, r25
    24a4:	6a 0b       	sbc	r22, r26
    24a6:	7b 0b       	sbc	r23, r27
    24a8:	80 91 f6 2e 	lds	r24, 0x2EF6	; 0x802ef6 <xTimerQueue>
    24ac:	90 91 f7 2e 	lds	r25, 0x2EF7	; 0x802ef7 <xTimerQueue+0x1>
    24b0:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <vQueueWaitForMessageRestricted>
    24b4:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
    24b8:	81 11       	cpse	r24, r1
    24ba:	87 c0       	rjmp	.+270    	; 0x25ca <prvTimerTask+0x212>
    24bc:	0e 94 a7 05 	call	0xb4e	; 0xb4e <vPortYield>
    24c0:	84 c0       	rjmp	.+264    	; 0x25ca <prvTimerTask+0x212>
    24c2:	0e 94 81 0c 	call	0x1902	; 0x1902 <xTaskResumeAll>
    24c6:	81 c0       	rjmp	.+258    	; 0x25ca <prvTimerTask+0x212>
    24c8:	89 81       	ldd	r24, Y+1	; 0x01
    24ca:	88 23       	and	r24, r24
    24cc:	6c f4       	brge	.+26     	; 0x24e8 <prvTimerTask+0x130>
    24ce:	4e 81       	ldd	r20, Y+6	; 0x06
    24d0:	5f 81       	ldd	r21, Y+7	; 0x07
    24d2:	68 85       	ldd	r22, Y+8	; 0x08
    24d4:	79 85       	ldd	r23, Y+9	; 0x09
    24d6:	ea 81       	ldd	r30, Y+2	; 0x02
    24d8:	fb 81       	ldd	r31, Y+3	; 0x03
    24da:	8c 81       	ldd	r24, Y+4	; 0x04
    24dc:	9d 81       	ldd	r25, Y+5	; 0x05
    24de:	19 95       	eicall
    24e0:	89 81       	ldd	r24, Y+1	; 0x01
    24e2:	88 23       	and	r24, r24
    24e4:	0c f4       	brge	.+2      	; 0x24e8 <prvTimerTask+0x130>
    24e6:	71 c0       	rjmp	.+226    	; 0x25ca <prvTimerTask+0x212>
    24e8:	8e 80       	ldd	r8, Y+6	; 0x06
    24ea:	9f 80       	ldd	r9, Y+7	; 0x07
    24ec:	d4 01       	movw	r26, r8
    24ee:	1c 96       	adiw	r26, 0x0c	; 12
    24f0:	8d 91       	ld	r24, X+
    24f2:	9c 91       	ld	r25, X
    24f4:	1d 97       	sbiw	r26, 0x0d	; 13
    24f6:	89 2b       	or	r24, r25
    24f8:	21 f0       	breq	.+8      	; 0x2502 <prvTimerTask+0x14a>
    24fa:	c4 01       	movw	r24, r8
    24fc:	02 96       	adiw	r24, 0x02	; 2
    24fe:	0e 94 bc 04 	call	0x978	; 0x978 <uxListRemove>
    2502:	ce 01       	movw	r24, r28
    2504:	0a 96       	adiw	r24, 0x0a	; 10
    2506:	0e 94 44 11 	call	0x2288	; 0x2288 <prvSampleTimeNow>
    250a:	8b 01       	movw	r16, r22
    250c:	9c 01       	movw	r18, r24
    250e:	89 81       	ldd	r24, Y+1	; 0x01
    2510:	08 2e       	mov	r0, r24
    2512:	00 0c       	add	r0, r0
    2514:	99 0b       	sbc	r25, r25
    2516:	aa 0b       	sbc	r26, r26
    2518:	bb 0b       	sbc	r27, r27
    251a:	8a 30       	cpi	r24, 0x0A	; 10
    251c:	91 05       	cpc	r25, r1
    251e:	08 f0       	brcs	.+2      	; 0x2522 <prvTimerTask+0x16a>
    2520:	54 c0       	rjmp	.+168    	; 0x25ca <prvTimerTask+0x212>
    2522:	fc 01       	movw	r30, r24
    2524:	88 27       	eor	r24, r24
    2526:	e2 50       	subi	r30, 0x02	; 2
    2528:	ff 4f       	sbci	r31, 0xFF	; 255
    252a:	8f 4f       	sbci	r24, 0xFF	; 255
    252c:	0c 94 b2 21 	jmp	0x4364	; 0x4364 <__tablejump2__>
    2530:	ca 80       	ldd	r12, Y+2	; 0x02
    2532:	db 80       	ldd	r13, Y+3	; 0x03
    2534:	ec 80       	ldd	r14, Y+4	; 0x04
    2536:	fd 80       	ldd	r15, Y+5	; 0x05
    2538:	f4 01       	movw	r30, r8
    253a:	46 85       	ldd	r20, Z+14	; 0x0e
    253c:	57 85       	ldd	r21, Z+15	; 0x0f
    253e:	60 89       	ldd	r22, Z+16	; 0x10
    2540:	71 89       	ldd	r23, Z+17	; 0x11
    2542:	4c 0d       	add	r20, r12
    2544:	5d 1d       	adc	r21, r13
    2546:	6e 1d       	adc	r22, r14
    2548:	7f 1d       	adc	r23, r15
    254a:	c4 01       	movw	r24, r8
    254c:	0e 94 53 10 	call	0x20a6	; 0x20a6 <prvInsertTimerInActiveList>
    2550:	88 23       	and	r24, r24
    2552:	d9 f1       	breq	.+118    	; 0x25ca <prvTimerTask+0x212>
    2554:	d4 01       	movw	r26, r8
    2556:	55 96       	adiw	r26, 0x15	; 21
    2558:	ed 91       	ld	r30, X+
    255a:	fc 91       	ld	r31, X
    255c:	56 97       	sbiw	r26, 0x16	; 22
    255e:	c4 01       	movw	r24, r8
    2560:	19 95       	eicall
    2562:	f4 01       	movw	r30, r8
    2564:	82 89       	ldd	r24, Z+18	; 0x12
    2566:	81 30       	cpi	r24, 0x01	; 1
    2568:	81 f5       	brne	.+96     	; 0x25ca <prvTimerTask+0x212>
    256a:	4a 81       	ldd	r20, Y+2	; 0x02
    256c:	5b 81       	ldd	r21, Y+3	; 0x03
    256e:	6c 81       	ldd	r22, Y+4	; 0x04
    2570:	7d 81       	ldd	r23, Y+5	; 0x05
    2572:	86 85       	ldd	r24, Z+14	; 0x0e
    2574:	97 85       	ldd	r25, Z+15	; 0x0f
    2576:	a0 89       	ldd	r26, Z+16	; 0x10
    2578:	b1 89       	ldd	r27, Z+17	; 0x11
    257a:	9a 01       	movw	r18, r20
    257c:	ab 01       	movw	r20, r22
    257e:	28 0f       	add	r18, r24
    2580:	39 1f       	adc	r19, r25
    2582:	4a 1f       	adc	r20, r26
    2584:	5b 1f       	adc	r21, r27
    2586:	c1 2c       	mov	r12, r1
    2588:	d1 2c       	mov	r13, r1
    258a:	76 01       	movw	r14, r12
    258c:	00 e0       	ldi	r16, 0x00	; 0
    258e:	10 e0       	ldi	r17, 0x00	; 0
    2590:	60 e0       	ldi	r22, 0x00	; 0
    2592:	c4 01       	movw	r24, r8
    2594:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <xTimerGenericCommand>
    2598:	18 c0       	rjmp	.+48     	; 0x25ca <prvTimerTask+0x212>
    259a:	4a 81       	ldd	r20, Y+2	; 0x02
    259c:	5b 81       	ldd	r21, Y+3	; 0x03
    259e:	6c 81       	ldd	r22, Y+4	; 0x04
    25a0:	7d 81       	ldd	r23, Y+5	; 0x05
    25a2:	d4 01       	movw	r26, r8
    25a4:	1e 96       	adiw	r26, 0x0e	; 14
    25a6:	4d 93       	st	X+, r20
    25a8:	5d 93       	st	X+, r21
    25aa:	6d 93       	st	X+, r22
    25ac:	7c 93       	st	X, r23
    25ae:	51 97       	sbiw	r26, 0x11	; 17
    25b0:	40 0f       	add	r20, r16
    25b2:	51 1f       	adc	r21, r17
    25b4:	62 1f       	adc	r22, r18
    25b6:	73 1f       	adc	r23, r19
    25b8:	68 01       	movw	r12, r16
    25ba:	79 01       	movw	r14, r18
    25bc:	c4 01       	movw	r24, r8
    25be:	0e 94 53 10 	call	0x20a6	; 0x20a6 <prvInsertTimerInActiveList>
    25c2:	03 c0       	rjmp	.+6      	; 0x25ca <prvTimerTask+0x212>
    25c4:	c4 01       	movw	r24, r8
    25c6:	0e 94 48 04 	call	0x890	; 0x890 <vPortFree>
    25ca:	20 e0       	ldi	r18, 0x00	; 0
    25cc:	30 e0       	ldi	r19, 0x00	; 0
    25ce:	a9 01       	movw	r20, r18
    25d0:	6a 2d       	mov	r22, r10
    25d2:	7b 2d       	mov	r23, r11
    25d4:	80 91 f6 2e 	lds	r24, 0x2EF6	; 0x802ef6 <xTimerQueue>
    25d8:	90 91 f7 2e 	lds	r25, 0x2EF7	; 0x802ef7 <xTimerQueue+0x1>
    25dc:	0e 94 c8 08 	call	0x1190	; 0x1190 <xQueueReceive>
    25e0:	81 11       	cpse	r24, r1
    25e2:	72 cf       	rjmp	.-284    	; 0x24c8 <prvTimerTask+0x110>
    25e4:	f5 ce       	rjmp	.-534    	; 0x23d0 <prvTimerTask+0x18>
    25e6:	0e 94 96 0b 	call	0x172c	; 0x172c <vTaskSuspendAll>
    25ea:	c1 01       	movw	r24, r2
    25ec:	0e 94 44 11 	call	0x2288	; 0x2288 <prvSampleTimeNow>
    25f0:	6b 87       	std	Y+11, r22	; 0x0b
    25f2:	7c 87       	std	Y+12, r23	; 0x0c
    25f4:	8d 87       	std	Y+13, r24	; 0x0d
    25f6:	9e 87       	std	Y+14, r25	; 0x0e
    25f8:	89 81       	ldd	r24, Y+1	; 0x01
    25fa:	81 11       	cpse	r24, r1
    25fc:	62 cf       	rjmp	.-316    	; 0x24c2 <prvTimerTask+0x10a>
    25fe:	e0 91 f8 2e 	lds	r30, 0x2EF8	; 0x802ef8 <pxOverflowTimerList>
    2602:	f0 91 f9 2e 	lds	r31, 0x2EF9	; 0x802ef9 <pxOverflowTimerList+0x1>
    2606:	80 81       	ld	r24, Z
    2608:	21 e0       	ldi	r18, 0x01	; 1
    260a:	81 11       	cpse	r24, r1
    260c:	20 e0       	ldi	r18, 0x00	; 0
    260e:	41 2c       	mov	r4, r1
    2610:	51 2c       	mov	r5, r1
    2612:	32 01       	movw	r6, r4
    2614:	3f cf       	rjmp	.-386    	; 0x2494 <prvTimerTask+0xdc>

00002616 <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2616:	0f 93       	push	r16
    2618:	1f 93       	push	r17
    261a:	cf 93       	push	r28
    261c:	df 93       	push	r29
    261e:	cd b7       	in	r28, 0x3d	; 61
    2620:	de b7       	in	r29, 0x3e	; 62
    2622:	29 97       	sbiw	r28, 0x09	; 9
    2624:	cd bf       	out	0x3d, r28	; 61
    2626:	de bf       	out	0x3e, r29	; 62
	DaemonTaskMessage_t xMessage;
	BaseType_t xReturn;

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
    2628:	ee ef       	ldi	r30, 0xFE	; 254
    262a:	e9 83       	std	Y+1, r30	; 0x01
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    262c:	8a 83       	std	Y+2, r24	; 0x02
    262e:	9b 83       	std	Y+3, r25	; 0x03
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    2630:	6c 83       	std	Y+4, r22	; 0x04
    2632:	7d 83       	std	Y+5, r23	; 0x05
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    2634:	2e 83       	std	Y+6, r18	; 0x06
    2636:	3f 83       	std	Y+7, r19	; 0x07
    2638:	48 87       	std	Y+8, r20	; 0x08
    263a:	59 87       	std	Y+9, r21	; 0x09

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    263c:	20 e0       	ldi	r18, 0x00	; 0
    263e:	a8 01       	movw	r20, r16
    2640:	be 01       	movw	r22, r28
    2642:	6f 5f       	subi	r22, 0xFF	; 255
    2644:	7f 4f       	sbci	r23, 0xFF	; 255
    2646:	80 91 f6 2e 	lds	r24, 0x2EF6	; 0x802ef6 <xTimerQueue>
    264a:	90 91 f7 2e 	lds	r25, 0x2EF7	; 0x802ef7 <xTimerQueue+0x1>
    264e:	0e 94 83 08 	call	0x1106	; 0x1106 <xQueueGenericSendFromISR>

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
	}
    2652:	29 96       	adiw	r28, 0x09	; 9
    2654:	cd bf       	out	0x3d, r28	; 61
    2656:	de bf       	out	0x3e, r29	; 62
    2658:	df 91       	pop	r29
    265a:	cf 91       	pop	r28
    265c:	1f 91       	pop	r17
    265e:	0f 91       	pop	r16
    2660:	08 95       	ret

00002662 <vInitClock>:
#include "clksys_driver.h"


void vInitClock(void)
{
	CLKSYS_Enable( OSC_RC2MEN_bm );
    2662:	e0 e5       	ldi	r30, 0x50	; 80
    2664:	f0 e0       	ldi	r31, 0x00	; 0
    2666:	80 81       	ld	r24, Z
    2668:	81 60       	ori	r24, 0x01	; 1
    266a:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC2MRDY_bm ) == 0 );
    266c:	81 81       	ldd	r24, Z+1	; 0x01
    266e:	80 ff       	sbrs	r24, 0
    2670:	fd cf       	rjmp	.-6      	; 0x266c <vInitClock+0xa>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC2M_gc );
    2672:	80 e0       	ldi	r24, 0x00	; 0
    2674:	0e 94 45 02 	call	0x48a	; 0x48a <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC32KEN_bm | OSC_XOSCEN_bm | OSC_PLLEN_bm);
    2678:	8e e1       	ldi	r24, 0x1E	; 30
    267a:	0e 94 35 02 	call	0x46a	; 0x46a <CLKSYS_Disable>
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    267e:	60 e0       	ldi	r22, 0x00	; 0
    2680:	80 e0       	ldi	r24, 0x00	; 0
    2682:	0e 94 3f 02 	call	0x47e	; 0x47e <CLKSYS_Prescalers_Config>
	CLKSYS_XOSC_Config( OSC_FRQRANGE_2TO9_gc,false,OSC_XOSCSEL_XTAL_256CLK_gc );
    2686:	43 e0       	ldi	r20, 0x03	; 3
    2688:	60 e0       	ldi	r22, 0x00	; 0
    268a:	80 e4       	ldi	r24, 0x40	; 64
    268c:	0e 94 26 02 	call	0x44c	; 0x44c <CLKSYS_XOSC_Config>
	CLKSYS_Enable( OSC_XOSCEN_bm );
    2690:	e0 e5       	ldi	r30, 0x50	; 80
    2692:	f0 e0       	ldi	r31, 0x00	; 0
    2694:	80 81       	ld	r24, Z
    2696:	88 60       	ori	r24, 0x08	; 8
    2698:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    269a:	81 81       	ldd	r24, Z+1	; 0x01
    269c:	83 ff       	sbrs	r24, 3
    269e:	fd cf       	rjmp	.-6      	; 0x269a <vInitClock+0x38>
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 4 );
    26a0:	64 e0       	ldi	r22, 0x04	; 4
    26a2:	80 ec       	ldi	r24, 0xC0	; 192
    26a4:	0e 94 30 02 	call	0x460	; 0x460 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    26a8:	e0 e5       	ldi	r30, 0x50	; 80
    26aa:	f0 e0       	ldi	r31, 0x00	; 0
    26ac:	80 81       	ld	r24, Z
    26ae:	80 61       	ori	r24, 0x10	; 16
    26b0:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    26b2:	60 e0       	ldi	r22, 0x00	; 0
    26b4:	80 e0       	ldi	r24, 0x00	; 0
    26b6:	0e 94 3f 02 	call	0x47e	; 0x47e <CLKSYS_Prescalers_Config>
	do {} while ( CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    26ba:	e0 e5       	ldi	r30, 0x50	; 80
    26bc:	f0 e0       	ldi	r31, 0x00	; 0
    26be:	81 81       	ldd	r24, Z+1	; 0x01
    26c0:	84 ff       	sbrs	r24, 4
    26c2:	fd cf       	rjmp	.-6      	; 0x26be <vInitClock+0x5c>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    26c4:	84 e0       	ldi	r24, 0x04	; 4
    26c6:	0e 94 45 02 	call	0x48a	; 0x48a <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC2MEN_bm | OSC_RC32KEN_bm);
    26ca:	87 e0       	ldi	r24, 0x07	; 7
    26cc:	0e 94 35 02 	call	0x46a	; 0x46a <CLKSYS_Disable>
    26d0:	08 95       	ret

000026d2 <vSteuertask>:
	vTaskStartScheduler();
	return 0;
}

void vSteuertask(void *pvParameters)
{
    26d2:	cf 93       	push	r28
    26d4:	df 93       	push	r29
    26d6:	cd b7       	in	r28, 0x3d	; 61
    26d8:	de b7       	in	r29, 0x3e	; 62
    26da:	a5 97       	sbiw	r28, 0x25	; 37
    26dc:	cd bf       	out	0x3d, r28	; 61
    26de:	de bf       	out	0x3e, r29	; 62
(void) pvParameters;
uint32_t Buttonvalue;
uint8_t DataString[33];
	
eSteuerungStates Steuerung = smalldata;
    26e0:	bb 24       	eor	r11, r11
    26e2:	b3 94       	inc	r11
			}
		
			case middledata:
			{
                DataString[0] = 0x2F;
                DataString[1] = 0x01;
    26e4:	aa 24       	eor	r10, r10
    26e6:	a3 94       	inc	r10
                DataString[12] = 0x68;
                DataString[13] = 0x69;
                DataString[14] = 0x65;
                DataString[15] = 0x72;
                Steuerung = writedata;
                vDisplayWriteStringAtPos(1, 0, "Data:      middle   ");
    26e8:	0f 2e       	mov	r0, r31
    26ea:	f3 e2       	ldi	r31, 0x23	; 35
    26ec:	6f 2e       	mov	r6, r31
    26ee:	f0 e2       	ldi	r31, 0x20	; 32
    26f0:	7f 2e       	mov	r7, r31
    26f2:	f0 2d       	mov	r31, r0
            {
                /* Command 3 is the command to transmit a string. */
                DataString[0] = 0x71;   // 0b011 1'0001 -> Command = 3, Databytes = 17
                sprintf((char*)&DataString[1], "Test erfolgreich!");
                Steuerung = writedata;
                vDisplayWriteStringAtPos(1, 0, "Data:      string   ");
    26f4:	0f 2e       	mov	r0, r31
    26f6:	ff e5       	ldi	r31, 0x5F	; 95
    26f8:	8f 2e       	mov	r8, r31
    26fa:	f0 e2       	ldi	r31, 0x20	; 32
    26fc:	9f 2e       	mov	r9, r31
    26fe:	f0 2d       	mov	r31, r0
            }
            
			case writedata:
			{
    			vDisplayWriteStringAtPos(2, 0, "Command:   %d ", DataString[0] >> 5);
    			vDisplayWriteStringAtPos(3, 0, "DataBytes: %d ", DataString[0] & 0x1F);
    2700:	0f 2e       	mov	r0, r31
    2702:	f3 e8       	ldi	r31, 0x83	; 131
    2704:	4f 2e       	mov	r4, r31
    2706:	f0 e2       	ldi	r31, 0x20	; 32
    2708:	5f 2e       	mov	r5, r31
    270a:	f0 2d       	mov	r31, r0
				DataString[0] = 0x83;   // Command + Amount of Data 0bXXXY'YYYY
				DataString[1] = 0xAB;
				DataString[2] = 0x37;
				DataString[3] = 0x85;
				Steuerung = writedata;
				vDisplayWriteStringAtPos(1, 0, "Data:      small    ");
    270c:	0f 2e       	mov	r0, r31
    270e:	fe e0       	ldi	r31, 0x0E	; 14
    2710:	2f 2e       	mov	r2, r31
    2712:	f0 e2       	ldi	r31, 0x20	; 32
    2714:	3f 2e       	mov	r3, r31
    2716:	f0 2d       	mov	r31, r0
eSteuerungStates Steuerung = smalldata;
    
    while(1)
    {
        
        xTaskNotifyWait(0, 0xffffffff, &Buttonvalue, pdMS_TO_TICKS(200));
    2718:	0f 2e       	mov	r0, r31
    271a:	f8 ec       	ldi	r31, 0xC8	; 200
    271c:	cf 2e       	mov	r12, r31
    271e:	d1 2c       	mov	r13, r1
    2720:	e1 2c       	mov	r14, r1
    2722:	f1 2c       	mov	r15, r1
    2724:	f0 2d       	mov	r31, r0
    2726:	8e 01       	movw	r16, r28
    2728:	0f 5f       	subi	r16, 0xFF	; 255
    272a:	1f 4f       	sbci	r17, 0xFF	; 255
    272c:	2f ef       	ldi	r18, 0xFF	; 255
    272e:	3f ef       	ldi	r19, 0xFF	; 255
    2730:	a9 01       	movw	r20, r18
    2732:	60 e0       	ldi	r22, 0x00	; 0
    2734:	70 e0       	ldi	r23, 0x00	; 0
    2736:	cb 01       	movw	r24, r22
    2738:	0e 94 2a 0f 	call	0x1e54	; 0x1e54 <xTaskNotifyWait>
        
		switch(Steuerung)
    273c:	22 e0       	ldi	r18, 0x02	; 2
    273e:	b2 16       	cp	r11, r18
    2740:	09 f4       	brne	.+2      	; 0x2744 <vSteuertask+0x72>
    2742:	45 c0       	rjmp	.+138    	; 0x27ce <vSteuertask+0xfc>
    2744:	2b 15       	cp	r18, r11
    2746:	30 f0       	brcs	.+12     	; 0x2754 <vSteuertask+0x82>
    2748:	bb 20       	and	r11, r11
    274a:	81 f0       	breq	.+32     	; 0x276c <vSteuertask+0x9a>
    274c:	81 e0       	ldi	r24, 0x01	; 1
    274e:	b8 16       	cp	r11, r24
    2750:	19 f1       	breq	.+70     	; 0x2798 <vSteuertask+0xc6>
    2752:	e2 cf       	rjmp	.-60     	; 0x2718 <vSteuertask+0x46>
    2754:	94 e0       	ldi	r25, 0x04	; 4
    2756:	b9 16       	cp	r11, r25
    2758:	09 f4       	brne	.+2      	; 0x275c <vSteuertask+0x8a>
    275a:	b2 c0       	rjmp	.+356    	; 0x28c0 <vSteuertask+0x1ee>
    275c:	b9 16       	cp	r11, r25
    275e:	08 f4       	brcc	.+2      	; 0x2762 <vSteuertask+0x90>
    2760:	67 c0       	rjmp	.+206    	; 0x2830 <vSteuertask+0x15e>
    2762:	25 e0       	ldi	r18, 0x05	; 5
    2764:	b2 16       	cp	r11, r18
    2766:	09 f4       	brne	.+2      	; 0x276a <vSteuertask+0x98>
    2768:	c9 c0       	rjmp	.+402    	; 0x28fc <vSteuertask+0x22a>
    276a:	d6 cf       	rjmp	.-84     	; 0x2718 <vSteuertask+0x46>
		{
			
		    case idle:
            {
                
                if (Buttonvalue&BUTTON1SHORTPRESSEDMASK)
    276c:	89 81       	ldd	r24, Y+1	; 0x01
                {
                    Steuerung=smalldata;
                }
                
                if (Buttonvalue&BUTTON2SHORTPRESSEDMASK)
    276e:	81 fd       	sbrc	r24, 1
    2770:	04 c0       	rjmp	.+8      	; 0x277a <vSteuertask+0xa8>
		    case idle:
            {
                
                if (Buttonvalue&BUTTON1SHORTPRESSEDMASK)
                {
                    Steuerung=smalldata;
    2772:	98 2f       	mov	r25, r24
    2774:	91 70       	andi	r25, 0x01	; 1
    2776:	b9 2e       	mov	r11, r25
    2778:	03 c0       	rjmp	.+6      	; 0x2780 <vSteuertask+0xae>
                }
                
                if (Buttonvalue&BUTTON2SHORTPRESSEDMASK)
                {
                    Steuerung=middledata;
    277a:	68 94       	set
    277c:	bb 24       	eor	r11, r11
    277e:	b1 f8       	bld	r11, 1
                }
                
                if (Buttonvalue&BUTTON3SHORTPRESSEDMASK)
    2780:	82 ff       	sbrs	r24, 2
    2782:	04 c0       	rjmp	.+8      	; 0x278c <vSteuertask+0xba>
                {
                    Steuerung=bigdata;
    2784:	0f 2e       	mov	r0, r31
    2786:	f3 e0       	ldi	r31, 0x03	; 3
    2788:	bf 2e       	mov	r11, r31
    278a:	f0 2d       	mov	r31, r0
                }
                
                if (Buttonvalue&BUTTON4SHORTPRESSEDMASK)
    278c:	83 ff       	sbrs	r24, 3
    278e:	c4 cf       	rjmp	.-120    	; 0x2718 <vSteuertask+0x46>
                {
                    Steuerung=stringdata;
    2790:	68 94       	set
    2792:	bb 24       	eor	r11, r11
    2794:	b2 f8       	bld	r11, 2
    2796:	c0 cf       	rjmp	.-128    	; 0x2718 <vSteuertask+0x46>
            }            
		
			case smalldata:
			{
			
				DataString[0] = 0x83;   // Command + Amount of Data 0bXXXY'YYYY
    2798:	83 e8       	ldi	r24, 0x83	; 131
    279a:	8d 83       	std	Y+5, r24	; 0x05
				DataString[1] = 0xAB;
    279c:	8b ea       	ldi	r24, 0xAB	; 171
    279e:	8e 83       	std	Y+6, r24	; 0x06
				DataString[2] = 0x37;
    27a0:	87 e3       	ldi	r24, 0x37	; 55
    27a2:	8f 83       	std	Y+7, r24	; 0x07
				DataString[3] = 0x85;
    27a4:	85 e8       	ldi	r24, 0x85	; 133
    27a6:	88 87       	std	Y+8, r24	; 0x08
				Steuerung = writedata;
				vDisplayWriteStringAtPos(1, 0, "Data:      small    ");
    27a8:	3f 92       	push	r3
    27aa:	2f 92       	push	r2
    27ac:	1f 92       	push	r1
    27ae:	1f 92       	push	r1
    27b0:	1f 92       	push	r1
    27b2:	af 92       	push	r10
    27b4:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <vDisplayWriteStringAtPos>
                
			    break;	
    27b8:	0f 90       	pop	r0
    27ba:	0f 90       	pop	r0
    27bc:	0f 90       	pop	r0
    27be:	0f 90       	pop	r0
    27c0:	0f 90       	pop	r0
    27c2:	0f 90       	pop	r0
			
				DataString[0] = 0x83;   // Command + Amount of Data 0bXXXY'YYYY
				DataString[1] = 0xAB;
				DataString[2] = 0x37;
				DataString[3] = 0x85;
				Steuerung = writedata;
    27c4:	0f 2e       	mov	r0, r31
    27c6:	f5 e0       	ldi	r31, 0x05	; 5
    27c8:	bf 2e       	mov	r11, r31
    27ca:	f0 2d       	mov	r31, r0
				vDisplayWriteStringAtPos(1, 0, "Data:      small    ");
                
			    break;	
    27cc:	a5 cf       	rjmp	.-182    	; 0x2718 <vSteuertask+0x46>
			}
		
			case middledata:
			{
                DataString[0] = 0x2F;
    27ce:	2f e2       	ldi	r18, 0x2F	; 47
    27d0:	2d 83       	std	Y+5, r18	; 0x05
                DataString[1] = 0x01;
    27d2:	ae 82       	std	Y+6, r10	; 0x06
                DataString[2] = 0x23;
    27d4:	83 e2       	ldi	r24, 0x23	; 35
    27d6:	8f 83       	std	Y+7, r24	; 0x07
                DataString[3] = 0x45;
    27d8:	95 e4       	ldi	r25, 0x45	; 69
    27da:	98 87       	std	Y+8, r25	; 0x08
                DataString[4] = 0x67;
    27dc:	87 e6       	ldi	r24, 0x67	; 103
    27de:	89 87       	std	Y+9, r24	; 0x09
                DataString[5] = 0x89;
    27e0:	89 e8       	ldi	r24, 0x89	; 137
    27e2:	8a 87       	std	Y+10, r24	; 0x0a
                DataString[6] = 0xAB;
    27e4:	8b ea       	ldi	r24, 0xAB	; 171
    27e6:	8b 87       	std	Y+11, r24	; 0x0b
                DataString[7] = 0xCD;
    27e8:	8d ec       	ldi	r24, 0xCD	; 205
    27ea:	8c 87       	std	Y+12, r24	; 0x0c
                DataString[8] = 0xEF;
    27ec:	8f ee       	ldi	r24, 0xEF	; 239
    27ee:	8d 87       	std	Y+13, r24	; 0x0d
                DataString[9] = 0x63;
    27f0:	83 e6       	ldi	r24, 0x63	; 99
    27f2:	8e 87       	std	Y+14, r24	; 0x0e
                DataString[10] = 0x68;
    27f4:	88 e6       	ldi	r24, 0x68	; 104
    27f6:	8f 87       	std	Y+15, r24	; 0x0f
                DataString[11] = 0x2D;
    27f8:	9d e2       	ldi	r25, 0x2D	; 45
    27fa:	98 8b       	std	Y+16, r25	; 0x10
                DataString[12] = 0x68;
    27fc:	89 8b       	std	Y+17, r24	; 0x11
                DataString[13] = 0x69;
    27fe:	89 e6       	ldi	r24, 0x69	; 105
    2800:	8a 8b       	std	Y+18, r24	; 0x12
                DataString[14] = 0x65;
    2802:	85 e6       	ldi	r24, 0x65	; 101
    2804:	8b 8b       	std	Y+19, r24	; 0x13
                DataString[15] = 0x72;
    2806:	82 e7       	ldi	r24, 0x72	; 114
    2808:	8c 8b       	std	Y+20, r24	; 0x14
                Steuerung = writedata;
                vDisplayWriteStringAtPos(1, 0, "Data:      middle   ");
    280a:	7f 92       	push	r7
    280c:	6f 92       	push	r6
    280e:	1f 92       	push	r1
    2810:	1f 92       	push	r1
    2812:	1f 92       	push	r1
    2814:	af 92       	push	r10
    2816:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <vDisplayWriteStringAtPos>
                
				break;
    281a:	0f 90       	pop	r0
    281c:	0f 90       	pop	r0
    281e:	0f 90       	pop	r0
    2820:	0f 90       	pop	r0
    2822:	0f 90       	pop	r0
    2824:	0f 90       	pop	r0
                DataString[11] = 0x2D;
                DataString[12] = 0x68;
                DataString[13] = 0x69;
                DataString[14] = 0x65;
                DataString[15] = 0x72;
                Steuerung = writedata;
    2826:	0f 2e       	mov	r0, r31
    2828:	f5 e0       	ldi	r31, 0x05	; 5
    282a:	bf 2e       	mov	r11, r31
    282c:	f0 2d       	mov	r31, r0
                vDisplayWriteStringAtPos(1, 0, "Data:      middle   ");
                
				break;
    282e:	74 cf       	rjmp	.-280    	; 0x2718 <vSteuertask+0x46>
			}
		
			case bigdata:
			{
    			DataString[0] = 0x5F;
    2830:	8f e5       	ldi	r24, 0x5F	; 95
    2832:	8d 83       	std	Y+5, r24	; 0x05
    			DataString[1] = 0x4D;
    2834:	5d e4       	ldi	r21, 0x4D	; 77
    2836:	5e 83       	std	Y+6, r21	; 0x06
    			DataString[2] = 0x65;
    2838:	25 e6       	ldi	r18, 0x65	; 101
    283a:	2f 83       	std	Y+7, r18	; 0x07
    			DataString[3] = 0x69;
    283c:	99 e6       	ldi	r25, 0x69	; 105
    283e:	98 87       	std	Y+8, r25	; 0x08
    			DataString[4] = 0x6E;
    2840:	3e e6       	ldi	r19, 0x6E	; 110
    2842:	39 87       	std	Y+9, r19	; 0x09
    			DataString[5] = 0x2D;
    2844:	8d e2       	ldi	r24, 0x2D	; 45
    2846:	8a 87       	std	Y+10, r24	; 0x0a
    			DataString[6] = 0x4E;
    2848:	4e e4       	ldi	r20, 0x4E	; 78
    284a:	4b 87       	std	Y+11, r20	; 0x0b
    			DataString[7] = 0x61;
    284c:	41 e6       	ldi	r20, 0x61	; 97
    284e:	4c 87       	std	Y+12, r20	; 0x0c
    			DataString[8] = 0x6D;
    2850:	4d e6       	ldi	r20, 0x6D	; 109
    2852:	4d 87       	std	Y+13, r20	; 0x0d
    			DataString[9] = 0x65;
    2854:	2e 87       	std	Y+14, r18	; 0x0e
    			DataString[10] = 0x2D;
    2856:	8f 87       	std	Y+15, r24	; 0x0f
    			DataString[11] = 0x69;
    2858:	98 8b       	std	Y+16, r25	; 0x10
    			DataString[12] = 0x73;
    285a:	43 e7       	ldi	r20, 0x73	; 115
    285c:	49 8b       	std	Y+17, r20	; 0x11
    			DataString[13] = 0x74;
    285e:	64 e7       	ldi	r22, 0x74	; 116
    2860:	6a 8b       	std	Y+18, r22	; 0x12
    			DataString[14] = 0x2D;
    2862:	8b 8b       	std	Y+19, r24	; 0x13
    			DataString[15] = 0x51;
    2864:	61 e5       	ldi	r22, 0x51	; 81
    2866:	6c 8b       	std	Y+20, r22	; 0x14
    			DataString[16] = 0x41;
    2868:	61 e4       	ldi	r22, 0x41	; 65
    286a:	6d 8b       	std	Y+21, r22	; 0x15
    			DataString[17] = 0x4D;
    286c:	5e 8b       	std	Y+22, r21	; 0x16
    			DataString[18] = 0x2D;
    286e:	8f 8b       	std	Y+23, r24	; 0x17
    			DataString[19] = 0x56;
    2870:	56 e5       	ldi	r21, 0x56	; 86
    2872:	58 8f       	std	Y+24, r21	; 0x18
    			DataString[20] = 0x65;
    2874:	29 8f       	std	Y+25, r18	; 0x19
    			DataString[21] = 0x72;
    2876:	22 e7       	ldi	r18, 0x72	; 114
    2878:	2a 8f       	std	Y+26, r18	; 0x1a
    			DataString[22] = 0x73;
    287a:	4b 8f       	std	Y+27, r20	; 0x1b
    			DataString[23] = 0x69;
    287c:	9c 8f       	std	Y+28, r25	; 0x1c
    			DataString[24] = 0x6F;
    287e:	9f e6       	ldi	r25, 0x6F	; 111
    2880:	9d 8f       	std	Y+29, r25	; 0x1d
    			DataString[25] = 0x6E;
    2882:	3e 8f       	std	Y+30, r19	; 0x1e
    			DataString[26] = 0x31;
    2884:	91 e3       	ldi	r25, 0x31	; 49
    2886:	9f 8f       	std	Y+31, r25	; 0x1f
    			DataString[27] = 0x2E;
    2888:	2e e2       	ldi	r18, 0x2E	; 46
    288a:	28 a3       	std	Y+32, r18	; 0x20
    			DataString[28] = 0x30;
    288c:	90 e3       	ldi	r25, 0x30	; 48
    288e:	99 a3       	std	Y+33, r25	; 0x21
    			DataString[29] = 0x2E;
    2890:	2a a3       	std	Y+34, r18	; 0x22
    			DataString[30] = 0x30;
    2892:	9b a3       	std	Y+35, r25	; 0x23
    			DataString[31] = 0x2D;
    2894:	8c a3       	std	Y+36, r24	; 0x24
    			Steuerung = writedata;
    			vDisplayWriteStringAtPos(1, 0, "Data:      big      ");
    2896:	88 e3       	ldi	r24, 0x38	; 56
    2898:	90 e2       	ldi	r25, 0x20	; 32
    289a:	9f 93       	push	r25
    289c:	8f 93       	push	r24
    289e:	1f 92       	push	r1
    28a0:	1f 92       	push	r1
    28a2:	1f 92       	push	r1
    28a4:	af 92       	push	r10
    28a6:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <vDisplayWriteStringAtPos>
                
				break;
    28aa:	0f 90       	pop	r0
    28ac:	0f 90       	pop	r0
    28ae:	0f 90       	pop	r0
    28b0:	0f 90       	pop	r0
    28b2:	0f 90       	pop	r0
    28b4:	0f 90       	pop	r0
    			DataString[27] = 0x2E;
    			DataString[28] = 0x30;
    			DataString[29] = 0x2E;
    			DataString[30] = 0x30;
    			DataString[31] = 0x2D;
    			Steuerung = writedata;
    28b6:	0f 2e       	mov	r0, r31
    28b8:	f5 e0       	ldi	r31, 0x05	; 5
    28ba:	bf 2e       	mov	r11, r31
    28bc:	f0 2d       	mov	r31, r0
    			vDisplayWriteStringAtPos(1, 0, "Data:      big      ");
                
				break;
    28be:	2c cf       	rjmp	.-424    	; 0x2718 <vSteuertask+0x46>
			}
		
            case stringdata:
            {
                /* Command 3 is the command to transmit a string. */
                DataString[0] = 0x71;   // 0b011 1'0001 -> Command = 3, Databytes = 17
    28c0:	81 e7       	ldi	r24, 0x71	; 113
    28c2:	8d 83       	std	Y+5, r24	; 0x05
                sprintf((char*)&DataString[1], "Test erfolgreich!");
    28c4:	82 e1       	ldi	r24, 0x12	; 18
    28c6:	ed e4       	ldi	r30, 0x4D	; 77
    28c8:	f0 e2       	ldi	r31, 0x20	; 32
    28ca:	de 01       	movw	r26, r28
    28cc:	16 96       	adiw	r26, 0x06	; 6
    28ce:	01 90       	ld	r0, Z+
    28d0:	0d 92       	st	X+, r0
    28d2:	8a 95       	dec	r24
    28d4:	e1 f7       	brne	.-8      	; 0x28ce <vSteuertask+0x1fc>
                Steuerung = writedata;
                vDisplayWriteStringAtPos(1, 0, "Data:      string   ");
    28d6:	9f 92       	push	r9
    28d8:	8f 92       	push	r8
    28da:	1f 92       	push	r1
    28dc:	1f 92       	push	r1
    28de:	1f 92       	push	r1
    28e0:	af 92       	push	r10
    28e2:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <vDisplayWriteStringAtPos>
                
                break;
    28e6:	0f 90       	pop	r0
    28e8:	0f 90       	pop	r0
    28ea:	0f 90       	pop	r0
    28ec:	0f 90       	pop	r0
    28ee:	0f 90       	pop	r0
    28f0:	0f 90       	pop	r0
            case stringdata:
            {
                /* Command 3 is the command to transmit a string. */
                DataString[0] = 0x71;   // 0b011 1'0001 -> Command = 3, Databytes = 17
                sprintf((char*)&DataString[1], "Test erfolgreich!");
                Steuerung = writedata;
    28f2:	0f 2e       	mov	r0, r31
    28f4:	f5 e0       	ldi	r31, 0x05	; 5
    28f6:	bf 2e       	mov	r11, r31
    28f8:	f0 2d       	mov	r31, r0
                vDisplayWriteStringAtPos(1, 0, "Data:      string   ");
                
                break;
    28fa:	0e cf       	rjmp	.-484    	; 0x2718 <vSteuertask+0x46>
            }
            
			case writedata:
			{
    			vDisplayWriteStringAtPos(2, 0, "Command:   %d ", DataString[0] >> 5);
    28fc:	8d 81       	ldd	r24, Y+5	; 0x05
    28fe:	82 95       	swap	r24
    2900:	86 95       	lsr	r24
    2902:	87 70       	andi	r24, 0x07	; 7
    2904:	1f 92       	push	r1
    2906:	8f 93       	push	r24
    2908:	84 e7       	ldi	r24, 0x74	; 116
    290a:	90 e2       	ldi	r25, 0x20	; 32
    290c:	9f 93       	push	r25
    290e:	8f 93       	push	r24
    2910:	1f 92       	push	r1
    2912:	1f 92       	push	r1
    2914:	1f 92       	push	r1
    2916:	82 e0       	ldi	r24, 0x02	; 2
    2918:	8f 93       	push	r24
    291a:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <vDisplayWriteStringAtPos>
    			vDisplayWriteStringAtPos(3, 0, "DataBytes: %d ", DataString[0] & 0x1F);
    291e:	8d 81       	ldd	r24, Y+5	; 0x05
    2920:	8f 71       	andi	r24, 0x1F	; 31
    2922:	1f 92       	push	r1
    2924:	8f 93       	push	r24
    2926:	5f 92       	push	r5
    2928:	4f 92       	push	r4
    292a:	1f 92       	push	r1
    292c:	1f 92       	push	r1
    292e:	1f 92       	push	r1
    2930:	83 e0       	ldi	r24, 0x03	; 3
    2932:	8f 93       	push	r24
    2934:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <vDisplayWriteStringAtPos>
				vsendCommand(DataString);
    2938:	ce 01       	movw	r24, r28
    293a:	05 96       	adiw	r24, 0x05	; 5
    293c:	0e 94 3c 1f 	call	0x3e78	; 0x3e78 <vsendCommand>
				Steuerung = idle;
                
				break;
    2940:	cd bf       	out	0x3d, r28	; 61
    2942:	de bf       	out	0x3e, r29	; 62
			case writedata:
			{
    			vDisplayWriteStringAtPos(2, 0, "Command:   %d ", DataString[0] >> 5);
    			vDisplayWriteStringAtPos(3, 0, "DataBytes: %d ", DataString[0] & 0x1F);
				vsendCommand(DataString);
				Steuerung = idle;
    2944:	b1 2c       	mov	r11, r1
                
				break;
    2946:	e8 ce       	rjmp	.-560    	; 0x2718 <vSteuertask+0x46>

00002948 <vButtonTask>:
    }    
    
}

void vButtonTask(void *pvParameters) {
    initButtons();
    2948:	0e 94 4b 01 	call	0x296	; 0x296 <initButtons>

    for(;;) {
        updateButtons();
    294c:	0e 94 56 01 	call	0x2ac	; 0x2ac <updateButtons>
        
        if(getButtonPress(BUTTON1) == SHORT_PRESSED) {
    2950:	80 e0       	ldi	r24, 0x00	; 0
    2952:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <getButtonPress>
    2956:	81 30       	cpi	r24, 0x01	; 1
    2958:	69 f4       	brne	.+26     	; 0x2974 <vButtonTask+0x2c>
            
            xTaskNotify(xSteuertask,BUTTON1SHORTPRESSEDMASK,eSetValueWithOverwrite);
    295a:	00 e0       	ldi	r16, 0x00	; 0
    295c:	10 e0       	ldi	r17, 0x00	; 0
    295e:	23 e0       	ldi	r18, 0x03	; 3
    2960:	41 e0       	ldi	r20, 0x01	; 1
    2962:	50 e0       	ldi	r21, 0x00	; 0
    2964:	60 e0       	ldi	r22, 0x00	; 0
    2966:	70 e0       	ldi	r23, 0x00	; 0
    2968:	80 91 41 30 	lds	r24, 0x3041	; 0x803041 <xSteuertask>
    296c:	90 91 42 30 	lds	r25, 0x3042	; 0x803042 <xSteuertask+0x1>
    2970:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <xTaskGenericNotify>
            
            
        }
        if(getButtonPress(BUTTON2) == SHORT_PRESSED) {
    2974:	81 e0       	ldi	r24, 0x01	; 1
    2976:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <getButtonPress>
    297a:	81 30       	cpi	r24, 0x01	; 1
    297c:	69 f4       	brne	.+26     	; 0x2998 <vButtonTask+0x50>
            
            xTaskNotify(xSteuertask,BUTTON2SHORTPRESSEDMASK,eSetValueWithOverwrite);
    297e:	00 e0       	ldi	r16, 0x00	; 0
    2980:	10 e0       	ldi	r17, 0x00	; 0
    2982:	23 e0       	ldi	r18, 0x03	; 3
    2984:	42 e0       	ldi	r20, 0x02	; 2
    2986:	50 e0       	ldi	r21, 0x00	; 0
    2988:	60 e0       	ldi	r22, 0x00	; 0
    298a:	70 e0       	ldi	r23, 0x00	; 0
    298c:	80 91 41 30 	lds	r24, 0x3041	; 0x803041 <xSteuertask>
    2990:	90 91 42 30 	lds	r25, 0x3042	; 0x803042 <xSteuertask+0x1>
    2994:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <xTaskGenericNotify>
        }
        if(getButtonPress(BUTTON3) == SHORT_PRESSED) {
    2998:	82 e0       	ldi	r24, 0x02	; 2
    299a:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <getButtonPress>
    299e:	81 30       	cpi	r24, 0x01	; 1
    29a0:	69 f4       	brne	.+26     	; 0x29bc <vButtonTask+0x74>
            
            xTaskNotify(xSteuertask,BUTTON3SHORTPRESSEDMASK,eSetValueWithOverwrite);
    29a2:	00 e0       	ldi	r16, 0x00	; 0
    29a4:	10 e0       	ldi	r17, 0x00	; 0
    29a6:	23 e0       	ldi	r18, 0x03	; 3
    29a8:	44 e0       	ldi	r20, 0x04	; 4
    29aa:	50 e0       	ldi	r21, 0x00	; 0
    29ac:	60 e0       	ldi	r22, 0x00	; 0
    29ae:	70 e0       	ldi	r23, 0x00	; 0
    29b0:	80 91 41 30 	lds	r24, 0x3041	; 0x803041 <xSteuertask>
    29b4:	90 91 42 30 	lds	r25, 0x3042	; 0x803042 <xSteuertask+0x1>
    29b8:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <xTaskGenericNotify>
            
        }
        if(getButtonPress(BUTTON4) == SHORT_PRESSED) {
    29bc:	83 e0       	ldi	r24, 0x03	; 3
    29be:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <getButtonPress>
    29c2:	81 30       	cpi	r24, 0x01	; 1
    29c4:	69 f4       	brne	.+26     	; 0x29e0 <vButtonTask+0x98>
            
            xTaskNotify(xSteuertask,BUTTON4SHORTPRESSEDMASK,eSetValueWithOverwrite);
    29c6:	00 e0       	ldi	r16, 0x00	; 0
    29c8:	10 e0       	ldi	r17, 0x00	; 0
    29ca:	23 e0       	ldi	r18, 0x03	; 3
    29cc:	48 e0       	ldi	r20, 0x08	; 8
    29ce:	50 e0       	ldi	r21, 0x00	; 0
    29d0:	60 e0       	ldi	r22, 0x00	; 0
    29d2:	70 e0       	ldi	r23, 0x00	; 0
    29d4:	80 91 41 30 	lds	r24, 0x3041	; 0x803041 <xSteuertask>
    29d8:	90 91 42 30 	lds	r25, 0x3042	; 0x803042 <xSteuertask+0x1>
    29dc:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <xTaskGenericNotify>
            
        }

        vTaskDelay((1000/BUTTON_UPDATE_FREQUENCY_HZ)/portTICK_RATE_MS);
    29e0:	6a e0       	ldi	r22, 0x0A	; 10
    29e2:	70 e0       	ldi	r23, 0x00	; 0
    29e4:	80 e0       	ldi	r24, 0x00	; 0
    29e6:	90 e0       	ldi	r25, 0x00	; 0
    29e8:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <vTaskDelay>
    }
    29ec:	af cf       	rjmp	.-162    	; 0x294c <vButtonTask+0x4>

000029ee <vApplicationIdleHook>:




void vApplicationIdleHook( void )
{	
    29ee:	08 95       	ret

000029f0 <main>:
TaskHandle_t xSteuertask;
TaskHandle_t xButtonTaskHandle;


int main(void)//Hauptprogramm
{
    29f0:	ef 92       	push	r14
    29f2:	ff 92       	push	r15
    29f4:	0f 93       	push	r16
    29f6:	cf 93       	push	r28
    resetReason_t reason = getResetReason();
    29f8:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <getResetReason>
    29fc:	c8 2f       	mov	r28, r24

	vInitClock();
    29fe:	0e 94 31 13 	call	0x2662	; 0x2662 <vInitClock>
	vInitDisplay();
    2a02:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <vInitDisplay>
    
 

	xTaskCreate(vQuamGen, NULL, configMINIMAL_STACK_SIZE+100, NULL, 2, NULL);
    2a06:	e1 2c       	mov	r14, r1
    2a08:	f1 2c       	mov	r15, r1
    2a0a:	02 e0       	ldi	r16, 0x02	; 2
    2a0c:	20 e0       	ldi	r18, 0x00	; 0
    2a0e:	30 e0       	ldi	r19, 0x00	; 0
    2a10:	4c e2       	ldi	r20, 0x2C	; 44
    2a12:	51 e0       	ldi	r21, 0x01	; 1
    2a14:	60 e0       	ldi	r22, 0x00	; 0
    2a16:	70 e0       	ldi	r23, 0x00	; 0
    2a18:	8a e7       	ldi	r24, 0x7A	; 122
    2a1a:	9d e1       	ldi	r25, 0x1D	; 29
    2a1c:	0e 94 46 0a 	call	0x148c	; 0x148c <xTaskCreate>
    xTaskCreate(vSteuertask, NULL, configMINIMAL_STACK_SIZE+100, NULL, 2, &xSteuertask);
    2a20:	0f 2e       	mov	r0, r31
    2a22:	f1 e4       	ldi	r31, 0x41	; 65
    2a24:	ef 2e       	mov	r14, r31
    2a26:	f0 e3       	ldi	r31, 0x30	; 48
    2a28:	ff 2e       	mov	r15, r31
    2a2a:	f0 2d       	mov	r31, r0
    2a2c:	20 e0       	ldi	r18, 0x00	; 0
    2a2e:	30 e0       	ldi	r19, 0x00	; 0
    2a30:	4c e2       	ldi	r20, 0x2C	; 44
    2a32:	51 e0       	ldi	r21, 0x01	; 1
    2a34:	60 e0       	ldi	r22, 0x00	; 0
    2a36:	70 e0       	ldi	r23, 0x00	; 0
    2a38:	89 e6       	ldi	r24, 0x69	; 105
    2a3a:	93 e1       	ldi	r25, 0x13	; 19
    2a3c:	0e 94 46 0a 	call	0x148c	; 0x148c <xTaskCreate>
    xTaskCreate(vButtonTask, (const char *) "ButtonTask", configMINIMAL_STACK_SIZE, NULL, 2, &xButtonTaskHandle);
    2a40:	0f 2e       	mov	r0, r31
    2a42:	ff e3       	ldi	r31, 0x3F	; 63
    2a44:	ef 2e       	mov	r14, r31
    2a46:	f0 e3       	ldi	r31, 0x30	; 48
    2a48:	ff 2e       	mov	r15, r31
    2a4a:	f0 2d       	mov	r31, r0
    2a4c:	20 e0       	ldi	r18, 0x00	; 0
    2a4e:	30 e0       	ldi	r19, 0x00	; 0
    2a50:	48 ec       	ldi	r20, 0xC8	; 200
    2a52:	50 e0       	ldi	r21, 0x00	; 0
    2a54:	62 e9       	ldi	r22, 0x92	; 146
    2a56:	70 e2       	ldi	r23, 0x20	; 32
    2a58:	84 ea       	ldi	r24, 0xA4	; 164
    2a5a:	94 e1       	ldi	r25, 0x14	; 20
    2a5c:	0e 94 46 0a 	call	0x148c	; 0x148c <xTaskCreate>

    

	vDisplayClear();
    2a60:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <vDisplayClear>
	vDisplayWriteStringAtPos(0,0,"QAM 4 Generator R: %d", reason);
    2a64:	1f 92       	push	r1
    2a66:	cf 93       	push	r28
    2a68:	8d e9       	ldi	r24, 0x9D	; 157
    2a6a:	90 e2       	ldi	r25, 0x20	; 32
    2a6c:	9f 93       	push	r25
    2a6e:	8f 93       	push	r24
    2a70:	1f 92       	push	r1
    2a72:	1f 92       	push	r1
    2a74:	1f 92       	push	r1
    2a76:	1f 92       	push	r1
    2a78:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <vDisplayWriteStringAtPos>
	vTaskStartScheduler();
    2a7c:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <vTaskStartScheduler>
    2a80:	8d b7       	in	r24, 0x3d	; 61
    2a82:	9e b7       	in	r25, 0x3e	; 62
    2a84:	08 96       	adiw	r24, 0x08	; 8
    2a86:	8d bf       	out	0x3d, r24	; 61
    2a88:	9e bf       	out	0x3e, r25	; 62
	return 0;
}
    2a8a:	80 e0       	ldi	r24, 0x00	; 0
    2a8c:	90 e0       	ldi	r25, 0x00	; 0
    2a8e:	cf 91       	pop	r28
    2a90:	0f 91       	pop	r16
    2a92:	ff 90       	pop	r15
    2a94:	ef 90       	pop	r14
    2a96:	08 95       	ret

00002a98 <__vector_108>:
 void displayHome() {
	 command(0x02);
 }
 void _displayClear() {
	 command(0x01);
	 delayUS(2000);
    2a98:	1f 92       	push	r1
    2a9a:	0f 92       	push	r0
    2a9c:	0f b6       	in	r0, 0x3f	; 63
    2a9e:	0f 92       	push	r0
    2aa0:	11 24       	eor	r1, r1
    2aa2:	0b b6       	in	r0, 0x3b	; 59
    2aa4:	0f 92       	push	r0
    2aa6:	2f 93       	push	r18
    2aa8:	3f 93       	push	r19
    2aaa:	4f 93       	push	r20
    2aac:	5f 93       	push	r21
    2aae:	6f 93       	push	r22
    2ab0:	7f 93       	push	r23
    2ab2:	8f 93       	push	r24
    2ab4:	9f 93       	push	r25
    2ab6:	af 93       	push	r26
    2ab8:	bf 93       	push	r27
    2aba:	ef 93       	push	r30
    2abc:	ff 93       	push	r31
    2abe:	cf 93       	push	r28
    2ac0:	df 93       	push	r29
    2ac2:	1f 92       	push	r1
    2ac4:	cd b7       	in	r28, 0x3d	; 61
    2ac6:	de b7       	in	r29, 0x3e	; 62
    2ac8:	19 82       	std	Y+1, r1	; 0x01
    2aca:	9e 01       	movw	r18, r28
    2acc:	2f 5f       	subi	r18, 0xFF	; 255
    2ace:	3f 4f       	sbci	r19, 0xFF	; 255
    2ad0:	41 e0       	ldi	r20, 0x01	; 1
    2ad2:	50 e0       	ldi	r21, 0x00	; 0
    2ad4:	60 e0       	ldi	r22, 0x00	; 0
    2ad6:	70 e0       	ldi	r23, 0x00	; 0
    2ad8:	80 91 45 30 	lds	r24, 0x3045	; 0x803045 <egDisplayTiming>
    2adc:	90 91 46 30 	lds	r25, 0x3046	; 0x803046 <egDisplayTiming+0x1>
    2ae0:	0e 94 15 04 	call	0x82a	; 0x82a <xEventGroupSetBitsFromISR>
    2ae4:	60 e0       	ldi	r22, 0x00	; 0
    2ae6:	80 e0       	ldi	r24, 0x00	; 0
    2ae8:	9b e0       	ldi	r25, 0x0B	; 11
    2aea:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <TC0_ConfigClockSource>
    2aee:	10 92 06 0b 	sts	0x0B06, r1	; 0x800b06 <__TEXT_REGION_LENGTH__+0x700b06>
    2af2:	0f 90       	pop	r0
    2af4:	df 91       	pop	r29
    2af6:	cf 91       	pop	r28
    2af8:	ff 91       	pop	r31
    2afa:	ef 91       	pop	r30
    2afc:	bf 91       	pop	r27
    2afe:	af 91       	pop	r26
    2b00:	9f 91       	pop	r25
    2b02:	8f 91       	pop	r24
    2b04:	7f 91       	pop	r23
    2b06:	6f 91       	pop	r22
    2b08:	5f 91       	pop	r21
    2b0a:	4f 91       	pop	r20
    2b0c:	3f 91       	pop	r19
    2b0e:	2f 91       	pop	r18
    2b10:	0f 90       	pop	r0
    2b12:	0b be       	out	0x3b, r0	; 59
    2b14:	0f 90       	pop	r0
    2b16:	0f be       	out	0x3f, r0	; 63
    2b18:	0f 90       	pop	r0
    2b1a:	1f 90       	pop	r1
    2b1c:	18 95       	reti

00002b1e <delayUS>:
    2b1e:	cf 92       	push	r12
    2b20:	df 92       	push	r13
    2b22:	ef 92       	push	r14
    2b24:	ff 92       	push	r15
    2b26:	0f 93       	push	r16
    2b28:	6b 01       	movw	r12, r22
    2b2a:	7c 01       	movw	r14, r24
    2b2c:	82 e0       	ldi	r24, 0x02	; 2
    2b2e:	c8 16       	cp	r12, r24
    2b30:	d1 04       	cpc	r13, r1
    2b32:	e1 04       	cpc	r14, r1
    2b34:	f1 04       	cpc	r15, r1
    2b36:	08 f4       	brcc	.+2      	; 0x2b3a <delayUS+0x1c>
    2b38:	4e c0       	rjmp	.+156    	; 0x2bd6 <delayUS+0xb8>
    2b3a:	e0 e0       	ldi	r30, 0x00	; 0
    2b3c:	fb e0       	ldi	r31, 0x0B	; 11
    2b3e:	81 e0       	ldi	r24, 0x01	; 1
    2b40:	86 83       	std	Z+6, r24	; 0x06
    2b42:	10 a2       	std	Z+32, r1	; 0x20
    2b44:	11 a2       	std	Z+33, r1	; 0x21
    2b46:	60 e0       	ldi	r22, 0x00	; 0
    2b48:	80 e0       	ldi	r24, 0x00	; 0
    2b4a:	9b e0       	ldi	r25, 0x0B	; 11
    2b4c:	0e 94 60 02 	call	0x4c0	; 0x4c0 <TC0_ConfigWGM>
    2b50:	8e ef       	ldi	r24, 0xFE	; 254
    2b52:	c8 16       	cp	r12, r24
    2b54:	8f ef       	ldi	r24, 0xFF	; 255
    2b56:	d8 06       	cpc	r13, r24
    2b58:	e1 04       	cpc	r14, r1
    2b5a:	f1 04       	cpc	r15, r1
    2b5c:	70 f4       	brcc	.+28     	; 0x2b7a <delayUS+0x5c>
    2b5e:	f6 94       	lsr	r15
    2b60:	e7 94       	ror	r14
    2b62:	d7 94       	ror	r13
    2b64:	c7 94       	ror	r12
    2b66:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2b6a:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2b6e:	65 e0       	ldi	r22, 0x05	; 5
    2b70:	80 e0       	ldi	r24, 0x00	; 0
    2b72:	9b e0       	ldi	r25, 0x0B	; 11
    2b74:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <TC0_ConfigClockSource>
    2b78:	19 c0       	rjmp	.+50     	; 0x2bac <delayUS+0x8e>
    2b7a:	80 e4       	ldi	r24, 0x40	; 64
    2b7c:	c8 16       	cp	r12, r24
    2b7e:	82 e4       	ldi	r24, 0x42	; 66
    2b80:	d8 06       	cpc	r13, r24
    2b82:	8f e0       	ldi	r24, 0x0F	; 15
    2b84:	e8 06       	cpc	r14, r24
    2b86:	f1 04       	cpc	r15, r1
    2b88:	88 f4       	brcc	.+34     	; 0x2bac <delayUS+0x8e>
    2b8a:	68 94       	set
    2b8c:	14 f8       	bld	r1, 4
    2b8e:	f6 94       	lsr	r15
    2b90:	e7 94       	ror	r14
    2b92:	d7 94       	ror	r13
    2b94:	c7 94       	ror	r12
    2b96:	16 94       	lsr	r1
    2b98:	d1 f7       	brne	.-12     	; 0x2b8e <delayUS+0x70>
    2b9a:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2b9e:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2ba2:	67 e0       	ldi	r22, 0x07	; 7
    2ba4:	80 e0       	ldi	r24, 0x00	; 0
    2ba6:	9b e0       	ldi	r25, 0x0B	; 11
    2ba8:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <TC0_ConfigClockSource>
    2bac:	0f 2e       	mov	r0, r31
    2bae:	f4 ef       	ldi	r31, 0xF4	; 244
    2bb0:	cf 2e       	mov	r12, r31
    2bb2:	dd 24       	eor	r13, r13
    2bb4:	d3 94       	inc	r13
    2bb6:	e1 2c       	mov	r14, r1
    2bb8:	f1 2c       	mov	r15, r1
    2bba:	f0 2d       	mov	r31, r0
    2bbc:	00 e0       	ldi	r16, 0x00	; 0
    2bbe:	21 e0       	ldi	r18, 0x01	; 1
    2bc0:	41 e0       	ldi	r20, 0x01	; 1
    2bc2:	50 e0       	ldi	r21, 0x00	; 0
    2bc4:	60 e0       	ldi	r22, 0x00	; 0
    2bc6:	70 e0       	ldi	r23, 0x00	; 0
    2bc8:	80 91 45 30 	lds	r24, 0x3045	; 0x803045 <egDisplayTiming>
    2bcc:	90 91 46 30 	lds	r25, 0x3046	; 0x803046 <egDisplayTiming+0x1>
    2bd0:	0e 94 8b 02 	call	0x516	; 0x516 <xEventGroupWaitBits>
    2bd4:	11 c0       	rjmp	.+34     	; 0x2bf8 <delayUS+0xda>
    2bd6:	e0 e0       	ldi	r30, 0x00	; 0
    2bd8:	fb e0       	ldi	r31, 0x0B	; 11
    2bda:	81 e0       	ldi	r24, 0x01	; 1
    2bdc:	86 83       	std	Z+6, r24	; 0x06
    2bde:	10 a2       	std	Z+32, r1	; 0x20
    2be0:	11 a2       	std	Z+33, r1	; 0x21
    2be2:	60 e0       	ldi	r22, 0x00	; 0
    2be4:	80 e0       	ldi	r24, 0x00	; 0
    2be6:	9b e0       	ldi	r25, 0x0B	; 11
    2be8:	0e 94 60 02 	call	0x4c0	; 0x4c0 <TC0_ConfigWGM>
    2bec:	c1 2c       	mov	r12, r1
    2bee:	d1 2c       	mov	r13, r1
    2bf0:	76 01       	movw	r14, r12
    2bf2:	68 94       	set
    2bf4:	c1 f8       	bld	r12, 1
    2bf6:	b3 cf       	rjmp	.-154    	; 0x2b5e <delayUS+0x40>
    2bf8:	0f 91       	pop	r16
    2bfa:	ff 90       	pop	r15
    2bfc:	ef 90       	pop	r14
    2bfe:	df 90       	pop	r13
    2c00:	cf 90       	pop	r12
    2c02:	08 95       	ret

00002c04 <setPort>:
    2c04:	82 95       	swap	r24
    2c06:	80 7f       	andi	r24, 0xF0	; 240
    2c08:	e0 e0       	ldi	r30, 0x00	; 0
    2c0a:	f6 e0       	ldi	r31, 0x06	; 6
    2c0c:	94 81       	ldd	r25, Z+4	; 0x04
    2c0e:	28 2f       	mov	r18, r24
    2c10:	2f 60       	ori	r18, 0x0F	; 15
    2c12:	92 23       	and	r25, r18
    2c14:	94 83       	std	Z+4, r25	; 0x04
    2c16:	94 81       	ldd	r25, Z+4	; 0x04
    2c18:	89 2b       	or	r24, r25
    2c1a:	84 83       	std	Z+4, r24	; 0x04
    2c1c:	08 95       	ret

00002c1e <Nybble>:
    2c1e:	1f 93       	push	r17
    2c20:	cf 93       	push	r28
    2c22:	df 93       	push	r29
    2c24:	c0 e6       	ldi	r28, 0x60	; 96
    2c26:	d6 e0       	ldi	r29, 0x06	; 6
    2c28:	14 e0       	ldi	r17, 0x04	; 4
    2c2a:	1d 83       	std	Y+5, r17	; 0x05
    2c2c:	61 e0       	ldi	r22, 0x01	; 1
    2c2e:	70 e0       	ldi	r23, 0x00	; 0
    2c30:	80 e0       	ldi	r24, 0x00	; 0
    2c32:	90 e0       	ldi	r25, 0x00	; 0
    2c34:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <delayUS>
    2c38:	1e 83       	std	Y+6, r17	; 0x06
    2c3a:	df 91       	pop	r29
    2c3c:	cf 91       	pop	r28
    2c3e:	1f 91       	pop	r17
    2c40:	08 95       	ret

00002c42 <command>:
    2c42:	cf 93       	push	r28
    2c44:	c8 2f       	mov	r28, r24
    2c46:	82 95       	swap	r24
    2c48:	8f 70       	andi	r24, 0x0F	; 15
    2c4a:	0e 94 02 16 	call	0x2c04	; 0x2c04 <setPort>
    2c4e:	e0 e6       	ldi	r30, 0x60	; 96
    2c50:	f6 e0       	ldi	r31, 0x06	; 6
    2c52:	81 e0       	ldi	r24, 0x01	; 1
    2c54:	86 83       	std	Z+6, r24	; 0x06
    2c56:	82 e0       	ldi	r24, 0x02	; 2
    2c58:	86 83       	std	Z+6, r24	; 0x06
    2c5a:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <Nybble>
    2c5e:	8c 2f       	mov	r24, r28
    2c60:	8f 70       	andi	r24, 0x0F	; 15
    2c62:	0e 94 02 16 	call	0x2c04	; 0x2c04 <setPort>
    2c66:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <Nybble>
    2c6a:	cf 91       	pop	r28
    2c6c:	08 95       	ret

00002c6e <write>:
    2c6e:	cf 93       	push	r28
    2c70:	c8 2f       	mov	r28, r24
    2c72:	82 95       	swap	r24
    2c74:	8f 70       	andi	r24, 0x0F	; 15
    2c76:	0e 94 02 16 	call	0x2c04	; 0x2c04 <setPort>
    2c7a:	e0 e6       	ldi	r30, 0x60	; 96
    2c7c:	f6 e0       	ldi	r31, 0x06	; 6
    2c7e:	81 e0       	ldi	r24, 0x01	; 1
    2c80:	85 83       	std	Z+5, r24	; 0x05
    2c82:	82 e0       	ldi	r24, 0x02	; 2
    2c84:	86 83       	std	Z+6, r24	; 0x06
    2c86:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <Nybble>
    2c8a:	8c 2f       	mov	r24, r28
    2c8c:	8f 70       	andi	r24, 0x0F	; 15
    2c8e:	0e 94 02 16 	call	0x2c04	; 0x2c04 <setPort>
    2c92:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <Nybble>
    2c96:	cf 91       	pop	r28
    2c98:	08 95       	ret

00002c9a <vInitDisplay>:
 }
 
 void vInitDisplay() {
    2c9a:	ef 92       	push	r14
    2c9c:	ff 92       	push	r15
    2c9e:	0f 93       	push	r16
	PORTA.DIRSET = PIN4_bm;
    2ca0:	e0 e0       	ldi	r30, 0x00	; 0
    2ca2:	f6 e0       	ldi	r31, 0x06	; 6
    2ca4:	80 e1       	ldi	r24, 0x10	; 16
    2ca6:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN5_bm;
    2ca8:	80 e2       	ldi	r24, 0x20	; 32
    2caa:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN6_bm;
    2cac:	80 e4       	ldi	r24, 0x40	; 64
    2cae:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN7_bm;
    2cb0:	80 e8       	ldi	r24, 0x80	; 128
    2cb2:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = PIN0_bm;
    2cb4:	a0 e6       	ldi	r26, 0x60	; 96
    2cb6:	b6 e0       	ldi	r27, 0x06	; 6
    2cb8:	81 e0       	ldi	r24, 0x01	; 1
    2cba:	11 96       	adiw	r26, 0x01	; 1
    2cbc:	8c 93       	st	X, r24
    2cbe:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN1_bm;
    2cc0:	82 e0       	ldi	r24, 0x02	; 2
    2cc2:	11 96       	adiw	r26, 0x01	; 1
    2cc4:	8c 93       	st	X, r24
    2cc6:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN2_bm;
    2cc8:	84 e0       	ldi	r24, 0x04	; 4
    2cca:	11 96       	adiw	r26, 0x01	; 1
    2ccc:	8c 93       	st	X, r24
    2cce:	11 97       	sbiw	r26, 0x01	; 1
	PORTA.OUT &= 0x0F;
    2cd0:	84 81       	ldd	r24, Z+4	; 0x04
    2cd2:	8f 70       	andi	r24, 0x0F	; 15
    2cd4:	84 83       	std	Z+4, r24	; 0x04
	PORTD.OUT &= 0xF8;
    2cd6:	14 96       	adiw	r26, 0x04	; 4
    2cd8:	8c 91       	ld	r24, X
    2cda:	14 97       	sbiw	r26, 0x04	; 4
    2cdc:	88 7f       	andi	r24, 0xF8	; 248
    2cde:	14 96       	adiw	r26, 0x04	; 4
    2ce0:	8c 93       	st	X, r24

	if((displayLineQueue = xQueueCreate(DISPLAY_QUEUE_DEPTH, sizeof(displayLine_t))) == NULL)
    2ce2:	40 e0       	ldi	r20, 0x00	; 0
    2ce4:	66 e1       	ldi	r22, 0x16	; 22
    2ce6:	88 e0       	ldi	r24, 0x08	; 8
    2ce8:	0e 94 ac 07 	call	0xf58	; 0xf58 <xQueueGenericCreate>
    2cec:	80 93 43 30 	sts	0x3043, r24	; 0x803043 <displayLineQueue>
    2cf0:	90 93 44 30 	sts	0x3044, r25	; 0x803044 <displayLineQueue+0x1>
	{
		//error(ERR_QUEUE_CREATE_HANDLE_NULL);
	}
	
	egDisplayTiming = xEventGroupCreate();
    2cf4:	0e 94 76 02 	call	0x4ec	; 0x4ec <xEventGroupCreate>
    2cf8:	80 93 45 30 	sts	0x3045, r24	; 0x803045 <egDisplayTiming>
    2cfc:	90 93 46 30 	sts	0x3046, r25	; 0x803046 <egDisplayTiming+0x1>
	

	xTaskCreate(vDisplayUpdateTask, (const char*) "dispUpdate", configMINIMAL_STACK_SIZE+150, NULL, 1, NULL);	
    2d00:	e1 2c       	mov	r14, r1
    2d02:	f1 2c       	mov	r15, r1
    2d04:	01 e0       	ldi	r16, 0x01	; 1
    2d06:	20 e0       	ldi	r18, 0x00	; 0
    2d08:	30 e0       	ldi	r19, 0x00	; 0
    2d0a:	4e e5       	ldi	r20, 0x5E	; 94
    2d0c:	51 e0       	ldi	r21, 0x01	; 1
    2d0e:	63 eb       	ldi	r22, 0xB3	; 179
    2d10:	70 e2       	ldi	r23, 0x20	; 32
    2d12:	8b ee       	ldi	r24, 0xEB	; 235
    2d14:	96 e1       	ldi	r25, 0x16	; 22
    2d16:	0e 94 46 0a 	call	0x148c	; 0x148c <xTaskCreate>
 }
    2d1a:	0f 91       	pop	r16
    2d1c:	ff 90       	pop	r15
    2d1e:	ef 90       	pop	r14
    2d20:	08 95       	ret

00002d22 <_displaySetPos>:
 
 void _displaySetPos(int line, int pos) {
	 switch(line) {
    2d22:	81 30       	cpi	r24, 0x01	; 1
    2d24:	91 05       	cpc	r25, r1
    2d26:	79 f0       	breq	.+30     	; 0x2d46 <_displaySetPos+0x24>
    2d28:	1c f4       	brge	.+6      	; 0x2d30 <_displaySetPos+0xe>
    2d2a:	89 2b       	or	r24, r25
    2d2c:	39 f0       	breq	.+14     	; 0x2d3c <_displaySetPos+0x1a>
    2d2e:	19 c0       	rjmp	.+50     	; 0x2d62 <_displaySetPos+0x40>
    2d30:	82 30       	cpi	r24, 0x02	; 2
    2d32:	91 05       	cpc	r25, r1
    2d34:	69 f0       	breq	.+26     	; 0x2d50 <_displaySetPos+0x2e>
    2d36:	03 97       	sbiw	r24, 0x03	; 3
    2d38:	81 f0       	breq	.+32     	; 0x2d5a <_displaySetPos+0x38>
    2d3a:	13 c0       	rjmp	.+38     	; 0x2d62 <_displaySetPos+0x40>
		 case 0:
		 command(0x80 + 0x00 + pos);
    2d3c:	80 e8       	ldi	r24, 0x80	; 128
    2d3e:	86 0f       	add	r24, r22
    2d40:	0e 94 21 16 	call	0x2c42	; 0x2c42 <command>
		 break;
    2d44:	0e c0       	rjmp	.+28     	; 0x2d62 <_displaySetPos+0x40>
		 case 1:
		 command(0x80 + 0x40 + pos);
    2d46:	80 ec       	ldi	r24, 0xC0	; 192
    2d48:	86 0f       	add	r24, r22
    2d4a:	0e 94 21 16 	call	0x2c42	; 0x2c42 <command>
		 break;
    2d4e:	09 c0       	rjmp	.+18     	; 0x2d62 <_displaySetPos+0x40>
		 case 2:
		 command(0x80 + 0x14 + pos);
    2d50:	84 e9       	ldi	r24, 0x94	; 148
    2d52:	86 0f       	add	r24, r22
    2d54:	0e 94 21 16 	call	0x2c42	; 0x2c42 <command>
		 break;
    2d58:	04 c0       	rjmp	.+8      	; 0x2d62 <_displaySetPos+0x40>
		 case 3:
		 command(0x80 + 0x54 + pos);
    2d5a:	84 ed       	ldi	r24, 0xD4	; 212
    2d5c:	86 0f       	add	r24, r22
    2d5e:	0e 94 21 16 	call	0x2c42	; 0x2c42 <command>
		 break;
	 }
	 delayUS(39);
    2d62:	67 e2       	ldi	r22, 0x27	; 39
    2d64:	70 e0       	ldi	r23, 0x00	; 0
    2d66:	80 e0       	ldi	r24, 0x00	; 0
    2d68:	90 e0       	ldi	r25, 0x00	; 0
    2d6a:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <delayUS>
    2d6e:	08 95       	ret

00002d70 <_displayWriteChar>:
 }

 void _displayWriteChar(char c) {
	 write(c);
    2d70:	0e 94 37 16 	call	0x2c6e	; 0x2c6e <write>
	 delayUS(43);
    2d74:	6b e2       	ldi	r22, 0x2B	; 43
    2d76:	70 e0       	ldi	r23, 0x00	; 0
    2d78:	80 e0       	ldi	r24, 0x00	; 0
    2d7a:	90 e0       	ldi	r25, 0x00	; 0
    2d7c:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <delayUS>
    2d80:	08 95       	ret

00002d82 <_displayWriteString>:
 }
 
 void _displayWriteString(char* s) {
    2d82:	0f 93       	push	r16
    2d84:	1f 93       	push	r17
    2d86:	cf 93       	push	r28
    2d88:	df 93       	push	r29
    2d8a:	fc 01       	movw	r30, r24
	 for(int i = 0; i < 20; i++) {
		 if(s[i] == '\0') {
    2d8c:	80 81       	ld	r24, Z
    2d8e:	81 11       	cpse	r24, r1
    2d90:	0a c0       	rjmp	.+20     	; 0x2da6 <_displayWriteString+0x24>
    2d92:	11 c0       	rjmp	.+34     	; 0x2db6 <_displayWriteString+0x34>
    2d94:	89 91       	ld	r24, Y+
    2d96:	88 23       	and	r24, r24
    2d98:	71 f0       	breq	.+28     	; 0x2db6 <_displayWriteString+0x34>
			 break;
		 }
		 _displayWriteChar(s[i]);
    2d9a:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <_displayWriteChar>
	 write(c);
	 delayUS(43);
 }
 
 void _displayWriteString(char* s) {
	 for(int i = 0; i < 20; i++) {
    2d9e:	0c 17       	cp	r16, r28
    2da0:	1d 07       	cpc	r17, r29
    2da2:	c1 f7       	brne	.-16     	; 0x2d94 <_displayWriteString+0x12>
    2da4:	08 c0       	rjmp	.+16     	; 0x2db6 <_displayWriteString+0x34>
    2da6:	8f 01       	movw	r16, r30
		 if(s[i] == '\0') {
			 break;
		 }
		 _displayWriteChar(s[i]);
    2da8:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <_displayWriteChar>
    2dac:	e8 01       	movw	r28, r16
    2dae:	21 96       	adiw	r28, 0x01	; 1
    2db0:	0c 5e       	subi	r16, 0xEC	; 236
    2db2:	1f 4f       	sbci	r17, 0xFF	; 255
    2db4:	ef cf       	rjmp	.-34     	; 0x2d94 <_displayWriteString+0x12>
	 }
 }
    2db6:	df 91       	pop	r29
    2db8:	cf 91       	pop	r28
    2dba:	1f 91       	pop	r17
    2dbc:	0f 91       	pop	r16
    2dbe:	08 95       	ret

00002dc0 <_displayWriteStringAtPos>:

 void _displayWriteStringAtPos(int line, int pos, char* s) {
    2dc0:	cf 93       	push	r28
    2dc2:	df 93       	push	r29
    2dc4:	ea 01       	movw	r28, r20
	 _displaySetPos(line, pos);
    2dc6:	0e 94 91 16 	call	0x2d22	; 0x2d22 <_displaySetPos>
	 _displayWriteString(s);
    2dca:	ce 01       	movw	r24, r28
    2dcc:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <_displayWriteString>
 }
    2dd0:	df 91       	pop	r29
    2dd2:	cf 91       	pop	r28
    2dd4:	08 95       	ret

00002dd6 <vDisplayUpdateTask>:

 void vDisplayUpdateTask(void *pvParameters) {
    2dd6:	cf 93       	push	r28
    2dd8:	df 93       	push	r29
    2dda:	cd b7       	in	r28, 0x3d	; 61
    2ddc:	de b7       	in	r29, 0x3e	; 62
    2dde:	c6 56       	subi	r28, 0x66	; 102
    2de0:	d1 09       	sbc	r29, r1
    2de2:	cd bf       	out	0x3d, r28	; 61
    2de4:	de bf       	out	0x3e, r29	; 62
    2de6:	5e 01       	movw	r10, r28
    2de8:	41 e5       	ldi	r20, 0x51	; 81
    2dea:	a4 0e       	add	r10, r20
    2dec:	b1 1c       	adc	r11, r1
    2dee:	fe 01       	movw	r30, r28
    2df0:	31 96       	adiw	r30, 0x01	; 1
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
			displayLines[i][j] = 0x20;
    2df2:	20 e2       	ldi	r18, 0x20	; 32
    2df4:	08 c0       	rjmp	.+16     	; 0x2e06 <vDisplayUpdateTask+0x30>
    2df6:	21 93       	st	Z+, r18
 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
    2df8:	e8 17       	cp	r30, r24
    2dfa:	f9 07       	cpc	r31, r25
    2dfc:	e1 f7       	brne	.-8      	; 0x2df6 <vDisplayUpdateTask+0x20>
    2dfe:	fc 01       	movw	r30, r24

 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
    2e00:	a8 16       	cp	r10, r24
    2e02:	b9 06       	cpc	r11, r25
    2e04:	19 f0       	breq	.+6      	; 0x2e0c <vDisplayUpdateTask+0x36>
    2e06:	cf 01       	movw	r24, r30
    2e08:	44 96       	adiw	r24, 0x14	; 20
    2e0a:	f5 cf       	rjmp	.-22     	; 0x2df6 <vDisplayUpdateTask+0x20>
			displayLines[i][j] = 0x20;
		}
	 }
	 displayLine_t newLine;

	 delayUS(40000);
    2e0c:	60 e4       	ldi	r22, 0x40	; 64
    2e0e:	7c e9       	ldi	r23, 0x9C	; 156
    2e10:	80 e0       	ldi	r24, 0x00	; 0
    2e12:	90 e0       	ldi	r25, 0x00	; 0
    2e14:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <delayUS>
	 setPort(0x03);
    2e18:	83 e0       	ldi	r24, 0x03	; 3
    2e1a:	0e 94 02 16 	call	0x2c04	; 0x2c04 <setPort>
	 delayUS(5000);
    2e1e:	68 e8       	ldi	r22, 0x88	; 136
    2e20:	73 e1       	ldi	r23, 0x13	; 19
    2e22:	80 e0       	ldi	r24, 0x00	; 0
    2e24:	90 e0       	ldi	r25, 0x00	; 0
    2e26:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <delayUS>
	 Nybble();
    2e2a:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <Nybble>
	 delayUS(160);
    2e2e:	60 ea       	ldi	r22, 0xA0	; 160
    2e30:	70 e0       	ldi	r23, 0x00	; 0
    2e32:	80 e0       	ldi	r24, 0x00	; 0
    2e34:	90 e0       	ldi	r25, 0x00	; 0
    2e36:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <delayUS>
	 Nybble();
    2e3a:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <Nybble>
	 delayUS(160);
    2e3e:	60 ea       	ldi	r22, 0xA0	; 160
    2e40:	70 e0       	ldi	r23, 0x00	; 0
    2e42:	80 e0       	ldi	r24, 0x00	; 0
    2e44:	90 e0       	ldi	r25, 0x00	; 0
    2e46:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <delayUS>
	 Nybble();
    2e4a:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <Nybble>
	 delayUS(160);
    2e4e:	60 ea       	ldi	r22, 0xA0	; 160
    2e50:	70 e0       	ldi	r23, 0x00	; 0
    2e52:	80 e0       	ldi	r24, 0x00	; 0
    2e54:	90 e0       	ldi	r25, 0x00	; 0
    2e56:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <delayUS>
	 setPort(0x02);
    2e5a:	82 e0       	ldi	r24, 0x02	; 2
    2e5c:	0e 94 02 16 	call	0x2c04	; 0x2c04 <setPort>
	 Nybble();
    2e60:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <Nybble>
	 command(0x28);
    2e64:	88 e2       	ldi	r24, 0x28	; 40
    2e66:	0e 94 21 16 	call	0x2c42	; 0x2c42 <command>
	 command(0x10);
    2e6a:	80 e1       	ldi	r24, 0x10	; 16
    2e6c:	0e 94 21 16 	call	0x2c42	; 0x2c42 <command>
	 command(0x0C); //Cursor and Blinking off
    2e70:	8c e0       	ldi	r24, 0x0C	; 12
    2e72:	0e 94 21 16 	call	0x2c42	; 0x2c42 <command>
	 command(0x06);
    2e76:	86 e0       	ldi	r24, 0x06	; 6
    2e78:	0e 94 21 16 	call	0x2c42	; 0x2c42 <command>
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2e7c:	10 e2       	ldi	r17, 0x20	; 32
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2e7e:	6e 01       	movw	r12, r28
    2e80:	51 e5       	ldi	r21, 0x51	; 81
    2e82:	c5 0e       	add	r12, r21
    2e84:	d1 1c       	adc	r13, r1
    2e86:	0f 2e       	mov	r0, r31
    2e88:	f4 e1       	ldi	r31, 0x14	; 20
    2e8a:	4f 2e       	mov	r4, r31
    2e8c:	f0 2d       	mov	r31, r0
    2e8e:	0f 2e       	mov	r0, r31
    2e90:	f6 e1       	ldi	r31, 0x16	; 22
    2e92:	8f 2e       	mov	r8, r31
    2e94:	91 2c       	mov	r9, r1
    2e96:	f0 2d       	mov	r31, r0
    2e98:	5c 2c       	mov	r5, r12
    2e9a:	0d 2d       	mov	r16, r13
	 command(0x10);
	 command(0x0C); //Cursor and Blinking off
	 command(0x06);
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
    2e9c:	68 ec       	ldi	r22, 0xC8	; 200
    2e9e:	70 e0       	ldi	r23, 0x00	; 0
    2ea0:	80 e0       	ldi	r24, 0x00	; 0
    2ea2:	90 e0       	ldi	r25, 0x00	; 0
    2ea4:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <vTaskDelay>
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
    2ea8:	40 e0       	ldi	r20, 0x00	; 0
    2eaa:	50 e0       	ldi	r21, 0x00	; 0
    2eac:	ba 01       	movw	r22, r20
    2eae:	80 91 45 30 	lds	r24, 0x3045	; 0x803045 <egDisplayTiming>
    2eb2:	90 91 46 30 	lds	r25, 0x3046	; 0x803046 <egDisplayTiming+0x1>
    2eb6:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
    2eba:	67 2b       	or	r22, r23
    2ebc:	68 2b       	or	r22, r24
    2ebe:	69 2b       	or	r22, r25
    2ec0:	09 f4       	brne	.+2      	; 0x2ec4 <vDisplayUpdateTask+0xee>
    2ec2:	49 c0       	rjmp	.+146    	; 0x2f56 <vDisplayUpdateTask+0x180>
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2ec4:	42 e0       	ldi	r20, 0x02	; 2
    2ec6:	50 e0       	ldi	r21, 0x00	; 0
    2ec8:	60 e0       	ldi	r22, 0x00	; 0
    2eca:	70 e0       	ldi	r23, 0x00	; 0
    2ecc:	80 91 45 30 	lds	r24, 0x3045	; 0x803045 <egDisplayTiming>
    2ed0:	90 91 46 30 	lds	r25, 0x3046	; 0x803046 <egDisplayTiming+0x1>
    2ed4:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
    2ed8:	fe 01       	movw	r30, r28
    2eda:	31 96       	adiw	r30, 0x01	; 1
    2edc:	08 c0       	rjmp	.+16     	; 0x2eee <vDisplayUpdateTask+0x118>
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2ede:	11 93       	st	Z+, r17
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
    2ee0:	e8 17       	cp	r30, r24
    2ee2:	f9 07       	cpc	r31, r25
    2ee4:	e1 f7       	brne	.-8      	; 0x2ede <vDisplayUpdateTask+0x108>
    2ee6:	fc 01       	movw	r30, r24
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
    2ee8:	8a 15       	cp	r24, r10
    2eea:	9b 05       	cpc	r25, r11
    2eec:	a1 f1       	breq	.+104    	; 0x2f56 <vDisplayUpdateTask+0x180>
    2eee:	cf 01       	movw	r24, r30
    2ef0:	44 96       	adiw	r24, 0x14	; 20
    2ef2:	f5 cf       	rjmp	.-22     	; 0x2ede <vDisplayUpdateTask+0x108>
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2ef4:	2f ef       	ldi	r18, 0xFF	; 255
    2ef6:	3f ef       	ldi	r19, 0xFF	; 255
    2ef8:	a9 01       	movw	r20, r18
    2efa:	65 2d       	mov	r22, r5
    2efc:	70 2f       	mov	r23, r16
    2efe:	80 91 43 30 	lds	r24, 0x3043	; 0x803043 <displayLineQueue>
    2f02:	90 91 44 30 	lds	r25, 0x3044	; 0x803044 <displayLineQueue+0x1>
    2f06:	0e 94 c8 08 	call	0x1190	; 0x1190 <xQueueReceive>
    2f0a:	88 23       	and	r24, r24
    2f0c:	21 f1       	breq	.+72     	; 0x2f56 <vDisplayUpdateTask+0x180>
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2f0e:	f6 01       	movw	r30, r12
    2f10:	21 81       	ldd	r18, Z+1	; 0x01
    2f12:	82 2f       	mov	r24, r18
    2f14:	90 e0       	ldi	r25, 0x00	; 0
    2f16:	44 97       	sbiw	r24, 0x14	; 20
    2f18:	f4 f4       	brge	.+60     	; 0x2f56 <vDisplayUpdateTask+0x180>
    2f1a:	82 81       	ldd	r24, Z+2	; 0x02
    2f1c:	88 23       	and	r24, r24
    2f1e:	d9 f0       	breq	.+54     	; 0x2f56 <vDisplayUpdateTask+0x180>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
    2f20:	90 81       	ld	r25, Z
    2f22:	30 e0       	ldi	r19, 0x00	; 0
    2f24:	d9 01       	movw	r26, r18
    2f26:	49 9e       	mul	r4, r25
    2f28:	a0 0d       	add	r26, r0
    2f2a:	b1 1d       	adc	r27, r1
    2f2c:	11 24       	eor	r1, r1
    2f2e:	41 e0       	ldi	r20, 0x01	; 1
    2f30:	50 e0       	ldi	r21, 0x00	; 0
    2f32:	4c 0f       	add	r20, r28
    2f34:	5d 1f       	adc	r21, r29
    2f36:	a4 0f       	add	r26, r20
    2f38:	b5 1f       	adc	r27, r21
    2f3a:	33 96       	adiw	r30, 0x03	; 3
    2f3c:	a4 01       	movw	r20, r8
    2f3e:	42 1b       	sub	r20, r18
    2f40:	53 0b       	sbc	r21, r19
    2f42:	9a 01       	movw	r18, r20
    2f44:	2c 0d       	add	r18, r12
    2f46:	3d 1d       	adc	r19, r13
    2f48:	8d 93       	st	X+, r24
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2f4a:	e2 17       	cp	r30, r18
    2f4c:	f3 07       	cpc	r31, r19
    2f4e:	19 f0       	breq	.+6      	; 0x2f56 <vDisplayUpdateTask+0x180>
    2f50:	81 91       	ld	r24, Z+
    2f52:	81 11       	cpse	r24, r1
    2f54:	f9 cf       	rjmp	.-14     	; 0x2f48 <vDisplayUpdateTask+0x172>
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
    2f56:	80 91 43 30 	lds	r24, 0x3043	; 0x803043 <displayLineQueue>
    2f5a:	90 91 44 30 	lds	r25, 0x3044	; 0x803044 <displayLineQueue+0x1>
    2f5e:	0e 94 6e 09 	call	0x12dc	; 0x12dc <uxQueueMessagesWaiting>
    2f62:	81 11       	cpse	r24, r1
    2f64:	c7 cf       	rjmp	.-114    	; 0x2ef4 <vDisplayUpdateTask+0x11e>
    2f66:	ce 01       	movw	r24, r28
    2f68:	01 96       	adiw	r24, 0x01	; 1
    2f6a:	7c 01       	movw	r14, r24
    2f6c:	61 2c       	mov	r6, r1
    2f6e:	71 2c       	mov	r7, r1
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
			 _displayWriteStringAtPos(i,0,&displayLines[i][0]);
    2f70:	a7 01       	movw	r20, r14
    2f72:	60 e0       	ldi	r22, 0x00	; 0
    2f74:	70 e0       	ldi	r23, 0x00	; 0
    2f76:	c3 01       	movw	r24, r6
    2f78:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <_displayWriteStringAtPos>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
    2f7c:	9f ef       	ldi	r25, 0xFF	; 255
    2f7e:	69 1a       	sub	r6, r25
    2f80:	79 0a       	sbc	r7, r25
    2f82:	e4 e1       	ldi	r30, 0x14	; 20
    2f84:	ee 0e       	add	r14, r30
    2f86:	f1 1c       	adc	r15, r1
    2f88:	f4 e0       	ldi	r31, 0x04	; 4
    2f8a:	6f 16       	cp	r6, r31
    2f8c:	71 04       	cpc	r7, r1
    2f8e:	81 f7       	brne	.-32     	; 0x2f70 <vDisplayUpdateTask+0x19a>
    2f90:	85 cf       	rjmp	.-246    	; 0x2e9c <vDisplayUpdateTask+0xc6>

00002f92 <vDisplayClear>:
	 }
 }
 

void vDisplayClear() {
	xEventGroupSetBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2f92:	42 e0       	ldi	r20, 0x02	; 2
    2f94:	50 e0       	ldi	r21, 0x00	; 0
    2f96:	60 e0       	ldi	r22, 0x00	; 0
    2f98:	70 e0       	ldi	r23, 0x00	; 0
    2f9a:	80 91 45 30 	lds	r24, 0x3045	; 0x803045 <egDisplayTiming>
    2f9e:	90 91 46 30 	lds	r25, 0x3046	; 0x803046 <egDisplayTiming+0x1>
    2fa2:	0e 94 80 03 	call	0x700	; 0x700 <xEventGroupSetBits>
    2fa6:	08 95       	ret

00002fa8 <vDisplayWriteStringAtPos>:
}

void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
    2fa8:	2f 92       	push	r2
    2faa:	3f 92       	push	r3
    2fac:	4f 92       	push	r4
    2fae:	5f 92       	push	r5
    2fb0:	6f 92       	push	r6
    2fb2:	7f 92       	push	r7
    2fb4:	8f 92       	push	r8
    2fb6:	9f 92       	push	r9
    2fb8:	af 92       	push	r10
    2fba:	bf 92       	push	r11
    2fbc:	cf 92       	push	r12
    2fbe:	df 92       	push	r13
    2fc0:	ef 92       	push	r14
    2fc2:	ff 92       	push	r15
    2fc4:	0f 93       	push	r16
    2fc6:	1f 93       	push	r17
    2fc8:	cf 93       	push	r28
    2fca:	df 93       	push	r29
    2fcc:	cd b7       	in	r28, 0x3d	; 61
    2fce:	de b7       	in	r29, 0x3e	; 62
    2fd0:	6d 97       	sbiw	r28, 0x1d	; 29
    2fd2:	cd bf       	out	0x3d, r28	; 61
    2fd4:	de bf       	out	0x3e, r29	; 62
    2fd6:	2b a9       	ldd	r18, Y+51	; 0x33
    2fd8:	2b 8f       	std	Y+27, r18	; 0x1b
    2fda:	af a9       	ldd	r26, Y+55	; 0x37
    2fdc:	b8 ad       	ldd	r27, Y+56	; 0x38
	va_list arg;	
	va_start(arg, fmt);
    2fde:	7e 01       	movw	r14, r28
    2fe0:	39 e3       	ldi	r19, 0x39	; 57
    2fe2:	e3 0e       	add	r14, r19
    2fe4:	f1 1c       	adc	r15, r1
    2fe6:	2a e3       	ldi	r18, 0x3A	; 58
    2fe8:	3f e2       	ldi	r19, 0x2F	; 47
	display_vprintf(line, pos, fmt, arg);
    2fea:	e6 e2       	ldi	r30, 0x26	; 38
    2fec:	ff e2       	ldi	r31, 0x2F	; 47
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
    2fee:	11 92       	st	Z+, r1
	char ch;
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
    2ff0:	e2 17       	cp	r30, r18
    2ff2:	f3 07       	cpc	r31, r19
    2ff4:	e1 f7       	brne	.-8      	; 0x2fee <vDisplayWriteStringAtPos+0x46>
    2ff6:	0f 2e       	mov	r0, r31
    2ff8:	f2 e1       	ldi	r31, 0x12	; 18
    2ffa:	af 2e       	mov	r10, r31
    2ffc:	ff e2       	ldi	r31, 0x2F	; 47
    2ffe:	bf 2e       	mov	r11, r31
    3000:	f0 2d       	mov	r31, r0
    3002:	26 e2       	ldi	r18, 0x26	; 38
    3004:	3f e2       	ldi	r19, 0x2F	; 47
    3006:	f5 01       	movw	r30, r10
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
    3008:	11 92       	st	Z+, r1
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    300a:	e2 17       	cp	r30, r18
    300c:	f3 07       	cpc	r31, r19
    300e:	e1 f7       	brne	.-8      	; 0x3008 <vDisplayWriteStringAtPos+0x60>
    3010:	81 2c       	mov	r8, r1
    3012:	91 2c       	mov	r9, r1
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    3014:	0f 2e       	mov	r0, r31
    3016:	f6 e2       	ldi	r31, 0x26	; 38
    3018:	cf 2e       	mov	r12, r31
    301a:	ff e2       	ldi	r31, 0x2F	; 47
    301c:	df 2e       	mov	r13, r31
    301e:	f0 2d       	mov	r31, r0
    3020:	fc c2       	rjmp	.+1528   	; 0x361a <vDisplayWriteStringAtPos+0x672>
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
    3022:	85 32       	cpi	r24, 0x25	; 37
    3024:	09 f0       	breq	.+2      	; 0x3028 <vDisplayWriteStringAtPos+0x80>
    3026:	e8 c2       	rjmp	.+1488   	; 0x35f8 <vDisplayWriteStringAtPos+0x650>
			switch (ch = *fmt++) {
    3028:	2d 01       	movw	r4, r26
    302a:	82 e0       	ldi	r24, 0x02	; 2
    302c:	48 0e       	add	r4, r24
    302e:	51 1c       	adc	r5, r1
    3030:	11 96       	adiw	r26, 0x01	; 1
    3032:	8c 91       	ld	r24, X
    3034:	85 36       	cpi	r24, 0x65	; 101
    3036:	09 f4       	brne	.+2      	; 0x303a <vDisplayWriteStringAtPos+0x92>
    3038:	db c1       	rjmp	.+950    	; 0x33f0 <vDisplayWriteStringAtPos+0x448>
    303a:	38 f4       	brcc	.+14     	; 0x304a <vDisplayWriteStringAtPos+0xa2>
    303c:	83 36       	cpi	r24, 0x63	; 99
    303e:	c1 f0       	breq	.+48     	; 0x3070 <vDisplayWriteStringAtPos+0xc8>
    3040:	08 f0       	brcs	.+2      	; 0x3044 <vDisplayWriteStringAtPos+0x9c>
    3042:	48 c0       	rjmp	.+144    	; 0x30d4 <vDisplayWriteStringAtPos+0x12c>
    3044:	85 32       	cpi	r24, 0x25	; 37
    3046:	51 f0       	breq	.+20     	; 0x305c <vDisplayWriteStringAtPos+0xb4>
    3048:	e7 c2       	rjmp	.+1486   	; 0x3618 <vDisplayWriteStringAtPos+0x670>
    304a:	83 37       	cpi	r24, 0x73	; 115
    304c:	f9 f0       	breq	.+62     	; 0x308c <vDisplayWriteStringAtPos+0xe4>
    304e:	88 37       	cpi	r24, 0x78	; 120
    3050:	09 f4       	brne	.+2      	; 0x3054 <vDisplayWriteStringAtPos+0xac>
    3052:	68 c0       	rjmp	.+208    	; 0x3124 <vDisplayWriteStringAtPos+0x17c>
    3054:	86 36       	cpi	r24, 0x66	; 102
    3056:	09 f0       	breq	.+2      	; 0x305a <vDisplayWriteStringAtPos+0xb2>
    3058:	df c2       	rjmp	.+1470   	; 0x3618 <vDisplayWriteStringAtPos+0x670>
    305a:	8c c0       	rjmp	.+280    	; 0x3174 <vDisplayWriteStringAtPos+0x1cc>
				/* %% - print out a single %    */
				case '%':
				str[length] = '%';
    305c:	f4 01       	movw	r30, r8
    305e:	ee 5e       	subi	r30, 0xEE	; 238
    3060:	f0 4d       	sbci	r31, 0xD0	; 208
    3062:	95 e2       	ldi	r25, 0x25	; 37
    3064:	90 83       	st	Z, r25
				length++;
    3066:	af ef       	ldi	r26, 0xFF	; 255
    3068:	8a 1a       	sub	r8, r26
    306a:	9a 0a       	sbc	r9, r26
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    306c:	d2 01       	movw	r26, r4
    306e:	d5 c2       	rjmp	.+1450   	; 0x361a <vDisplayWriteStringAtPos+0x672>
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
				str[length] = char_temp;
    3070:	f4 01       	movw	r30, r8
    3072:	ee 5e       	subi	r30, 0xEE	; 238
    3074:	f0 4d       	sbci	r31, 0xD0	; 208
    3076:	d7 01       	movw	r26, r14
    3078:	8c 91       	ld	r24, X
    307a:	80 83       	st	Z, r24
				length++;
    307c:	bf ef       	ldi	r27, 0xFF	; 255
    307e:	8b 1a       	sub	r8, r27
    3080:	9b 0a       	sbc	r9, r27
				length++;
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
    3082:	f7 01       	movw	r30, r14
    3084:	32 96       	adiw	r30, 0x02	; 2
    3086:	7f 01       	movw	r14, r30
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3088:	d2 01       	movw	r26, r4
    308a:	c7 c2       	rjmp	.+1422   	; 0x361a <vDisplayWriteStringAtPos+0x672>
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    308c:	a7 01       	movw	r20, r14
    308e:	4e 5f       	subi	r20, 0xFE	; 254
    3090:	5f 4f       	sbci	r21, 0xFF	; 255
    3092:	d7 01       	movw	r26, r14
    3094:	8d 91       	ld	r24, X+
    3096:	9c 91       	ld	r25, X
    3098:	9c 01       	movw	r18, r24
    309a:	b4 01       	movw	r22, r8
    309c:	f4 01       	movw	r30, r8
    309e:	ee 5e       	subi	r30, 0xEE	; 238
    30a0:	f0 4d       	sbci	r31, 0xD0	; 208
				for(int i = 0; i < strlen(string_temp);i++) {
    30a2:	00 e0       	ldi	r16, 0x00	; 0
    30a4:	10 e0       	ldi	r17, 0x00	; 0
    30a6:	06 c0       	rjmp	.+12     	; 0x30b4 <vDisplayWriteStringAtPos+0x10c>
					str[length+i] = string_temp[i];
    30a8:	d9 01       	movw	r26, r18
    30aa:	fd 90       	ld	r15, X+
    30ac:	9d 01       	movw	r18, r26
    30ae:	f1 92       	st	Z+, r15
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
				for(int i = 0; i < strlen(string_temp);i++) {
    30b0:	0f 5f       	subi	r16, 0xFF	; 255
    30b2:	1f 4f       	sbci	r17, 0xFF	; 255
    30b4:	dc 01       	movw	r26, r24
    30b6:	0d 90       	ld	r0, X+
    30b8:	00 20       	and	r0, r0
    30ba:	e9 f7       	brne	.-6      	; 0x30b6 <vDisplayWriteStringAtPos+0x10e>
    30bc:	11 97       	sbiw	r26, 0x01	; 1
    30be:	a8 1b       	sub	r26, r24
    30c0:	b9 0b       	sbc	r27, r25
    30c2:	0a 17       	cp	r16, r26
    30c4:	1b 07       	cpc	r17, r27
    30c6:	80 f3       	brcs	.-32     	; 0x30a8 <vDisplayWriteStringAtPos+0x100>
					str[length+i] = string_temp[i];
				}
				length += strlen(string_temp);
    30c8:	4d 01       	movw	r8, r26
    30ca:	86 0e       	add	r8, r22
    30cc:	97 1e       	adc	r9, r23
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    30ce:	7a 01       	movw	r14, r20
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    30d0:	d2 01       	movw	r26, r4
    30d2:	a3 c2       	rjmp	.+1350   	; 0x361a <vDisplayWriteStringAtPos+0x672>
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    30d4:	87 01       	movw	r16, r14
    30d6:	0e 5f       	subi	r16, 0xFE	; 254
    30d8:	1f 4f       	sbci	r17, 0xFF	; 255
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    30da:	4a e0       	ldi	r20, 0x0A	; 10
    30dc:	b6 01       	movw	r22, r12
    30de:	f7 01       	movw	r30, r14
    30e0:	80 81       	ld	r24, Z
    30e2:	91 81       	ldd	r25, Z+1	; 0x01
    30e4:	0e 94 ca 21 	call	0x4394	; 0x4394 <__itoa_ncheck>
    30e8:	94 01       	movw	r18, r8
    30ea:	d4 01       	movw	r26, r8
    30ec:	ae 5e       	subi	r26, 0xEE	; 238
    30ee:	b0 4d       	sbci	r27, 0xD0	; 208
    30f0:	46 e2       	ldi	r20, 0x26	; 38
    30f2:	5f e2       	ldi	r21, 0x2F	; 47
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    30f4:	80 e0       	ldi	r24, 0x00	; 0
    30f6:	90 e0       	ldi	r25, 0x00	; 0
    30f8:	05 c0       	rjmp	.+10     	; 0x3104 <vDisplayWriteStringAtPos+0x15c>
					str[length+i] = buffer[i];
    30fa:	fa 01       	movw	r30, r20
    30fc:	61 91       	ld	r22, Z+
    30fe:	af 01       	movw	r20, r30
    3100:	6d 93       	st	X+, r22

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    3102:	01 96       	adiw	r24, 0x01	; 1
    3104:	f6 01       	movw	r30, r12
    3106:	01 90       	ld	r0, Z+
    3108:	00 20       	and	r0, r0
    310a:	e9 f7       	brne	.-6      	; 0x3106 <vDisplayWriteStringAtPos+0x15e>
    310c:	31 97       	sbiw	r30, 0x01	; 1
    310e:	e6 52       	subi	r30, 0x26	; 38
    3110:	ff 42       	sbci	r31, 0x2F	; 47
    3112:	8e 17       	cp	r24, r30
    3114:	9f 07       	cpc	r25, r31
    3116:	88 f3       	brcs	.-30     	; 0x30fa <vDisplayWriteStringAtPos+0x152>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    3118:	4f 01       	movw	r8, r30
    311a:	82 0e       	add	r8, r18
    311c:	93 1e       	adc	r9, r19
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    311e:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3120:	d2 01       	movw	r26, r4
    3122:	7b c2       	rjmp	.+1270   	; 0x361a <vDisplayWriteStringAtPos+0x672>
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    3124:	87 01       	movw	r16, r14
    3126:	0e 5f       	subi	r16, 0xFE	; 254
    3128:	1f 4f       	sbci	r17, 0xFF	; 255
    312a:	40 e1       	ldi	r20, 0x10	; 16
    312c:	b6 01       	movw	r22, r12
    312e:	d7 01       	movw	r26, r14
    3130:	8d 91       	ld	r24, X+
    3132:	9c 91       	ld	r25, X
    3134:	0e 94 ca 21 	call	0x4394	; 0x4394 <__itoa_ncheck>
    3138:	94 01       	movw	r18, r8
    313a:	f4 01       	movw	r30, r8
    313c:	ee 5e       	subi	r30, 0xEE	; 238
    313e:	f0 4d       	sbci	r31, 0xD0	; 208
    3140:	46 e2       	ldi	r20, 0x26	; 38
    3142:	5f e2       	ldi	r21, 0x2F	; 47
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    3144:	80 e0       	ldi	r24, 0x00	; 0
    3146:	90 e0       	ldi	r25, 0x00	; 0
    3148:	05 c0       	rjmp	.+10     	; 0x3154 <vDisplayWriteStringAtPos+0x1ac>
					str[length+i] = buffer[i];
    314a:	da 01       	movw	r26, r20
    314c:	6d 91       	ld	r22, X+
    314e:	ad 01       	movw	r20, r26
    3150:	61 93       	st	Z+, r22

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    3152:	01 96       	adiw	r24, 0x01	; 1
    3154:	d6 01       	movw	r26, r12
    3156:	0d 90       	ld	r0, X+
    3158:	00 20       	and	r0, r0
    315a:	e9 f7       	brne	.-6      	; 0x3156 <vDisplayWriteStringAtPos+0x1ae>
    315c:	11 97       	sbiw	r26, 0x01	; 1
    315e:	a6 52       	subi	r26, 0x26	; 38
    3160:	bf 42       	sbci	r27, 0x2F	; 47
    3162:	8a 17       	cp	r24, r26
    3164:	9b 07       	cpc	r25, r27
    3166:	88 f3       	brcs	.-30     	; 0x314a <vDisplayWriteStringAtPos+0x1a2>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    3168:	4d 01       	movw	r8, r26
    316a:	82 0e       	add	r8, r18
    316c:	93 1e       	adc	r9, r19
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    316e:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3170:	d2 01       	movw	r26, r4
    3172:	53 c2       	rjmp	.+1190   	; 0x361a <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    3174:	17 01       	movw	r2, r14
    3176:	b4 e0       	ldi	r27, 0x04	; 4
    3178:	2b 0e       	add	r2, r27
    317a:	31 1c       	adc	r3, r1
    317c:	d7 01       	movw	r26, r14
    317e:	8d 91       	ld	r24, X+
    3180:	9d 91       	ld	r25, X+
    3182:	0d 90       	ld	r0, X+
    3184:	bc 91       	ld	r27, X
    3186:	a0 2d       	mov	r26, r0
    3188:	8f 8b       	std	Y+23, r24	; 0x17
    318a:	98 8f       	std	Y+24, r25	; 0x18
    318c:	a9 8f       	std	Y+25, r26	; 0x19
    318e:	ba 8f       	std	Y+26, r27	; 0x1a

    int exponent = 0;
    int places = 0;
    static const int width = 4;

    if (value == 0.0) {
    3190:	20 e0       	ldi	r18, 0x00	; 0
    3192:	30 e0       	ldi	r19, 0x00	; 0
    3194:	a9 01       	movw	r20, r18
    3196:	bc 01       	movw	r22, r24
    3198:	cd 01       	movw	r24, r26
    319a:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <__cmpsf2>
    319e:	81 11       	cpse	r24, r1
    31a0:	05 c0       	rjmp	.+10     	; 0x31ac <vDisplayWriteStringAtPos+0x204>
        buffer[0] = '0';
    31a2:	20 e3       	ldi	r18, 0x30	; 48
    31a4:	f6 01       	movw	r30, r12
    31a6:	20 83       	st	Z, r18
        buffer[1] = '\0';
    31a8:	11 82       	std	Z+1, r1	; 0x01
    31aa:	04 c1       	rjmp	.+520    	; 0x33b4 <vDisplayWriteStringAtPos+0x40c>
        return;
    }         

    if (value < 0.0) {
    31ac:	20 e0       	ldi	r18, 0x00	; 0
    31ae:	30 e0       	ldi	r19, 0x00	; 0
    31b0:	a9 01       	movw	r20, r18
    31b2:	6f 89       	ldd	r22, Y+23	; 0x17
    31b4:	78 8d       	ldd	r23, Y+24	; 0x18
    31b6:	89 8d       	ldd	r24, Y+25	; 0x19
    31b8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    31ba:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <__cmpsf2>
    31be:	88 23       	and	r24, r24
    31c0:	9c f4       	brge	.+38     	; 0x31e8 <vDisplayWriteStringAtPos+0x240>
        *buffer++ = '-';
    31c2:	ed e2       	ldi	r30, 0x2D	; 45
    31c4:	d6 01       	movw	r26, r12
    31c6:	ec 93       	st	X, r30
        value = -value;
    31c8:	8f 89       	ldd	r24, Y+23	; 0x17
    31ca:	98 8d       	ldd	r25, Y+24	; 0x18
    31cc:	a9 8d       	ldd	r26, Y+25	; 0x19
    31ce:	ba 8d       	ldd	r27, Y+26	; 0x1a
    31d0:	b0 58       	subi	r27, 0x80	; 128
    31d2:	8f 8b       	std	Y+23, r24	; 0x17
    31d4:	98 8f       	std	Y+24, r25	; 0x18
    31d6:	a9 8f       	std	Y+25, r26	; 0x19
    31d8:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
        *buffer++ = '-';
    31da:	0f 2e       	mov	r0, r31
    31dc:	f7 e2       	ldi	r31, 0x27	; 39
    31de:	6f 2e       	mov	r6, r31
    31e0:	ff e2       	ldi	r31, 0x2F	; 47
    31e2:	7f 2e       	mov	r7, r31
    31e4:	f0 2d       	mov	r31, r0
    31e6:	01 c0       	rjmp	.+2      	; 0x31ea <vDisplayWriteStringAtPos+0x242>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
    31e8:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    31ea:	20 e0       	ldi	r18, 0x00	; 0
    31ec:	30 e0       	ldi	r19, 0x00	; 0
    31ee:	40 e8       	ldi	r20, 0x80	; 128
    31f0:	5f e3       	ldi	r21, 0x3F	; 63
    31f2:	6f 89       	ldd	r22, Y+23	; 0x17
    31f4:	78 8d       	ldd	r23, Y+24	; 0x18
    31f6:	89 8d       	ldd	r24, Y+25	; 0x19
    31f8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    31fa:	0e 94 40 21 	call	0x4280	; 0x4280 <__gesf2>
    31fe:	88 23       	and	r24, r24
    3200:	0c f4       	brge	.+2      	; 0x3204 <vDisplayWriteStringAtPos+0x25c>
    3202:	44 c2       	rjmp	.+1160   	; 0x368c <vDisplayWriteStringAtPos+0x6e4>
    3204:	00 e0       	ldi	r16, 0x00	; 0
    3206:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    3208:	20 e0       	ldi	r18, 0x00	; 0
    320a:	30 e0       	ldi	r19, 0x00	; 0
    320c:	40 e2       	ldi	r20, 0x20	; 32
    320e:	51 e4       	ldi	r21, 0x41	; 65
    3210:	6f 89       	ldd	r22, Y+23	; 0x17
    3212:	78 8d       	ldd	r23, Y+24	; 0x18
    3214:	89 8d       	ldd	r24, Y+25	; 0x19
    3216:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3218:	0e 94 e6 1f 	call	0x3fcc	; 0x3fcc <__divsf3>
    321c:	6f 8b       	std	Y+23, r22	; 0x17
    321e:	78 8f       	std	Y+24, r23	; 0x18
    3220:	89 8f       	std	Y+25, r24	; 0x19
    3222:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    3224:	0f 5f       	subi	r16, 0xFF	; 255
    3226:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3228:	20 e0       	ldi	r18, 0x00	; 0
    322a:	30 e0       	ldi	r19, 0x00	; 0
    322c:	40 e8       	ldi	r20, 0x80	; 128
    322e:	5f e3       	ldi	r21, 0x3F	; 63
    3230:	0e 94 40 21 	call	0x4280	; 0x4280 <__gesf2>
    3234:	88 23       	and	r24, r24
    3236:	44 f7       	brge	.-48     	; 0x3208 <vDisplayWriteStringAtPos+0x260>
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3238:	2d ec       	ldi	r18, 0xCD	; 205
    323a:	3c ec       	ldi	r19, 0xCC	; 204
    323c:	4c ec       	ldi	r20, 0xCC	; 204
    323e:	5d e3       	ldi	r21, 0x3D	; 61
    3240:	6f 89       	ldd	r22, Y+23	; 0x17
    3242:	78 8d       	ldd	r23, Y+24	; 0x18
    3244:	89 8d       	ldd	r24, Y+25	; 0x19
    3246:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3248:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <__cmpsf2>
    324c:	88 23       	and	r24, r24
    324e:	1c f0       	brlt	.+6      	; 0x3256 <vDisplayWriteStringAtPos+0x2ae>
    3250:	1a c0       	rjmp	.+52     	; 0x3286 <vDisplayWriteStringAtPos+0x2de>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    3252:	00 e0       	ldi	r16, 0x00	; 0
    3254:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
        value *= 10.0;
    3256:	20 e0       	ldi	r18, 0x00	; 0
    3258:	30 e0       	ldi	r19, 0x00	; 0
    325a:	40 e2       	ldi	r20, 0x20	; 32
    325c:	51 e4       	ldi	r21, 0x41	; 65
    325e:	6f 89       	ldd	r22, Y+23	; 0x17
    3260:	78 8d       	ldd	r23, Y+24	; 0x18
    3262:	89 8d       	ldd	r24, Y+25	; 0x19
    3264:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3266:	0e 94 45 21 	call	0x428a	; 0x428a <__mulsf3>
    326a:	6f 8b       	std	Y+23, r22	; 0x17
    326c:	78 8f       	std	Y+24, r23	; 0x18
    326e:	89 8f       	std	Y+25, r24	; 0x19
    3270:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    3272:	01 50       	subi	r16, 0x01	; 1
    3274:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3276:	2d ec       	ldi	r18, 0xCD	; 205
    3278:	3c ec       	ldi	r19, 0xCC	; 204
    327a:	4c ec       	ldi	r20, 0xCC	; 204
    327c:	5d e3       	ldi	r21, 0x3D	; 61
    327e:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <__cmpsf2>
    3282:	88 23       	and	r24, r24
    3284:	44 f3       	brlt	.-48     	; 0x3256 <vDisplayWriteStringAtPos+0x2ae>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    3286:	10 16       	cp	r1, r16
    3288:	11 06       	cpc	r1, r17
    328a:	ac f5       	brge	.+106    	; 0x32f6 <vDisplayWriteStringAtPos+0x34e>
    328c:	73 01       	movw	r14, r6
    328e:	d3 01       	movw	r26, r6
    3290:	a0 0f       	add	r26, r16
    3292:	b1 1f       	adc	r27, r17
    3294:	ac 8f       	std	Y+28, r26	; 0x1c
    3296:	bd 8f       	std	Y+29, r27	; 0x1d
    3298:	3d 01       	movw	r6, r26
    329a:	6f 89       	ldd	r22, Y+23	; 0x17
    329c:	78 8d       	ldd	r23, Y+24	; 0x18
    329e:	89 8d       	ldd	r24, Y+25	; 0x19
    32a0:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10;
    32a2:	20 e0       	ldi	r18, 0x00	; 0
    32a4:	30 e0       	ldi	r19, 0x00	; 0
    32a6:	40 e2       	ldi	r20, 0x20	; 32
    32a8:	51 e4       	ldi	r21, 0x41	; 65
    32aa:	0e 94 45 21 	call	0x428a	; 0x428a <__mulsf3>
    32ae:	6f 8b       	std	Y+23, r22	; 0x17
    32b0:	78 8f       	std	Y+24, r23	; 0x18
    32b2:	89 8f       	std	Y+25, r24	; 0x19
    32b4:	9a 8f       	std	Y+26, r25	; 0x1a
    32b6:	0e 94 58 20 	call	0x40b0	; 0x40b0 <__fixsfsi>
        *buffer++ = digit + '0';
    32ba:	20 e3       	ldi	r18, 0x30	; 48
    32bc:	26 0f       	add	r18, r22
    32be:	f7 01       	movw	r30, r14
    32c0:	21 93       	st	Z+, r18
    32c2:	7f 01       	movw	r14, r30
        value = value * 10 - digit;
    32c4:	07 2e       	mov	r0, r23
    32c6:	00 0c       	add	r0, r0
    32c8:	88 0b       	sbc	r24, r24
    32ca:	99 0b       	sbc	r25, r25
    32cc:	0e 94 90 20 	call	0x4120	; 0x4120 <__floatsisf>
    32d0:	9b 01       	movw	r18, r22
    32d2:	ac 01       	movw	r20, r24
    32d4:	6f 89       	ldd	r22, Y+23	; 0x17
    32d6:	78 8d       	ldd	r23, Y+24	; 0x18
    32d8:	89 8d       	ldd	r24, Y+25	; 0x19
    32da:	9a 8d       	ldd	r25, Y+26	; 0x1a
    32dc:	0e 94 74 1f 	call	0x3ee8	; 0x3ee8 <__subsf3>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    32e0:	e6 14       	cp	r14, r6
    32e2:	f7 04       	cpc	r15, r7
    32e4:	f1 f6       	brne	.-68     	; 0x32a2 <vDisplayWriteStringAtPos+0x2fa>
    32e6:	6f 8b       	std	Y+23, r22	; 0x17
    32e8:	78 8f       	std	Y+24, r23	; 0x18
    32ea:	89 8f       	std	Y+25, r24	; 0x19
    32ec:	9a 8f       	std	Y+26, r25	; 0x1a
        value = value * 10 - digit;
        ++places;
        --exponent;
    }

    if (places == 0)
    32ee:	01 15       	cp	r16, r1
    32f0:	11 05       	cpc	r17, r1
    32f2:	89 f4       	brne	.+34     	; 0x3316 <vDisplayWriteStringAtPos+0x36e>
    32f4:	db c1       	rjmp	.+950    	; 0x36ac <vDisplayWriteStringAtPos+0x704>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    32f6:	c8 01       	movw	r24, r16
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    32f8:	e0 e3       	ldi	r30, 0x30	; 48
    32fa:	d3 01       	movw	r26, r6
    32fc:	ec 93       	st	X, r30

    *buffer++ = '.';
    32fe:	73 01       	movw	r14, r6
    3300:	f2 e0       	ldi	r31, 0x02	; 2
    3302:	ef 0e       	add	r14, r31
    3304:	f1 1c       	adc	r15, r1
    3306:	2e e2       	ldi	r18, 0x2E	; 46
    3308:	11 96       	adiw	r26, 0x01	; 1
    330a:	2c 93       	st	X, r18

    while (exponent < 0 && places < width) {
    330c:	99 23       	and	r25, r25
    330e:	6c f0       	brlt	.+26     	; 0x332a <vDisplayWriteStringAtPos+0x382>
    3310:	00 e0       	ldi	r16, 0x00	; 0
    3312:	10 e0       	ldi	r17, 0x00	; 0
    3314:	1f c0       	rjmp	.+62     	; 0x3354 <vDisplayWriteStringAtPos+0x3ac>
    }

    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';
    3316:	ec 8c       	ldd	r14, Y+28	; 0x1c
    3318:	fd 8c       	ldd	r15, Y+29	; 0x1d
    331a:	3f ef       	ldi	r19, 0xFF	; 255
    331c:	e3 1a       	sub	r14, r19
    331e:	f3 0a       	sbc	r15, r19
    3320:	ee e2       	ldi	r30, 0x2E	; 46
    3322:	ac 8d       	ldd	r26, Y+28	; 0x1c
    3324:	bd 8d       	ldd	r27, Y+29	; 0x1d
    3326:	ec 93       	st	X, r30
    3328:	12 c0       	rjmp	.+36     	; 0x334e <vDisplayWriteStringAtPos+0x3a6>

    while (exponent < 0 && places < width) {
    332a:	00 e0       	ldi	r16, 0x00	; 0
    332c:	10 e0       	ldi	r17, 0x00	; 0
        *buffer++ = '0';
    332e:	ff ef       	ldi	r31, 0xFF	; 255
    3330:	ef 1a       	sub	r14, r31
    3332:	ff 0a       	sbc	r15, r31
    3334:	f7 01       	movw	r30, r14
    3336:	31 97       	sbiw	r30, 0x01	; 1
    3338:	20 e3       	ldi	r18, 0x30	; 48
    333a:	20 83       	st	Z, r18
        --exponent;
    333c:	01 97       	sbiw	r24, 0x01	; 1
        ++places;
    333e:	0f 5f       	subi	r16, 0xFF	; 255
    3340:	1f 4f       	sbci	r17, 0xFF	; 255
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    3342:	99 23       	and	r25, r25
    3344:	24 f4       	brge	.+8      	; 0x334e <vDisplayWriteStringAtPos+0x3a6>
    3346:	04 30       	cpi	r16, 0x04	; 4
    3348:	11 05       	cpc	r17, r1
    334a:	8c f3       	brlt	.-30     	; 0x332e <vDisplayWriteStringAtPos+0x386>
    334c:	31 c0       	rjmp	.+98     	; 0x33b0 <vDisplayWriteStringAtPos+0x408>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    334e:	04 30       	cpi	r16, 0x04	; 4
    3350:	11 05       	cpc	r17, r1
    3352:	74 f5       	brge	.+92     	; 0x33b0 <vDisplayWriteStringAtPos+0x408>
    3354:	37 01       	movw	r6, r14
    3356:	84 e0       	ldi	r24, 0x04	; 4
    3358:	90 e0       	ldi	r25, 0x00	; 0
    335a:	80 1b       	sub	r24, r16
    335c:	91 0b       	sbc	r25, r17
    335e:	e8 0e       	add	r14, r24
    3360:	f9 1e       	adc	r15, r25
    3362:	87 01       	movw	r16, r14
    3364:	6f 89       	ldd	r22, Y+23	; 0x17
    3366:	78 8d       	ldd	r23, Y+24	; 0x18
    3368:	89 8d       	ldd	r24, Y+25	; 0x19
    336a:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10.0;
    336c:	20 e0       	ldi	r18, 0x00	; 0
    336e:	30 e0       	ldi	r19, 0x00	; 0
    3370:	40 e2       	ldi	r20, 0x20	; 32
    3372:	51 e4       	ldi	r21, 0x41	; 65
    3374:	0e 94 45 21 	call	0x428a	; 0x428a <__mulsf3>
    3378:	6f 8b       	std	Y+23, r22	; 0x17
    337a:	78 8f       	std	Y+24, r23	; 0x18
    337c:	89 8f       	std	Y+25, r24	; 0x19
    337e:	9a 8f       	std	Y+26, r25	; 0x1a
    3380:	0e 94 58 20 	call	0x40b0	; 0x40b0 <__fixsfsi>
        *buffer++ = digit + '0';
    3384:	20 e3       	ldi	r18, 0x30	; 48
    3386:	26 0f       	add	r18, r22
    3388:	d3 01       	movw	r26, r6
    338a:	2d 93       	st	X+, r18
    338c:	3d 01       	movw	r6, r26
        value = value * 10.0 - digit;
    338e:	07 2e       	mov	r0, r23
    3390:	00 0c       	add	r0, r0
    3392:	88 0b       	sbc	r24, r24
    3394:	99 0b       	sbc	r25, r25
    3396:	0e 94 90 20 	call	0x4120	; 0x4120 <__floatsisf>
    339a:	9b 01       	movw	r18, r22
    339c:	ac 01       	movw	r20, r24
    339e:	6f 89       	ldd	r22, Y+23	; 0x17
    33a0:	78 8d       	ldd	r23, Y+24	; 0x18
    33a2:	89 8d       	ldd	r24, Y+25	; 0x19
    33a4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    33a6:	0e 94 74 1f 	call	0x3ee8	; 0x3ee8 <__subsf3>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    33aa:	60 16       	cp	r6, r16
    33ac:	71 06       	cpc	r7, r17
    33ae:	f1 f6       	brne	.-68     	; 0x336c <vDisplayWriteStringAtPos+0x3c4>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
        ++places;
    }
    *buffer = '\0';
    33b0:	f7 01       	movw	r30, r14
    33b2:	10 82       	st	Z, r1
    33b4:	94 01       	movw	r18, r8
    33b6:	f4 01       	movw	r30, r8
    33b8:	ee 5e       	subi	r30, 0xEE	; 238
    33ba:	f0 4d       	sbci	r31, 0xD0	; 208
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    33bc:	46 e2       	ldi	r20, 0x26	; 38
    33be:	5f e2       	ldi	r21, 0x2F	; 47
    33c0:	80 e0       	ldi	r24, 0x00	; 0
    33c2:	90 e0       	ldi	r25, 0x00	; 0
    33c4:	05 c0       	rjmp	.+10     	; 0x33d0 <vDisplayWriteStringAtPos+0x428>

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    33c6:	da 01       	movw	r26, r20
    33c8:	6d 91       	ld	r22, X+
    33ca:	ad 01       	movw	r20, r26
    33cc:	61 93       	st	Z+, r22
				break;

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    33ce:	01 96       	adiw	r24, 0x01	; 1
    33d0:	d6 01       	movw	r26, r12
    33d2:	0d 90       	ld	r0, X+
    33d4:	00 20       	and	r0, r0
    33d6:	e9 f7       	brne	.-6      	; 0x33d2 <vDisplayWriteStringAtPos+0x42a>
    33d8:	11 97       	sbiw	r26, 0x01	; 1
    33da:	a6 52       	subi	r26, 0x26	; 38
    33dc:	bf 42       	sbci	r27, 0x2F	; 47
    33de:	8a 17       	cp	r24, r26
    33e0:	9b 07       	cpc	r25, r27
    33e2:	88 f3       	brcs	.-30     	; 0x33c6 <vDisplayWriteStringAtPos+0x41e>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    33e4:	4d 01       	movw	r8, r26
    33e6:	82 0e       	add	r8, r18
    33e8:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    33ea:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    33ec:	d2 01       	movw	r26, r4
    33ee:	15 c1       	rjmp	.+554    	; 0x361a <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    33f0:	17 01       	movw	r2, r14
    33f2:	b4 e0       	ldi	r27, 0x04	; 4
    33f4:	2b 0e       	add	r2, r27
    33f6:	31 1c       	adc	r3, r1
    33f8:	d7 01       	movw	r26, r14
    33fa:	8d 91       	ld	r24, X+
    33fc:	9d 91       	ld	r25, X+
    33fe:	0d 90       	ld	r0, X+
    3400:	bc 91       	ld	r27, X
    3402:	a0 2d       	mov	r26, r0
    3404:	8f 8b       	std	Y+23, r24	; 0x17
    3406:	98 8f       	std	Y+24, r25	; 0x18
    3408:	a9 8f       	std	Y+25, r26	; 0x19
    340a:	ba 8f       	std	Y+26, r27	; 0x1a

void ftoa_sci(char *buffer, double value) {
    int exponent = 0;    
    static const int width = 4;

    if (value == 0.0) {
    340c:	20 e0       	ldi	r18, 0x00	; 0
    340e:	30 e0       	ldi	r19, 0x00	; 0
    3410:	a9 01       	movw	r20, r18
    3412:	bc 01       	movw	r22, r24
    3414:	cd 01       	movw	r24, r26
    3416:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <__cmpsf2>
    341a:	81 11       	cpse	r24, r1
    341c:	05 c0       	rjmp	.+10     	; 0x3428 <vDisplayWriteStringAtPos+0x480>
        buffer[0] = '0';
    341e:	20 e3       	ldi	r18, 0x30	; 48
    3420:	f6 01       	movw	r30, r12
    3422:	20 83       	st	Z, r18
        buffer[1] = '\0';
    3424:	11 82       	std	Z+1, r1	; 0x01
    3426:	ca c0       	rjmp	.+404    	; 0x35bc <vDisplayWriteStringAtPos+0x614>
        return;
    }

    if (value < 0.0) {
    3428:	20 e0       	ldi	r18, 0x00	; 0
    342a:	30 e0       	ldi	r19, 0x00	; 0
    342c:	a9 01       	movw	r20, r18
    342e:	6f 89       	ldd	r22, Y+23	; 0x17
    3430:	78 8d       	ldd	r23, Y+24	; 0x18
    3432:	89 8d       	ldd	r24, Y+25	; 0x19
    3434:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3436:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <__cmpsf2>
    343a:	88 23       	and	r24, r24
    343c:	9c f4       	brge	.+38     	; 0x3464 <vDisplayWriteStringAtPos+0x4bc>
        *buffer++ = '-';
    343e:	ed e2       	ldi	r30, 0x2D	; 45
    3440:	d6 01       	movw	r26, r12
    3442:	ec 93       	st	X, r30
        value = -value;
    3444:	8f 89       	ldd	r24, Y+23	; 0x17
    3446:	98 8d       	ldd	r25, Y+24	; 0x18
    3448:	a9 8d       	ldd	r26, Y+25	; 0x19
    344a:	ba 8d       	ldd	r27, Y+26	; 0x1a
    344c:	b0 58       	subi	r27, 0x80	; 128
    344e:	8f 8b       	std	Y+23, r24	; 0x17
    3450:	98 8f       	std	Y+24, r25	; 0x18
    3452:	a9 8f       	std	Y+25, r26	; 0x19
    3454:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
        *buffer++ = '-';
    3456:	0f 2e       	mov	r0, r31
    3458:	f7 e2       	ldi	r31, 0x27	; 39
    345a:	6f 2e       	mov	r6, r31
    345c:	ff e2       	ldi	r31, 0x2F	; 47
    345e:	7f 2e       	mov	r7, r31
    3460:	f0 2d       	mov	r31, r0
    3462:	01 c0       	rjmp	.+2      	; 0x3466 <vDisplayWriteStringAtPos+0x4be>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
    3464:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3466:	20 e0       	ldi	r18, 0x00	; 0
    3468:	30 e0       	ldi	r19, 0x00	; 0
    346a:	40 e8       	ldi	r20, 0x80	; 128
    346c:	5f e3       	ldi	r21, 0x3F	; 63
    346e:	6f 89       	ldd	r22, Y+23	; 0x17
    3470:	78 8d       	ldd	r23, Y+24	; 0x18
    3472:	89 8d       	ldd	r24, Y+25	; 0x19
    3474:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3476:	0e 94 40 21 	call	0x4280	; 0x4280 <__gesf2>
    347a:	88 23       	and	r24, r24
    347c:	dc f0       	brlt	.+54     	; 0x34b4 <vDisplayWriteStringAtPos+0x50c>
    347e:	00 e0       	ldi	r16, 0x00	; 0
    3480:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    3482:	20 e0       	ldi	r18, 0x00	; 0
    3484:	30 e0       	ldi	r19, 0x00	; 0
    3486:	40 e2       	ldi	r20, 0x20	; 32
    3488:	51 e4       	ldi	r21, 0x41	; 65
    348a:	6f 89       	ldd	r22, Y+23	; 0x17
    348c:	78 8d       	ldd	r23, Y+24	; 0x18
    348e:	89 8d       	ldd	r24, Y+25	; 0x19
    3490:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3492:	0e 94 e6 1f 	call	0x3fcc	; 0x3fcc <__divsf3>
    3496:	6f 8b       	std	Y+23, r22	; 0x17
    3498:	78 8f       	std	Y+24, r23	; 0x18
    349a:	89 8f       	std	Y+25, r24	; 0x19
    349c:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    349e:	0f 5f       	subi	r16, 0xFF	; 255
    34a0:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    34a2:	20 e0       	ldi	r18, 0x00	; 0
    34a4:	30 e0       	ldi	r19, 0x00	; 0
    34a6:	40 e8       	ldi	r20, 0x80	; 128
    34a8:	5f e3       	ldi	r21, 0x3F	; 63
    34aa:	0e 94 40 21 	call	0x4280	; 0x4280 <__gesf2>
    34ae:	88 23       	and	r24, r24
    34b0:	44 f7       	brge	.-48     	; 0x3482 <vDisplayWriteStringAtPos+0x4da>
    34b2:	02 c0       	rjmp	.+4      	; 0x34b8 <vDisplayWriteStringAtPos+0x510>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    34b4:	00 e0       	ldi	r16, 0x00	; 0
    34b6:	10 e0       	ldi	r17, 0x00	; 0
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    34b8:	2d ec       	ldi	r18, 0xCD	; 205
    34ba:	3c ec       	ldi	r19, 0xCC	; 204
    34bc:	4c ec       	ldi	r20, 0xCC	; 204
    34be:	5d e3       	ldi	r21, 0x3D	; 61
    34c0:	6f 89       	ldd	r22, Y+23	; 0x17
    34c2:	78 8d       	ldd	r23, Y+24	; 0x18
    34c4:	89 8d       	ldd	r24, Y+25	; 0x19
    34c6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    34c8:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <__cmpsf2>
    34cc:	88 23       	and	r24, r24
    34ce:	c4 f4       	brge	.+48     	; 0x3500 <vDisplayWriteStringAtPos+0x558>
        value *= 10.0;
    34d0:	20 e0       	ldi	r18, 0x00	; 0
    34d2:	30 e0       	ldi	r19, 0x00	; 0
    34d4:	40 e2       	ldi	r20, 0x20	; 32
    34d6:	51 e4       	ldi	r21, 0x41	; 65
    34d8:	6f 89       	ldd	r22, Y+23	; 0x17
    34da:	78 8d       	ldd	r23, Y+24	; 0x18
    34dc:	89 8d       	ldd	r24, Y+25	; 0x19
    34de:	9a 8d       	ldd	r25, Y+26	; 0x1a
    34e0:	0e 94 45 21 	call	0x428a	; 0x428a <__mulsf3>
    34e4:	6f 8b       	std	Y+23, r22	; 0x17
    34e6:	78 8f       	std	Y+24, r23	; 0x18
    34e8:	89 8f       	std	Y+25, r24	; 0x19
    34ea:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    34ec:	01 50       	subi	r16, 0x01	; 1
    34ee:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    34f0:	2d ec       	ldi	r18, 0xCD	; 205
    34f2:	3c ec       	ldi	r19, 0xCC	; 204
    34f4:	4c ec       	ldi	r20, 0xCC	; 204
    34f6:	5d e3       	ldi	r21, 0x3D	; 61
    34f8:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <__cmpsf2>
    34fc:	88 23       	and	r24, r24
    34fe:	44 f3       	brlt	.-48     	; 0x34d0 <vDisplayWriteStringAtPos+0x528>
        value = -value;
    }

    exponent = normalize(&value);

    int digit = value * 10.0;
    3500:	20 e0       	ldi	r18, 0x00	; 0
    3502:	30 e0       	ldi	r19, 0x00	; 0
    3504:	40 e2       	ldi	r20, 0x20	; 32
    3506:	51 e4       	ldi	r21, 0x41	; 65
    3508:	6f 89       	ldd	r22, Y+23	; 0x17
    350a:	78 8d       	ldd	r23, Y+24	; 0x18
    350c:	89 8d       	ldd	r24, Y+25	; 0x19
    350e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3510:	0e 94 45 21 	call	0x428a	; 0x428a <__mulsf3>
    3514:	6f 8b       	std	Y+23, r22	; 0x17
    3516:	78 8f       	std	Y+24, r23	; 0x18
    3518:	89 8f       	std	Y+25, r24	; 0x19
    351a:	9a 8f       	std	Y+26, r25	; 0x1a
    351c:	0e 94 58 20 	call	0x40b0	; 0x40b0 <__fixsfsi>
    *buffer++ = digit + '0';
    3520:	20 e3       	ldi	r18, 0x30	; 48
    3522:	26 0f       	add	r18, r22
    3524:	d3 01       	movw	r26, r6
    3526:	2c 93       	st	X, r18
    value = value * 10.0 - digit;
    3528:	07 2e       	mov	r0, r23
    352a:	00 0c       	add	r0, r0
    352c:	88 0b       	sbc	r24, r24
    352e:	99 0b       	sbc	r25, r25
    3530:	0e 94 90 20 	call	0x4120	; 0x4120 <__floatsisf>
    3534:	9b 01       	movw	r18, r22
    3536:	ac 01       	movw	r20, r24
    3538:	6f 89       	ldd	r22, Y+23	; 0x17
    353a:	78 8d       	ldd	r23, Y+24	; 0x18
    353c:	89 8d       	ldd	r24, Y+25	; 0x19
    353e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3540:	0e 94 74 1f 	call	0x3ee8	; 0x3ee8 <__subsf3>
    --exponent;
    3544:	f8 01       	movw	r30, r16
    3546:	31 97       	sbiw	r30, 0x01	; 1
    3548:	ec 8f       	std	Y+28, r30	; 0x1c
    354a:	fd 8f       	std	Y+29, r31	; 0x1d

    *buffer++ = '.';
    354c:	ee e2       	ldi	r30, 0x2E	; 46
    354e:	d3 01       	movw	r26, r6
    3550:	11 96       	adiw	r26, 0x01	; 1
    3552:	ec 93       	st	X, r30
    3554:	83 01       	movw	r16, r6
    3556:	0e 5f       	subi	r16, 0xFE	; 254
    3558:	1f 4f       	sbci	r17, 0xFF	; 255
    355a:	73 01       	movw	r14, r6
    355c:	f6 e0       	ldi	r31, 0x06	; 6
    355e:	ef 0e       	add	r14, r31
    3560:	f1 1c       	adc	r15, r1

    for (int i = 0; i < width; i++) {
        int digit = value * 10.0;
    3562:	20 e0       	ldi	r18, 0x00	; 0
    3564:	30 e0       	ldi	r19, 0x00	; 0
    3566:	40 e2       	ldi	r20, 0x20	; 32
    3568:	51 e4       	ldi	r21, 0x41	; 65
    356a:	0e 94 45 21 	call	0x428a	; 0x428a <__mulsf3>
    356e:	6f 8b       	std	Y+23, r22	; 0x17
    3570:	78 8f       	std	Y+24, r23	; 0x18
    3572:	89 8f       	std	Y+25, r24	; 0x19
    3574:	9a 8f       	std	Y+26, r25	; 0x1a
    3576:	0e 94 58 20 	call	0x40b0	; 0x40b0 <__fixsfsi>
        *buffer++ = digit + '0';
    357a:	20 e3       	ldi	r18, 0x30	; 48
    357c:	26 0f       	add	r18, r22
    357e:	d8 01       	movw	r26, r16
    3580:	2d 93       	st	X+, r18
    3582:	8d 01       	movw	r16, r26
        value = value * 10.0 - digit;
    3584:	07 2e       	mov	r0, r23
    3586:	00 0c       	add	r0, r0
    3588:	88 0b       	sbc	r24, r24
    358a:	99 0b       	sbc	r25, r25
    358c:	0e 94 90 20 	call	0x4120	; 0x4120 <__floatsisf>
    3590:	9b 01       	movw	r18, r22
    3592:	ac 01       	movw	r20, r24
    3594:	6f 89       	ldd	r22, Y+23	; 0x17
    3596:	78 8d       	ldd	r23, Y+24	; 0x18
    3598:	89 8d       	ldd	r24, Y+25	; 0x19
    359a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    359c:	0e 94 74 1f 	call	0x3ee8	; 0x3ee8 <__subsf3>
    value = value * 10.0 - digit;
    --exponent;

    *buffer++ = '.';

    for (int i = 0; i < width; i++) {
    35a0:	0e 15       	cp	r16, r14
    35a2:	1f 05       	cpc	r17, r15
    35a4:	f1 f6       	brne	.-68     	; 0x3562 <vDisplayWriteStringAtPos+0x5ba>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
    }

    *buffer++ = 'e';
    35a6:	25 e6       	ldi	r18, 0x65	; 101
    35a8:	f3 01       	movw	r30, r6
    35aa:	26 83       	std	Z+6, r18	; 0x06
    35ac:	b3 01       	movw	r22, r6
    35ae:	69 5f       	subi	r22, 0xF9	; 249
    35b0:	7f 4f       	sbci	r23, 0xFF	; 255
    35b2:	4a e0       	ldi	r20, 0x0A	; 10
    35b4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    35b6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    35b8:	0e 94 ca 21 	call	0x4394	; 0x4394 <__itoa_ncheck>
    35bc:	94 01       	movw	r18, r8
    35be:	f4 01       	movw	r30, r8
    35c0:	ee 5e       	subi	r30, 0xEE	; 238
    35c2:	f0 4d       	sbci	r31, 0xD0	; 208
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    35c4:	46 e2       	ldi	r20, 0x26	; 38
    35c6:	5f e2       	ldi	r21, 0x2F	; 47
    35c8:	80 e0       	ldi	r24, 0x00	; 0
    35ca:	90 e0       	ldi	r25, 0x00	; 0
    35cc:	05 c0       	rjmp	.+10     	; 0x35d8 <vDisplayWriteStringAtPos+0x630>

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    35ce:	da 01       	movw	r26, r20
    35d0:	6d 91       	ld	r22, X+
    35d2:	ad 01       	movw	r20, r26
    35d4:	61 93       	st	Z+, r22
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    35d6:	01 96       	adiw	r24, 0x01	; 1
    35d8:	d6 01       	movw	r26, r12
    35da:	0d 90       	ld	r0, X+
    35dc:	00 20       	and	r0, r0
    35de:	e9 f7       	brne	.-6      	; 0x35da <vDisplayWriteStringAtPos+0x632>
    35e0:	11 97       	sbiw	r26, 0x01	; 1
    35e2:	a6 52       	subi	r26, 0x26	; 38
    35e4:	bf 42       	sbci	r27, 0x2F	; 47
    35e6:	8a 17       	cp	r24, r26
    35e8:	9b 07       	cpc	r25, r27
    35ea:	88 f3       	brcs	.-30     	; 0x35ce <vDisplayWriteStringAtPos+0x626>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    35ec:	4d 01       	movw	r8, r26
    35ee:	82 0e       	add	r8, r18
    35f0:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    35f2:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    35f4:	d2 01       	movw	r26, r4
    35f6:	11 c0       	rjmp	.+34     	; 0x361a <vDisplayWriteStringAtPos+0x672>
				break;
			}
		}
		else {
			str[length] = ch;
			if(str[length] == '\n') {
    35f8:	8a 30       	cpi	r24, 0x0A	; 10
    35fa:	29 f0       	breq	.+10     	; 0x3606 <vDisplayWriteStringAtPos+0x65e>
				length += strlen(buffer);
				break;
			}
		}
		else {
			str[length] = ch;
    35fc:	f4 01       	movw	r30, r8
    35fe:	ee 5e       	subi	r30, 0xEE	; 238
    3600:	f0 4d       	sbci	r31, 0xD0	; 208
    3602:	80 83       	st	Z, r24
    3604:	04 c0       	rjmp	.+8      	; 0x360e <vDisplayWriteStringAtPos+0x666>
			if(str[length] == '\n') {
				str[length] = '\0';				
    3606:	f4 01       	movw	r30, r8
    3608:	ee 5e       	subi	r30, 0xEE	; 238
    360a:	f0 4d       	sbci	r31, 0xD0	; 208
    360c:	10 82       	st	Z, r1
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    360e:	11 96       	adiw	r26, 0x01	; 1
		else {
			str[length] = ch;
			if(str[length] == '\n') {
				str[length] = '\0';				
			}
			length++;
    3610:	ef ef       	ldi	r30, 0xFF	; 255
    3612:	8e 1a       	sub	r8, r30
    3614:	9e 0a       	sbc	r9, r30
    3616:	01 c0       	rjmp	.+2      	; 0x361a <vDisplayWriteStringAtPos+0x672>
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3618:	d2 01       	movw	r26, r4
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    361a:	8c 91       	ld	r24, X
    361c:	81 11       	cpse	r24, r1
    361e:	01 cd       	rjmp	.-1534   	; 0x3022 <vDisplayWriteStringAtPos+0x7a>
				str[length] = '\0';				
			}
			length++;
		}
	}
	if(length + pos >= 20) {
    3620:	8d a9       	ldd	r24, Y+53	; 0x35
    3622:	9e a9       	ldd	r25, Y+54	; 0x36
    3624:	88 0d       	add	r24, r8
    3626:	99 1d       	adc	r25, r9
    3628:	44 97       	sbiw	r24, 0x14	; 20
    362a:	3c f0       	brlt	.+14     	; 0x363a <vDisplayWriteStringAtPos+0x692>
		length = 20-pos;
    362c:	84 e1       	ldi	r24, 0x14	; 20
    362e:	90 e0       	ldi	r25, 0x00	; 0
    3630:	4c 01       	movw	r8, r24
    3632:	2d a9       	ldd	r18, Y+53	; 0x35
    3634:	3e a9       	ldd	r19, Y+54	; 0x36
    3636:	82 1a       	sub	r8, r18
    3638:	93 0a       	sbc	r9, r19
    363a:	fe 01       	movw	r30, r28
    363c:	33 96       	adiw	r30, 0x03	; 3
    363e:	ce 01       	movw	r24, r28
    3640:	47 96       	adiw	r24, 0x17	; 23
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    3642:	df 01       	movw	r26, r30
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
    3644:	1d 92       	st	X+, r1
	}
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
    3646:	a8 17       	cp	r26, r24
    3648:	b9 07       	cpc	r27, r25
    364a:	e1 f7       	brne	.-8      	; 0x3644 <vDisplayWriteStringAtPos+0x69c>
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
    364c:	3b 8d       	ldd	r19, Y+27	; 0x1b
    364e:	39 83       	std	Y+1, r19	; 0x01
	newLine.displayPos = pos;
    3650:	8d a9       	ldd	r24, Y+53	; 0x35
    3652:	8a 83       	std	Y+2, r24	; 0x02
	for(int i = 0; i < length;i++) {
    3654:	18 14       	cp	r1, r8
    3656:	19 04       	cpc	r1, r9
    3658:	5c f4       	brge	.+22     	; 0x3670 <vDisplayWriteStringAtPos+0x6c8>
    365a:	ce 01       	movw	r24, r28
    365c:	88 0d       	add	r24, r8
    365e:	99 1d       	adc	r25, r9
    3660:	03 96       	adiw	r24, 0x03	; 3
		newLine.displayBuffer[i] = str[i];
    3662:	d5 01       	movw	r26, r10
    3664:	2d 91       	ld	r18, X+
    3666:	5d 01       	movw	r10, r26
    3668:	21 93       	st	Z+, r18
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
	newLine.displayPos = pos;
	for(int i = 0; i < length;i++) {
    366a:	8e 17       	cp	r24, r30
    366c:	9f 07       	cpc	r25, r31
    366e:	c9 f7       	brne	.-14     	; 0x3662 <vDisplayWriteStringAtPos+0x6ba>
		newLine.displayBuffer[i] = str[i];
	}	
	xQueueSend(displayLineQueue, (void *) &newLine, portMAX_DELAY);
    3670:	00 e0       	ldi	r16, 0x00	; 0
    3672:	2f ef       	ldi	r18, 0xFF	; 255
    3674:	3f ef       	ldi	r19, 0xFF	; 255
    3676:	a9 01       	movw	r20, r18
    3678:	be 01       	movw	r22, r28
    367a:	6f 5f       	subi	r22, 0xFF	; 255
    367c:	7f 4f       	sbci	r23, 0xFF	; 255
    367e:	80 91 43 30 	lds	r24, 0x3043	; 0x803043 <displayLineQueue>
    3682:	90 91 44 30 	lds	r25, 0x3044	; 0x803044 <displayLineQueue+0x1>
    3686:	0e 94 dd 07 	call	0xfba	; 0xfba <xQueueGenericSend>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    368a:	1b c0       	rjmp	.+54     	; 0x36c2 <vDisplayWriteStringAtPos+0x71a>
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    368c:	2d ec       	ldi	r18, 0xCD	; 205
    368e:	3c ec       	ldi	r19, 0xCC	; 204
    3690:	4c ec       	ldi	r20, 0xCC	; 204
    3692:	5d e3       	ldi	r21, 0x3D	; 61
    3694:	6f 89       	ldd	r22, Y+23	; 0x17
    3696:	78 8d       	ldd	r23, Y+24	; 0x18
    3698:	89 8d       	ldd	r24, Y+25	; 0x19
    369a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    369c:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <__cmpsf2>
    36a0:	88 23       	and	r24, r24
    36a2:	0c f4       	brge	.+2      	; 0x36a6 <vDisplayWriteStringAtPos+0x6fe>
    36a4:	d6 cd       	rjmp	.-1108   	; 0x3252 <vDisplayWriteStringAtPos+0x2aa>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    36a6:	80 e0       	ldi	r24, 0x00	; 0
    36a8:	90 e0       	ldi	r25, 0x00	; 0
    36aa:	26 ce       	rjmp	.-948    	; 0x32f8 <vDisplayWriteStringAtPos+0x350>
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    36ac:	20 e3       	ldi	r18, 0x30	; 48
    36ae:	ec 8d       	ldd	r30, Y+28	; 0x1c
    36b0:	fd 8d       	ldd	r31, Y+29	; 0x1d
    36b2:	20 83       	st	Z, r18

    *buffer++ = '.';
    36b4:	7f 01       	movw	r14, r30
    36b6:	32 e0       	ldi	r19, 0x02	; 2
    36b8:	e3 0e       	add	r14, r19
    36ba:	f1 1c       	adc	r15, r1
    36bc:	8e e2       	ldi	r24, 0x2E	; 46
    36be:	81 83       	std	Z+1, r24	; 0x01
    36c0:	46 ce       	rjmp	.-884    	; 0x334e <vDisplayWriteStringAtPos+0x3a6>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    36c2:	6d 96       	adiw	r28, 0x1d	; 29
    36c4:	cd bf       	out	0x3d, r28	; 61
    36c6:	de bf       	out	0x3e, r29	; 62
    36c8:	df 91       	pop	r29
    36ca:	cf 91       	pop	r28
    36cc:	1f 91       	pop	r17
    36ce:	0f 91       	pop	r16
    36d0:	ff 90       	pop	r15
    36d2:	ef 90       	pop	r14
    36d4:	df 90       	pop	r13
    36d6:	cf 90       	pop	r12
    36d8:	bf 90       	pop	r11
    36da:	af 90       	pop	r10
    36dc:	9f 90       	pop	r9
    36de:	8f 90       	pop	r8
    36e0:	7f 90       	pop	r7
    36e2:	6f 90       	pop	r6
    36e4:	5f 90       	pop	r5
    36e6:	4f 90       	pop	r4
    36e8:	3f 90       	pop	r3
    36ea:	2f 90       	pop	r2
    36ec:	08 95       	ret

000036ee <vsendFrame>:
        xQueueSend(xQueue_Data,(void *)Data,pdMS_TO_TICKS(10));
    }    
}

void vsendFrame(void *pvParameters)
{
    36ee:	cf 93       	push	r28
    36f0:	df 93       	push	r29
    36f2:	cd b7       	in	r28, 0x3d	; 61
    36f4:	de b7       	in	r29, 0x3e	; 62
    36f6:	a2 97       	sbiw	r28, 0x22	; 34
    36f8:	cd bf       	out	0x3d, r28	; 61
    36fa:	de bf       	out	0x3e, r29	; 62
uint8_t ucDataByteCounter = 0;              // Counts the sent data of the data array.
uint8_t ucDataBytesToSend;                  // Stores the value of how many data bytes should be sent. Extracted from command byte (1st array in data queue).
uint8_t ucQAMChannelsReady = 0;             // Status register to check if both QAM channels got the new amplitude levels.
uint8_t ucIdleSendByteFlag = 0;             // Byte for differentiation of idle bytes to be sent between 0xAF and 0x05.
uint8_t ucChecksumValue = 0;                // Used for checksum calculation.
uint8_t Data[NR_OF_DATA_SAMPLES + 1] = {};  // Data bytes received from queue.                
    36fc:	fe 01       	movw	r30, r28
    36fe:	32 96       	adiw	r30, 0x02	; 2
    3700:	81 e2       	ldi	r24, 0x21	; 33
    3702:	df 01       	movw	r26, r30
    3704:	1d 92       	st	X+, r1
    3706:	8a 95       	dec	r24
    3708:	e9 f7       	brne	.-6      	; 0x3704 <vsendFrame+0x16>

    
    eProtokollStates Protokoll = Idle;
    370a:	10 e0       	ldi	r17, 0x00	; 0
uint8_t ucNewDataByteValue = 0;             // Stores the new data byte value, which should be sent next.
uint8_t ucDataByteCounter = 0;              // Counts the sent data of the data array.
uint8_t ucDataBytesToSend;                  // Stores the value of how many data bytes should be sent. Extracted from command byte (1st array in data queue).
uint8_t ucQAMChannelsReady = 0;             // Status register to check if both QAM channels got the new amplitude levels.
uint8_t ucIdleSendByteFlag = 0;             // Byte for differentiation of idle bytes to be sent between 0xAF and 0x05.
uint8_t ucChecksumValue = 0;                // Used for checksum calculation.
    370c:	b1 2c       	mov	r11, r1
uint8_t ucReadyForNewDataByte = 1;          // Indicates if new data byte can be provided.
uint8_t ucNewDataByteValue = 0;             // Stores the new data byte value, which should be sent next.
uint8_t ucDataByteCounter = 0;              // Counts the sent data of the data array.
uint8_t ucDataBytesToSend;                  // Stores the value of how many data bytes should be sent. Extracted from command byte (1st array in data queue).
uint8_t ucQAMChannelsReady = 0;             // Status register to check if both QAM channels got the new amplitude levels.
uint8_t ucIdleSendByteFlag = 0;             // Byte for differentiation of idle bytes to be sent between 0xAF and 0x05.
    370e:	a1 2c       	mov	r10, r1
uint8_t ucSendBitPackageCounter = 0;        // Counts the sent bit packages, for QAM4 for 1 byte there are 4 packages (4 x 2bit = 8bit)
uint8_t ucReadyForNewDataByte = 1;          // Indicates if new data byte can be provided.
uint8_t ucNewDataByteValue = 0;             // Stores the new data byte value, which should be sent next.
uint8_t ucDataByteCounter = 0;              // Counts the sent data of the data array.
uint8_t ucDataBytesToSend;                  // Stores the value of how many data bytes should be sent. Extracted from command byte (1st array in data queue).
uint8_t ucQAMChannelsReady = 0;             // Status register to check if both QAM channels got the new amplitude levels.
    3710:	00 e0       	ldi	r16, 0x00	; 0
    
volatile uint8_t ucSendByteValue;                    // Variable current byte to send is stored
uint8_t ucSendBitPackageCounter = 0;        // Counts the sent bit packages, for QAM4 for 1 byte there are 4 packages (4 x 2bit = 8bit)
uint8_t ucReadyForNewDataByte = 1;          // Indicates if new data byte can be provided.
uint8_t ucNewDataByteValue = 0;             // Stores the new data byte value, which should be sent next.
uint8_t ucDataByteCounter = 0;              // Counts the sent data of the data array.
    3712:	c1 2c       	mov	r12, r1
(void) pvParameters;
    
volatile uint8_t ucSendByteValue;                    // Variable current byte to send is stored
uint8_t ucSendBitPackageCounter = 0;        // Counts the sent bit packages, for QAM4 for 1 byte there are 4 packages (4 x 2bit = 8bit)
uint8_t ucReadyForNewDataByte = 1;          // Indicates if new data byte can be provided.
uint8_t ucNewDataByteValue = 0;             // Stores the new data byte value, which should be sent next.
    3714:	d1 2c       	mov	r13, r1
{
(void) pvParameters;
    
volatile uint8_t ucSendByteValue;                    // Variable current byte to send is stored
uint8_t ucSendBitPackageCounter = 0;        // Counts the sent bit packages, for QAM4 for 1 byte there are 4 packages (4 x 2bit = 8bit)
uint8_t ucReadyForNewDataByte = 1;          // Indicates if new data byte can be provided.
    3716:	ee 24       	eor	r14, r14
    3718:	e3 94       	inc	r14
void vsendFrame(void *pvParameters)
{
(void) pvParameters;
    
volatile uint8_t ucSendByteValue;                    // Variable current byte to send is stored
uint8_t ucSendBitPackageCounter = 0;        // Counts the sent bit packages, for QAM4 for 1 byte there are 4 packages (4 x 2bit = 8bit)
    371a:	f1 2c       	mov	r15, r1
            
            case sendSyncByte:
            {
                if (ucReadyForNewDataByte)
                {
                    ucNewDataByteValue = 0xFF;
    371c:	88 24       	eor	r8, r8
    371e:	8a 94       	dec	r8
    {
        
        /************************************************************************/
        /* State machine for setting up data.                                   */
        /************************************************************************/
        switch(Protokoll)
    3720:	11 30       	cpi	r17, 0x01	; 1
    3722:	41 f1       	breq	.+80     	; 0x3774 <vsendFrame+0x86>
    3724:	28 f0       	brcs	.+10     	; 0x3730 <vsendFrame+0x42>
    3726:	12 30       	cpi	r17, 0x02	; 2
    3728:	59 f1       	breq	.+86     	; 0x3780 <vsendFrame+0x92>
    372a:	13 30       	cpi	r17, 0x03	; 3
    372c:	c1 f1       	breq	.+112    	; 0x379e <vsendFrame+0xb0>
    372e:	3e c0       	rjmp	.+124    	; 0x37ac <vsendFrame+0xbe>
        {
            case Idle:
            {
                if (ucIdleSendByteFlag == 0)
    3730:	a1 10       	cpse	r10, r1
    3732:	08 c0       	rjmp	.+16     	; 0x3744 <vsendFrame+0x56>
                {
                    /* Send first idle byte. */
                    if (ucReadyForNewDataByte)
    3734:	ee 20       	and	r14, r14
    3736:	09 f4       	brne	.+2      	; 0x373a <vsendFrame+0x4c>
    3738:	41 c0       	rjmp	.+130    	; 0x37bc <vsendFrame+0xce>
                    {
                        ucIdleSendByteFlag = 1;
    373a:	aa 24       	eor	r10, r10
    373c:	a3 94       	inc	r10
                        ucNewDataByteValue = 0x00; //AF
    373e:	d1 2c       	mov	r13, r1
                        ucReadyForNewDataByte = 0;
    3740:	e1 2c       	mov	r14, r1
    3742:	3c c0       	rjmp	.+120    	; 0x37bc <vsendFrame+0xce>
                    }
                }
                else
                {
                    /* Send second idle byte. */
                    if (ucReadyForNewDataByte)
    3744:	ee 20       	and	r14, r14
    3746:	d1 f1       	breq	.+116    	; 0x37bc <vsendFrame+0xce>
                        ucNewDataByteValue = 0x00; //05
                        ucReadyForNewDataByte = 0;
                        
                        
                        /* Check if new Data was received. */
                        if (xQueueReceive(xQueue_Data,Data, pdMS_TO_TICKS(0)) == pdTRUE)
    3748:	20 e0       	ldi	r18, 0x00	; 0
    374a:	30 e0       	ldi	r19, 0x00	; 0
    374c:	a9 01       	movw	r20, r18
    374e:	be 01       	movw	r22, r28
    3750:	6e 5f       	subi	r22, 0xFE	; 254
    3752:	7f 4f       	sbci	r23, 0xFF	; 255
    3754:	80 91 4b 30 	lds	r24, 0x304B	; 0x80304b <xQueue_Data>
    3758:	90 91 4c 30 	lds	r25, 0x304C	; 0x80304c <xQueue_Data+0x1>
    375c:	0e 94 c8 08 	call	0x1190	; 0x1190 <xQueueReceive>
    3760:	81 30       	cpi	r24, 0x01	; 1
    3762:	31 f5       	brne	.+76     	; 0x37b0 <vsendFrame+0xc2>
                        {
                            ucDataBytesToSend = Data[0] & DATABYTETOSENDMASK;
    3764:	8a 81       	ldd	r24, Y+2	; 0x02
    3766:	8f 71       	andi	r24, 0x1F	; 31
    3768:	98 2e       	mov	r9, r24
                            Protokoll = sendSyncByte;
    376a:	11 e0       	ldi	r17, 0x01	; 1
                else
                {
                    /* Send second idle byte. */
                    if (ucReadyForNewDataByte)
                    {
                        ucIdleSendByteFlag = 0;
    376c:	a1 2c       	mov	r10, r1
                        ucNewDataByteValue = 0x00; //05
    376e:	d1 2c       	mov	r13, r1
                        ucReadyForNewDataByte = 0;
    3770:	e1 2c       	mov	r14, r1
    3772:	24 c0       	rjmp	.+72     	; 0x37bc <vsendFrame+0xce>
                break;
            }
            
            case sendSyncByte:
            {
                if (ucReadyForNewDataByte)
    3774:	ee 20       	and	r14, r14
    3776:	11 f1       	breq	.+68     	; 0x37bc <vsendFrame+0xce>
                {
                    ucNewDataByteValue = 0xFF;
                    ucReadyForNewDataByte = 0;
                    Protokoll = sendDatenbuffer;
    3778:	12 e0       	ldi	r17, 0x02	; 2
            
            case sendSyncByte:
            {
                if (ucReadyForNewDataByte)
                {
                    ucNewDataByteValue = 0xFF;
    377a:	d8 2c       	mov	r13, r8
                    ucReadyForNewDataByte = 0;
    377c:	e1 2c       	mov	r14, r1
    377e:	1e c0       	rjmp	.+60     	; 0x37bc <vsendFrame+0xce>
                break;
            }                          
            
            case sendDatenbuffer:
            {  
                if (ucReadyForNewDataByte)
    3780:	ee 20       	and	r14, r14
    3782:	e1 f0       	breq	.+56     	; 0x37bc <vsendFrame+0xce>
                {
                    if (ucDataByteCounter <= ucDataBytesToSend)
    3784:	9c 14       	cp	r9, r12
    3786:	c0 f0       	brcs	.+48     	; 0x37b8 <vsendFrame+0xca>
                    {
                        ucNewDataByteValue = Data[ucDataByteCounter];
    3788:	e2 e0       	ldi	r30, 0x02	; 2
    378a:	f0 e0       	ldi	r31, 0x00	; 0
    378c:	ec 0f       	add	r30, r28
    378e:	fd 1f       	adc	r31, r29
    3790:	ec 0d       	add	r30, r12
    3792:	f1 1d       	adc	r31, r1
    3794:	d0 80       	ld	r13, Z
                        
                        /* Continuous checksum calculation over all sent data bytes. */
                        ucChecksumValue ^= ucNewDataByteValue;
    3796:	bd 24       	eor	r11, r13
                        ucReadyForNewDataByte = 0;
                        ucDataByteCounter++;
    3798:	c3 94       	inc	r12
                    {
                        ucNewDataByteValue = Data[ucDataByteCounter];
                        
                        /* Continuous checksum calculation over all sent data bytes. */
                        ucChecksumValue ^= ucNewDataByteValue;
                        ucReadyForNewDataByte = 0;
    379a:	e1 2c       	mov	r14, r1
    379c:	0f c0       	rjmp	.+30     	; 0x37bc <vsendFrame+0xce>

                break;
            }
            case sendChecksum:
            {
                if (ucReadyForNewDataByte)
    379e:	ee 20       	and	r14, r14
    37a0:	69 f0       	breq	.+26     	; 0x37bc <vsendFrame+0xce>
                {
                    ucNewDataByteValue = ucChecksumValue;
    37a2:	db 2c       	mov	r13, r11
                    ucChecksumValue = 0;
                    ucReadyForNewDataByte = 0;
                    Protokoll = Idle;
    37a4:	10 e0       	ldi	r17, 0x00	; 0
            case sendChecksum:
            {
                if (ucReadyForNewDataByte)
                {
                    ucNewDataByteValue = ucChecksumValue;
                    ucChecksumValue = 0;
    37a6:	b1 2c       	mov	r11, r1
                    ucReadyForNewDataByte = 0;
    37a8:	e1 2c       	mov	r14, r1
    37aa:	08 c0       	rjmp	.+16     	; 0x37bc <vsendFrame+0xce>
                }
                break;
            }
            default:
            {
                Protokoll = Idle;
    37ac:	10 e0       	ldi	r17, 0x00	; 0
    37ae:	06 c0       	rjmp	.+12     	; 0x37bc <vsendFrame+0xce>
                else
                {
                    /* Send second idle byte. */
                    if (ucReadyForNewDataByte)
                    {
                        ucIdleSendByteFlag = 0;
    37b0:	a1 2c       	mov	r10, r1
                        ucNewDataByteValue = 0x00; //05
    37b2:	d1 2c       	mov	r13, r1
                        ucReadyForNewDataByte = 0;
    37b4:	e1 2c       	mov	r14, r1
    37b6:	02 c0       	rjmp	.+4      	; 0x37bc <vsendFrame+0xce>
                        ucDataByteCounter++;
                    } 
                    else
                    {
                        ucDataByteCounter = 0;
                        Protokoll = sendChecksum;
    37b8:	13 e0       	ldi	r17, 0x03	; 3
                        ucReadyForNewDataByte = 0;
                        ucDataByteCounter++;
                    } 
                    else
                    {
                        ucDataByteCounter = 0;
    37ba:	c1 2c       	mov	r12, r1
        /************************************************************************/
        /* Data send part.                                                      */
        /************************************************************************/
        
        /* Check if all data bit packages of one byte were sent. */
        if (ucSendBitPackageCounter > 1) //3
    37bc:	b1 e0       	ldi	r27, 0x01	; 1
    37be:	bf 15       	cp	r27, r15
    37c0:	20 f4       	brcc	.+8      	; 0x37ca <vsendFrame+0xdc>
        {
            /* Then the new data byte can be loaded. */
            ucSendByteValue = ucNewDataByteValue;
    37c2:	d9 82       	std	Y+1, r13	; 0x01
            ucSendBitPackageCounter = 0;
            ucReadyForNewDataByte = 1;
    37c4:	ee 24       	eor	r14, r14
    37c6:	e3 94       	inc	r14
        /* Check if all data bit packages of one byte were sent. */
        if (ucSendBitPackageCounter > 1) //3
        {
            /* Then the new data byte can be loaded. */
            ucSendByteValue = ucNewDataByteValue;
            ucSendBitPackageCounter = 0;
    37c8:	f1 2c       	mov	r15, r1
            ucReadyForNewDataByte = 1;
        }
        
        /* Check if QAM channel 1 got amplitude value. */
        if (xEventGroupGetBits(xQAMchannel_1) & DATEN_AUFBEREITET)
    37ca:	40 e0       	ldi	r20, 0x00	; 0
    37cc:	50 e0       	ldi	r21, 0x00	; 0
    37ce:	ba 01       	movw	r22, r20
    37d0:	80 91 47 30 	lds	r24, 0x3047	; 0x803047 <xQAMchannel_1>
    37d4:	90 91 48 30 	lds	r25, 0x3048	; 0x803048 <xQAMchannel_1+0x1>
    37d8:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
    37dc:	62 ff       	sbrs	r22, 2
    37de:	69 c0       	rjmp	.+210    	; 0x38b2 <vsendFrame+0x1c4>
        {
            /* Then flag can be deleted an status can be stored temporarily. */
            xEventGroupClearBits(xQAMchannel_1, DATEN_AUFBEREITET);
    37e0:	44 e0       	ldi	r20, 0x04	; 4
    37e2:	50 e0       	ldi	r21, 0x00	; 0
    37e4:	60 e0       	ldi	r22, 0x00	; 0
    37e6:	70 e0       	ldi	r23, 0x00	; 0
    37e8:	80 91 47 30 	lds	r24, 0x3047	; 0x803047 <xQAMchannel_1>
    37ec:	90 91 48 30 	lds	r25, 0x3048	; 0x803048 <xQAMchannel_1+0x1>
    37f0:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
            ucQAMChannelsReady |= QAMCHANNEL_1_READY;
    37f4:	01 60       	ori	r16, 0x01	; 1
            
            /* New amplitude level for next transmission can be prepared. */
            switch (ucSendByteValue & 0b000000011)
    37f6:	89 81       	ldd	r24, Y+1	; 0x01
    37f8:	83 70       	andi	r24, 0x03	; 3
    37fa:	81 30       	cpi	r24, 0x01	; 1
    37fc:	e1 f0       	breq	.+56     	; 0x3836 <vsendFrame+0x148>
    37fe:	30 f0       	brcs	.+12     	; 0x380c <vsendFrame+0x11e>
    3800:	82 30       	cpi	r24, 0x02	; 2
    3802:	71 f1       	breq	.+92     	; 0x3860 <vsendFrame+0x172>
    3804:	83 30       	cpi	r24, 0x03	; 3
    3806:	09 f4       	brne	.+2      	; 0x380a <vsendFrame+0x11c>
    3808:	40 c0       	rjmp	.+128    	; 0x388a <vsendFrame+0x19c>
    380a:	53 c0       	rjmp	.+166    	; 0x38b2 <vsendFrame+0x1c4>
            {
	            case 0b00000000:
	            xEventGroupSetBits(xQAMchannel_1, ein_kHz_0_25V);
    380c:	40 e1       	ldi	r20, 0x10	; 16
    380e:	50 e0       	ldi	r21, 0x00	; 0
    3810:	60 e0       	ldi	r22, 0x00	; 0
    3812:	70 e0       	ldi	r23, 0x00	; 0
    3814:	80 91 47 30 	lds	r24, 0x3047	; 0x803047 <xQAMchannel_1>
    3818:	90 91 48 30 	lds	r25, 0x3048	; 0x803048 <xQAMchannel_1+0x1>
    381c:	0e 94 80 03 	call	0x700	; 0x700 <xEventGroupSetBits>
	            xEventGroupClearBits(xQAMchannel_1, ein_kHz_0_50V|ein_kHZ_0_75V|ein_kHZ_1_00V);
    3820:	40 ee       	ldi	r20, 0xE0	; 224
    3822:	50 e0       	ldi	r21, 0x00	; 0
    3824:	60 e0       	ldi	r22, 0x00	; 0
    3826:	70 e0       	ldi	r23, 0x00	; 0
    3828:	80 91 47 30 	lds	r24, 0x3047	; 0x803047 <xQAMchannel_1>
    382c:	90 91 48 30 	lds	r25, 0x3048	; 0x803048 <xQAMchannel_1+0x1>
    3830:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
	            break;
    3834:	3e c0       	rjmp	.+124    	; 0x38b2 <vsendFrame+0x1c4>
	            
	            case 0b00000001:
	            xEventGroupSetBits(xQAMchannel_1, ein_kHz_0_50V);
    3836:	40 e2       	ldi	r20, 0x20	; 32
    3838:	50 e0       	ldi	r21, 0x00	; 0
    383a:	60 e0       	ldi	r22, 0x00	; 0
    383c:	70 e0       	ldi	r23, 0x00	; 0
    383e:	80 91 47 30 	lds	r24, 0x3047	; 0x803047 <xQAMchannel_1>
    3842:	90 91 48 30 	lds	r25, 0x3048	; 0x803048 <xQAMchannel_1+0x1>
    3846:	0e 94 80 03 	call	0x700	; 0x700 <xEventGroupSetBits>
	            xEventGroupClearBits(xQAMchannel_1, ein_kHz_0_25V|ein_kHZ_0_75V|ein_kHZ_1_00V);
    384a:	40 ed       	ldi	r20, 0xD0	; 208
    384c:	50 e0       	ldi	r21, 0x00	; 0
    384e:	60 e0       	ldi	r22, 0x00	; 0
    3850:	70 e0       	ldi	r23, 0x00	; 0
    3852:	80 91 47 30 	lds	r24, 0x3047	; 0x803047 <xQAMchannel_1>
    3856:	90 91 48 30 	lds	r25, 0x3048	; 0x803048 <xQAMchannel_1+0x1>
    385a:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
	            break;
    385e:	29 c0       	rjmp	.+82     	; 0x38b2 <vsendFrame+0x1c4>
	            
	            case 0b00000010:
	            xEventGroupSetBits(xQAMchannel_1, ein_kHZ_0_75V);
    3860:	40 e4       	ldi	r20, 0x40	; 64
    3862:	50 e0       	ldi	r21, 0x00	; 0
    3864:	60 e0       	ldi	r22, 0x00	; 0
    3866:	70 e0       	ldi	r23, 0x00	; 0
    3868:	80 91 47 30 	lds	r24, 0x3047	; 0x803047 <xQAMchannel_1>
    386c:	90 91 48 30 	lds	r25, 0x3048	; 0x803048 <xQAMchannel_1+0x1>
    3870:	0e 94 80 03 	call	0x700	; 0x700 <xEventGroupSetBits>
	            xEventGroupClearBits(xQAMchannel_1, ein_kHz_0_50V|ein_kHz_0_25V|ein_kHZ_1_00V);
    3874:	40 eb       	ldi	r20, 0xB0	; 176
    3876:	50 e0       	ldi	r21, 0x00	; 0
    3878:	60 e0       	ldi	r22, 0x00	; 0
    387a:	70 e0       	ldi	r23, 0x00	; 0
    387c:	80 91 47 30 	lds	r24, 0x3047	; 0x803047 <xQAMchannel_1>
    3880:	90 91 48 30 	lds	r25, 0x3048	; 0x803048 <xQAMchannel_1+0x1>
    3884:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
	            break;
    3888:	14 c0       	rjmp	.+40     	; 0x38b2 <vsendFrame+0x1c4>
	            
	            case 0b00000011:
	            xEventGroupSetBits(xQAMchannel_1, ein_kHZ_1_00V);
    388a:	40 e8       	ldi	r20, 0x80	; 128
    388c:	50 e0       	ldi	r21, 0x00	; 0
    388e:	60 e0       	ldi	r22, 0x00	; 0
    3890:	70 e0       	ldi	r23, 0x00	; 0
    3892:	80 91 47 30 	lds	r24, 0x3047	; 0x803047 <xQAMchannel_1>
    3896:	90 91 48 30 	lds	r25, 0x3048	; 0x803048 <xQAMchannel_1+0x1>
    389a:	0e 94 80 03 	call	0x700	; 0x700 <xEventGroupSetBits>
	            xEventGroupClearBits(xQAMchannel_1, ein_kHz_0_50V|ein_kHZ_0_75V|ein_kHz_0_25V);
    389e:	40 e7       	ldi	r20, 0x70	; 112
    38a0:	50 e0       	ldi	r21, 0x00	; 0
    38a2:	60 e0       	ldi	r22, 0x00	; 0
    38a4:	70 e0       	ldi	r23, 0x00	; 0
    38a6:	80 91 47 30 	lds	r24, 0x3047	; 0x803047 <xQAMchannel_1>
    38aa:	90 91 48 30 	lds	r25, 0x3048	; 0x803048 <xQAMchannel_1+0x1>
    38ae:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
	            break;
            }        
		}
        
        /* Check if QAM channel 2 got amplitude value. */
        if (xEventGroupGetBits(xQAMchannel_2)&DATEN_AUFBEREITET)
    38b2:	40 e0       	ldi	r20, 0x00	; 0
    38b4:	50 e0       	ldi	r21, 0x00	; 0
    38b6:	ba 01       	movw	r22, r20
    38b8:	80 91 49 30 	lds	r24, 0x3049	; 0x803049 <xQAMchannel_2>
    38bc:	90 91 4a 30 	lds	r25, 0x304A	; 0x80304a <xQAMchannel_2+0x1>
    38c0:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
    38c4:	62 ff       	sbrs	r22, 2
    38c6:	6c c0       	rjmp	.+216    	; 0x39a0 <vsendFrame+0x2b2>
        {
            /* Then flag can be deleted an status can be stored temporarily. */
            xEventGroupClearBits(xQAMchannel_2,DATEN_AUFBEREITET);
    38c8:	44 e0       	ldi	r20, 0x04	; 4
    38ca:	50 e0       	ldi	r21, 0x00	; 0
    38cc:	60 e0       	ldi	r22, 0x00	; 0
    38ce:	70 e0       	ldi	r23, 0x00	; 0
    38d0:	80 91 49 30 	lds	r24, 0x3049	; 0x803049 <xQAMchannel_2>
    38d4:	90 91 4a 30 	lds	r25, 0x304A	; 0x80304a <xQAMchannel_2+0x1>
    38d8:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
            ucQAMChannelsReady |= QAMCHANNEL_2_READY;
    38dc:	02 60       	ori	r16, 0x02	; 2
            
            /* New amplitude level for next transmission can be prepared. */
            switch (ucSendByteValue & 0b000001100)
    38de:	89 81       	ldd	r24, Y+1	; 0x01
    38e0:	8c 70       	andi	r24, 0x0C	; 12
    38e2:	84 30       	cpi	r24, 0x04	; 4
    38e4:	f9 f0       	breq	.+62     	; 0x3924 <vsendFrame+0x236>
    38e6:	18 f4       	brcc	.+6      	; 0x38ee <vsendFrame+0x200>
    38e8:	88 23       	and	r24, r24
    38ea:	39 f0       	breq	.+14     	; 0x38fa <vsendFrame+0x20c>
    38ec:	59 c0       	rjmp	.+178    	; 0x39a0 <vsendFrame+0x2b2>
    38ee:	88 30       	cpi	r24, 0x08	; 8
    38f0:	71 f1       	breq	.+92     	; 0x394e <vsendFrame+0x260>
    38f2:	8c 30       	cpi	r24, 0x0C	; 12
    38f4:	09 f4       	brne	.+2      	; 0x38f8 <vsendFrame+0x20a>
    38f6:	40 c0       	rjmp	.+128    	; 0x3978 <vsendFrame+0x28a>
    38f8:	53 c0       	rjmp	.+166    	; 0x39a0 <vsendFrame+0x2b2>
            {
				case 0b00000000:
                xEventGroupSetBits(xQAMchannel_2, zwei_kHz_0_25V);
    38fa:	40 e0       	ldi	r20, 0x00	; 0
    38fc:	51 e0       	ldi	r21, 0x01	; 1
    38fe:	60 e0       	ldi	r22, 0x00	; 0
    3900:	70 e0       	ldi	r23, 0x00	; 0
    3902:	80 91 49 30 	lds	r24, 0x3049	; 0x803049 <xQAMchannel_2>
    3906:	90 91 4a 30 	lds	r25, 0x304A	; 0x80304a <xQAMchannel_2+0x1>
    390a:	0e 94 80 03 	call	0x700	; 0x700 <xEventGroupSetBits>
                xEventGroupClearBits(xQAMchannel_2, zwei_kHz_0_50V|zwei_kHz_0_75V|zwei_kHz_1_00V);
    390e:	40 e0       	ldi	r20, 0x00	; 0
    3910:	5e e0       	ldi	r21, 0x0E	; 14
    3912:	60 e0       	ldi	r22, 0x00	; 0
    3914:	70 e0       	ldi	r23, 0x00	; 0
    3916:	80 91 49 30 	lds	r24, 0x3049	; 0x803049 <xQAMchannel_2>
    391a:	90 91 4a 30 	lds	r25, 0x304A	; 0x80304a <xQAMchannel_2+0x1>
    391e:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
				break;
    3922:	3e c0       	rjmp	.+124    	; 0x39a0 <vsendFrame+0x2b2>
				
				case 0b00000100:
				xEventGroupSetBits(xQAMchannel_2, zwei_kHz_0_50V);
    3924:	40 e0       	ldi	r20, 0x00	; 0
    3926:	52 e0       	ldi	r21, 0x02	; 2
    3928:	60 e0       	ldi	r22, 0x00	; 0
    392a:	70 e0       	ldi	r23, 0x00	; 0
    392c:	80 91 49 30 	lds	r24, 0x3049	; 0x803049 <xQAMchannel_2>
    3930:	90 91 4a 30 	lds	r25, 0x304A	; 0x80304a <xQAMchannel_2+0x1>
    3934:	0e 94 80 03 	call	0x700	; 0x700 <xEventGroupSetBits>
				xEventGroupClearBits(xQAMchannel_2, zwei_kHz_0_25V|zwei_kHz_0_75V|zwei_kHz_1_00V);
    3938:	40 e0       	ldi	r20, 0x00	; 0
    393a:	5d e0       	ldi	r21, 0x0D	; 13
    393c:	60 e0       	ldi	r22, 0x00	; 0
    393e:	70 e0       	ldi	r23, 0x00	; 0
    3940:	80 91 49 30 	lds	r24, 0x3049	; 0x803049 <xQAMchannel_2>
    3944:	90 91 4a 30 	lds	r25, 0x304A	; 0x80304a <xQAMchannel_2+0x1>
    3948:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
				break;
    394c:	29 c0       	rjmp	.+82     	; 0x39a0 <vsendFrame+0x2b2>
				
				case 0b00001000:
				xEventGroupSetBits(xQAMchannel_2, zwei_kHz_0_75V);
    394e:	40 e0       	ldi	r20, 0x00	; 0
    3950:	54 e0       	ldi	r21, 0x04	; 4
    3952:	60 e0       	ldi	r22, 0x00	; 0
    3954:	70 e0       	ldi	r23, 0x00	; 0
    3956:	80 91 49 30 	lds	r24, 0x3049	; 0x803049 <xQAMchannel_2>
    395a:	90 91 4a 30 	lds	r25, 0x304A	; 0x80304a <xQAMchannel_2+0x1>
    395e:	0e 94 80 03 	call	0x700	; 0x700 <xEventGroupSetBits>
				xEventGroupClearBits(xQAMchannel_2, zwei_kHz_0_50V|zwei_kHz_0_25V|zwei_kHz_1_00V);
    3962:	40 e0       	ldi	r20, 0x00	; 0
    3964:	5b e0       	ldi	r21, 0x0B	; 11
    3966:	60 e0       	ldi	r22, 0x00	; 0
    3968:	70 e0       	ldi	r23, 0x00	; 0
    396a:	80 91 49 30 	lds	r24, 0x3049	; 0x803049 <xQAMchannel_2>
    396e:	90 91 4a 30 	lds	r25, 0x304A	; 0x80304a <xQAMchannel_2+0x1>
    3972:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
				break;
    3976:	14 c0       	rjmp	.+40     	; 0x39a0 <vsendFrame+0x2b2>
				
				case 0b00001100:
				xEventGroupSetBits(xQAMchannel_2, zwei_kHz_1_00V);
    3978:	40 e0       	ldi	r20, 0x00	; 0
    397a:	58 e0       	ldi	r21, 0x08	; 8
    397c:	60 e0       	ldi	r22, 0x00	; 0
    397e:	70 e0       	ldi	r23, 0x00	; 0
    3980:	80 91 49 30 	lds	r24, 0x3049	; 0x803049 <xQAMchannel_2>
    3984:	90 91 4a 30 	lds	r25, 0x304A	; 0x80304a <xQAMchannel_2+0x1>
    3988:	0e 94 80 03 	call	0x700	; 0x700 <xEventGroupSetBits>
				xEventGroupClearBits(xQAMchannel_2, zwei_kHz_0_50V|zwei_kHz_0_75V|zwei_kHz_0_25V);
    398c:	40 e0       	ldi	r20, 0x00	; 0
    398e:	57 e0       	ldi	r21, 0x07	; 7
    3990:	60 e0       	ldi	r22, 0x00	; 0
    3992:	70 e0       	ldi	r23, 0x00	; 0
    3994:	80 91 49 30 	lds	r24, 0x3049	; 0x803049 <xQAMchannel_2>
    3998:	90 91 4a 30 	lds	r25, 0x304A	; 0x80304a <xQAMchannel_2+0x1>
    399c:	0e 94 50 03 	call	0x6a0	; 0x6a0 <xEventGroupClearBits>
				break;
            }
        }        
        
        /* Check if both channels got the new amplitude level. */
        if((ucQAMChannelsReady & QAMCHANNEL_1_READY) && (ucQAMChannelsReady & QAMCHANNEL_2_READY))
    39a0:	80 2f       	mov	r24, r16
    39a2:	83 70       	andi	r24, 0x03	; 3
    39a4:	83 30       	cpi	r24, 0x03	; 3
    39a6:	31 f4       	brne	.+12     	; 0x39b4 <vsendFrame+0x2c6>
        {
            /* Then new bit package can be prepared. */
            ucQAMChannelsReady = 0;
            ucSendBitPackageCounter++;
    39a8:	f3 94       	inc	r15
            ucSendByteValue = ucSendByteValue >> 4; //2
    39aa:	89 81       	ldd	r24, Y+1	; 0x01
    39ac:	82 95       	swap	r24
    39ae:	8f 70       	andi	r24, 0x0F	; 15
    39b0:	89 83       	std	Y+1, r24	; 0x01
        
        /* Check if both channels got the new amplitude level. */
        if((ucQAMChannelsReady & QAMCHANNEL_1_READY) && (ucQAMChannelsReady & QAMCHANNEL_2_READY))
        {
            /* Then new bit package can be prepared. */
            ucQAMChannelsReady = 0;
    39b2:	00 e0       	ldi	r16, 0x00	; 0
            ucSendBitPackageCounter++;
            ucSendByteValue = ucSendByteValue >> 4; //2
        }
        vTaskDelay(pdMS_TO_TICKS(1));
    39b4:	61 e0       	ldi	r22, 0x01	; 1
    39b6:	70 e0       	ldi	r23, 0x00	; 0
    39b8:	80 e0       	ldi	r24, 0x00	; 0
    39ba:	90 e0       	ldi	r25, 0x00	; 0
    39bc:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <vTaskDelay>
    }
    39c0:	af ce       	rjmp	.-674    	; 0x3720 <vsendFrame+0x32>

000039c2 <initDAC>:
                                                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

void initDAC(void) {
	DACB.CTRLA = DAC_CH0EN_bm | DAC_CH1EN_bm;
    39c2:	e0 e2       	ldi	r30, 0x20	; 32
    39c4:	f3 e0       	ldi	r31, 0x03	; 3
    39c6:	8c e0       	ldi	r24, 0x0C	; 12
    39c8:	80 83       	st	Z, r24
	DACB.CTRLB = DAC_CHSEL1_bm | DAC_CH0TRIG_bm | DAC_CH1TRIG_bm;
    39ca:	83 e4       	ldi	r24, 0x43	; 67
    39cc:	81 83       	std	Z+1, r24	; 0x01
	DACB.CTRLC = DAC_REFSEL0_bm; // Reference Voltage = AVCC
    39ce:	98 e0       	ldi	r25, 0x08	; 8
    39d0:	92 83       	std	Z+2, r25	; 0x02
	DACB.EVCTRL = 0x00;
    39d2:	13 82       	std	Z+3, r1	; 0x03
	DACB.CTRLA |= DAC_ENABLE_bm;
    39d4:	80 81       	ld	r24, Z
    39d6:	81 60       	ori	r24, 0x01	; 1
    39d8:	80 83       	st	Z, r24
	PORTB.DIRSET = 0x04;
    39da:	e0 e2       	ldi	r30, 0x20	; 32
    39dc:	f6 e0       	ldi	r31, 0x06	; 6
    39de:	84 e0       	ldi	r24, 0x04	; 4
    39e0:	81 83       	std	Z+1, r24	; 0x01
    PORTB.DIRSET = 0x08;
    39e2:	91 83       	std	Z+1, r25	; 0x01
    39e4:	08 95       	ret

000039e6 <initGenDMA>:
}
    
void initGenDMA(void) {
	DMA.CTRL = 0;
    39e6:	e0 e0       	ldi	r30, 0x00	; 0
    39e8:	f1 e0       	ldi	r31, 0x01	; 1
    39ea:	10 82       	st	Z, r1
	DMA.CTRL = DMA_RESET_bm;
    39ec:	80 e4       	ldi	r24, 0x40	; 64
    39ee:	80 83       	st	Z, r24
	while ((DMA.CTRL & DMA_RESET_bm) != 0);
    39f0:	80 81       	ld	r24, Z
    39f2:	86 fd       	sbrc	r24, 6
    39f4:	fd cf       	rjmp	.-6      	; 0x39f0 <initGenDMA+0xa>

	DMA.CTRL = DMA_ENABLE_bm | DMA_DBUFMODE_CH01CH23_gc;
    39f6:	e0 e0       	ldi	r30, 0x00	; 0
    39f8:	f1 e0       	ldi	r31, 0x01	; 1
    39fa:	8c e8       	ldi	r24, 0x8C	; 140
    39fc:	80 83       	st	Z, r24

	DMA.CH0.REPCNT = 0;
    39fe:	16 8a       	std	Z+22, r1	; 0x16
	DMA.CH0.CTRLB|=0x01;
    3a00:	81 89       	ldd	r24, Z+17	; 0x11
    3a02:	81 60       	ori	r24, 0x01	; 1
    3a04:	81 8b       	std	Z+17, r24	; 0x11
	DMA.CH0.CTRLA = DMA_CH_BURSTLEN_2BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm;					// ADC result is 2 byte 12 bit word
    3a06:	85 e2       	ldi	r24, 0x25	; 37
    3a08:	80 8b       	std	Z+16, r24	; 0x10
	DMA.CH0.ADDRCTRL =	DMA_CH_SRCRELOAD_TRANSACTION_gc | DMA_CH_SRCDIR_INC_gc | DMA_CH_DESTRELOAD_BURST_gc | DMA_CH_DESTDIR_INC_gc;	// reload source after every burst, reload dest after every transaction
    3a0a:	49 ed       	ldi	r20, 0xD9	; 217
    3a0c:	42 8b       	std	Z+18, r20	; 0x12
	DMA.CH0.TRIGSRC = DMA_CH_TRIGSRC_DACB_CH0_gc;
    3a0e:	83 8b       	std	Z+19, r24	; 0x13
	DMA.CH0.TRFCNT = NR_OF_GENERATOR_SAMPLES*2;	// always the number of bytes, even if burst length > 1
    3a10:	20 e4       	ldi	r18, 0x40	; 64
    3a12:	30 e0       	ldi	r19, 0x00	; 0
    3a14:	24 8b       	std	Z+20, r18	; 0x14
    3a16:	35 8b       	std	Z+21, r19	; 0x15
	DMA.CH0.SRCADDR0 = ((uint16_t)(&dacBuffer0[0]) >> 0) & 0xFF;
    3a18:	6a ef       	ldi	r22, 0xFA	; 250
    3a1a:	7f e2       	ldi	r23, 0x2F	; 47
    3a1c:	60 8f       	std	Z+24, r22	; 0x18
	DMA.CH0.SRCADDR1 = ((uint16_t)(&dacBuffer0[0]) >>  8) & 0xFF;
    3a1e:	71 8f       	std	Z+25, r23	; 0x19
	DMA.CH0.SRCADDR2 =0;
    3a20:	12 8e       	std	Z+26, r1	; 0x1a
	DMA.CH0.DESTADDR0 = ((uint16_t)(&DACB.CH0DATA) >> 0) & 0xFF;
    3a22:	68 e3       	ldi	r22, 0x38	; 56
    3a24:	64 8f       	std	Z+28, r22	; 0x1c
	DMA.CH0.DESTADDR1 = ((uint16_t)(&DACB.CH0DATA) >> 8) & 0xFF;
    3a26:	93 e0       	ldi	r25, 0x03	; 3
    3a28:	95 8f       	std	Z+29, r25	; 0x1d
	DMA.CH0.DESTADDR2 = 0;
    3a2a:	16 8e       	std	Z+30, r1	; 0x1e

	DMA.CH1.REPCNT = 0;
    3a2c:	16 a2       	std	Z+38, r1	; 0x26
	DMA.CH1.CTRLB |= 0x01;
    3a2e:	51 a1       	ldd	r21, Z+33	; 0x21
    3a30:	51 60       	ori	r21, 0x01	; 1
    3a32:	51 a3       	std	Z+33, r21	; 0x21
	DMA.CH1.CTRLA = DMA_CH_BURSTLEN_2BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm;
    3a34:	80 a3       	std	Z+32, r24	; 0x20
	DMA.CH1.ADDRCTRL = DMA_CH_SRCRELOAD_TRANSACTION_gc | DMA_CH_SRCDIR_INC_gc | DMA_CH_DESTRELOAD_BURST_gc | DMA_CH_DESTDIR_INC_gc;
    3a36:	42 a3       	std	Z+34, r20	; 0x22
	DMA.CH1.TRIGSRC = DMA_CH_TRIGSRC_DACB_CH0_gc;
    3a38:	83 a3       	std	Z+35, r24	; 0x23
	DMA.CH1.TRFCNT = NR_OF_GENERATOR_SAMPLES*2;
    3a3a:	24 a3       	std	Z+36, r18	; 0x24
    3a3c:	35 a3       	std	Z+37, r19	; 0x25
	DMA.CH1.SRCADDR0 = ((uint16_t)(&dacBuffer1[0]) >> 0) & 0xFF;
    3a3e:	aa eb       	ldi	r26, 0xBA	; 186
    3a40:	bf e2       	ldi	r27, 0x2F	; 47
    3a42:	a0 a7       	std	Z+40, r26	; 0x28
	DMA.CH1.SRCADDR1 = ((uint16_t)(&dacBuffer1[0]) >>  8) & 0xFF;
    3a44:	b1 a7       	std	Z+41, r27	; 0x29
	DMA.CH1.SRCADDR2 =0;
    3a46:	12 a6       	std	Z+42, r1	; 0x2a
	DMA.CH1.DESTADDR0 = ((uint16_t)(&DACB.CH0DATA) >> 0) & 0xFF;
    3a48:	64 a7       	std	Z+44, r22	; 0x2c
	DMA.CH1.DESTADDR1 = ((uint16_t)(&DACB.CH0DATA) >> 8) & 0xFF;
    3a4a:	95 a7       	std	Z+45, r25	; 0x2d
	DMA.CH1.DESTADDR2 = 0;
    3a4c:	16 a6       	std	Z+46, r1	; 0x2e
    
    DMA.CH2.REPCNT = 0;
    3a4e:	16 aa       	std	Z+54, r1	; 0x36
    DMA.CH2.CTRLB|=0x01;
    3a50:	51 a9       	ldd	r21, Z+49	; 0x31
    3a52:	51 60       	ori	r21, 0x01	; 1
    3a54:	51 ab       	std	Z+49, r21	; 0x31
    DMA.CH2.CTRLA = DMA_CH_BURSTLEN_2BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm;					// ADC result is 2 byte 12 bit word
    3a56:	80 ab       	std	Z+48, r24	; 0x30
    DMA.CH2.ADDRCTRL =	DMA_CH_SRCRELOAD_TRANSACTION_gc | DMA_CH_SRCDIR_INC_gc | DMA_CH_DESTRELOAD_BURST_gc | DMA_CH_DESTDIR_INC_gc;	// reload source after every burst, reload dest after every transaction
    3a58:	42 ab       	std	Z+50, r20	; 0x32
    DMA.CH2.TRIGSRC = DMA_CH_TRIGSRC_DACB_CH0_gc;
    3a5a:	83 ab       	std	Z+51, r24	; 0x33
    DMA.CH2.TRFCNT = NR_OF_GENERATOR_SAMPLES*2;	// always the number of bytes, even if burst length > 1
    3a5c:	24 ab       	std	Z+52, r18	; 0x34
    3a5e:	35 ab       	std	Z+53, r19	; 0x35
    DMA.CH2.SRCADDR0 = ((uint16_t)(&dacBuffer2[0]) >> 0) & 0xFF;
    3a60:	6a e7       	ldi	r22, 0x7A	; 122
    3a62:	7f e2       	ldi	r23, 0x2F	; 47
    3a64:	60 af       	std	Z+56, r22	; 0x38
    DMA.CH2.SRCADDR1 = ((uint16_t)(&dacBuffer2[0]) >>  8) & 0xFF;
    3a66:	71 af       	std	Z+57, r23	; 0x39
    DMA.CH2.SRCADDR2 =0;
    3a68:	12 ae       	std	Z+58, r1	; 0x3a
    DMA.CH2.DESTADDR0 = ((uint16_t)(&DACB.CH1DATA) >> 0) & 0xFF;
    3a6a:	6a e3       	ldi	r22, 0x3A	; 58
    3a6c:	64 af       	std	Z+60, r22	; 0x3c
    DMA.CH2.DESTADDR1 = ((uint16_t)(&DACB.CH1DATA) >> 8) & 0xFF;
    3a6e:	95 af       	std	Z+61, r25	; 0x3d
    DMA.CH2.DESTADDR2 = 0;
    3a70:	16 ae       	std	Z+62, r1	; 0x3e
    
    DMA.CH3.REPCNT = 0;
    3a72:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <__TEXT_REGION_LENGTH__+0x700146>
    DMA.CH3.CTRLB |= 0x01;
    3a76:	a1 e4       	ldi	r26, 0x41	; 65
    3a78:	b1 e0       	ldi	r27, 0x01	; 1
    3a7a:	5c 91       	ld	r21, X
    3a7c:	51 60       	ori	r21, 0x01	; 1
    3a7e:	5c 93       	st	X, r21
    DMA.CH3.CTRLA = DMA_CH_BURSTLEN_2BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm;
    3a80:	a0 e4       	ldi	r26, 0x40	; 64
    3a82:	b1 e0       	ldi	r27, 0x01	; 1
    3a84:	8c 93       	st	X, r24
    DMA.CH3.ADDRCTRL = DMA_CH_SRCRELOAD_TRANSACTION_gc | DMA_CH_SRCDIR_INC_gc | DMA_CH_DESTRELOAD_BURST_gc | DMA_CH_DESTDIR_INC_gc;
    3a86:	40 93 42 01 	sts	0x0142, r20	; 0x800142 <__TEXT_REGION_LENGTH__+0x700142>
    DMA.CH3.TRIGSRC = DMA_CH_TRIGSRC_DACB_CH0_gc;
    3a8a:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
    DMA.CH3.TRFCNT = NR_OF_GENERATOR_SAMPLES*2;
    3a8e:	20 93 44 01 	sts	0x0144, r18	; 0x800144 <__TEXT_REGION_LENGTH__+0x700144>
    3a92:	30 93 45 01 	sts	0x0145, r19	; 0x800145 <__TEXT_REGION_LENGTH__+0x700145>
    DMA.CH3.SRCADDR0 = ((uint16_t)(&dacBuffer3[0]) >> 0) & 0xFF;
    3a96:	2a e3       	ldi	r18, 0x3A	; 58
    3a98:	3f e2       	ldi	r19, 0x2F	; 47
    3a9a:	20 93 48 01 	sts	0x0148, r18	; 0x800148 <__TEXT_REGION_LENGTH__+0x700148>
    DMA.CH3.SRCADDR1 = ((uint16_t)(&dacBuffer3[0]) >>  8) & 0xFF;
    3a9e:	30 93 49 01 	sts	0x0149, r19	; 0x800149 <__TEXT_REGION_LENGTH__+0x700149>
    DMA.CH3.SRCADDR2 =0;
    3aa2:	10 92 4a 01 	sts	0x014A, r1	; 0x80014a <__TEXT_REGION_LENGTH__+0x70014a>
    DMA.CH3.DESTADDR0 = ((uint16_t)(&DACB.CH1DATA) >> 0) & 0xFF;
    3aa6:	60 93 4c 01 	sts	0x014C, r22	; 0x80014c <__TEXT_REGION_LENGTH__+0x70014c>
    DMA.CH3.DESTADDR1 = ((uint16_t)(&DACB.CH1DATA) >> 8) & 0xFF;
    3aaa:	90 93 4d 01 	sts	0x014D, r25	; 0x80014d <__TEXT_REGION_LENGTH__+0x70014d>
    DMA.CH3.DESTADDR2 = 0;
    3aae:	10 92 4e 01 	sts	0x014E, r1	; 0x80014e <__TEXT_REGION_LENGTH__+0x70014e>
	
	DMA.CH0.CTRLA |= DMA_CH_ENABLE_bm;
    3ab2:	80 89       	ldd	r24, Z+16	; 0x10
    3ab4:	80 68       	ori	r24, 0x80	; 128
    3ab6:	80 8b       	std	Z+16, r24	; 0x10
	DMA.CH1.CTRLA |= DMA_CH_ENABLE_bm; 
    3ab8:	80 a1       	ldd	r24, Z+32	; 0x20
    3aba:	80 68       	ori	r24, 0x80	; 128
    3abc:	80 a3       	std	Z+32, r24	; 0x20
    DMA.CH2.CTRLA |= DMA_CH_ENABLE_bm;
    3abe:	80 a9       	ldd	r24, Z+48	; 0x30
    3ac0:	80 68       	ori	r24, 0x80	; 128
    3ac2:	80 ab       	std	Z+48, r24	; 0x30
    DMA.CH3.CTRLA |= DMA_CH_ENABLE_bm;
    3ac4:	8c 91       	ld	r24, X
    3ac6:	80 68       	ori	r24, 0x80	; 128
    3ac8:	8c 93       	st	X, r24
    3aca:	08 95       	ret

00003acc <initDACTimer>:
}
void initDACTimer(void) {
	TC0_ConfigClockSource(&TCD0, TC_CLKSEL_DIV1_gc);
    3acc:	61 e0       	ldi	r22, 0x01	; 1
    3ace:	80 e0       	ldi	r24, 0x00	; 0
    3ad0:	99 e0       	ldi	r25, 0x09	; 9
    3ad2:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <TC0_ConfigClockSource>
	TC0_ConfigWGM(&TCD0, TC_WGMODE_SINGLESLOPE_gc);
    3ad6:	63 e0       	ldi	r22, 0x03	; 3
    3ad8:	80 e0       	ldi	r24, 0x00	; 0
    3ada:	99 e0       	ldi	r25, 0x09	; 9
    3adc:	0e 94 60 02 	call	0x4c0	; 0x4c0 <TC0_ConfigWGM>
	TC_SetPeriod(&TCD0, 32000000/(GENERATOR_FREQUENCY_INITIAL_VALUE*NR_OF_GENERATOR_SAMPLES));
    3ae0:	88 ee       	ldi	r24, 0xE8	; 232
    3ae2:	93 e0       	ldi	r25, 0x03	; 3
    3ae4:	80 93 26 09 	sts	0x0926, r24	; 0x800926 <__TEXT_REGION_LENGTH__+0x700926>
    3ae8:	90 93 27 09 	sts	0x0927, r25	; 0x800927 <__TEXT_REGION_LENGTH__+0x700927>
	EVSYS.CH0MUX = EVSYS_CHMUX_TCD0_OVF_gc; //Setup Eventsystem with timer TCD0 overflow
    3aec:	80 ed       	ldi	r24, 0xD0	; 208
    3aee:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__TEXT_REGION_LENGTH__+0x700180>
    3af2:	08 95       	ret

00003af4 <vQuamGen>:
}

void vQuamGen(void *pvParameters) {
	initDAC();
    3af4:	0e 94 e1 1c 	call	0x39c2	; 0x39c2 <initDAC>
	initDACTimer();
    3af8:	0e 94 66 1d 	call	0x3acc	; 0x3acc <initDACTimer>
	initGenDMA();
    3afc:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <initGenDMA>
    
       xQAMchannel_1=xEventGroupCreate();
    3b00:	0e 94 76 02 	call	0x4ec	; 0x4ec <xEventGroupCreate>
    3b04:	80 93 47 30 	sts	0x3047, r24	; 0x803047 <xQAMchannel_1>
    3b08:	90 93 48 30 	sts	0x3048, r25	; 0x803048 <xQAMchannel_1+0x1>
       xQAMchannel_2=xEventGroupCreate();
    3b0c:	0e 94 76 02 	call	0x4ec	; 0x4ec <xEventGroupCreate>
    3b10:	80 93 49 30 	sts	0x3049, r24	; 0x803049 <xQAMchannel_2>
    3b14:	90 93 4a 30 	sts	0x304A, r25	; 0x80304a <xQAMchannel_2+0x1>
       xQueue_Data = xQueueCreate( 1, sizeof(uint8_t)*NR_OF_DATA_SAMPLES);
    3b18:	40 e0       	ldi	r20, 0x00	; 0
    3b1a:	60 e2       	ldi	r22, 0x20	; 32
    3b1c:	81 e0       	ldi	r24, 0x01	; 1
    3b1e:	0e 94 ac 07 	call	0xf58	; 0xf58 <xQueueGenericCreate>
    3b22:	80 93 4b 30 	sts	0x304B, r24	; 0x80304b <xQueue_Data>
    3b26:	90 93 4c 30 	sts	0x304C, r25	; 0x80304c <xQueue_Data+0x1>
    
        xTaskCreate(vsendFrame, NULL, configMINIMAL_STACK_SIZE+400, NULL, 2, &xsendFrame);
    3b2a:	0f 2e       	mov	r0, r31
    3b2c:	fd e4       	ldi	r31, 0x4D	; 77
    3b2e:	ef 2e       	mov	r14, r31
    3b30:	f0 e3       	ldi	r31, 0x30	; 48
    3b32:	ff 2e       	mov	r15, r31
    3b34:	f0 2d       	mov	r31, r0
    3b36:	02 e0       	ldi	r16, 0x02	; 2
    3b38:	20 e0       	ldi	r18, 0x00	; 0
    3b3a:	30 e0       	ldi	r19, 0x00	; 0
    3b3c:	48 e5       	ldi	r20, 0x58	; 88
    3b3e:	52 e0       	ldi	r21, 0x02	; 2
    3b40:	60 e0       	ldi	r22, 0x00	; 0
    3b42:	70 e0       	ldi	r23, 0x00	; 0
    3b44:	87 e7       	ldi	r24, 0x77	; 119
    3b46:	9b e1       	ldi	r25, 0x1B	; 27
    3b48:	0e 94 46 0a 	call	0x148c	; 0x148c <xTaskCreate>
	
	for(;;) {
		vTaskDelay(1000/portTICK_RATE_MS);
    3b4c:	68 ee       	ldi	r22, 0xE8	; 232
    3b4e:	73 e0       	ldi	r23, 0x03	; 3
    3b50:	80 e0       	ldi	r24, 0x00	; 0
    3b52:	90 e0       	ldi	r25, 0x00	; 0
    3b54:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <vTaskDelay>
    3b58:	f9 cf       	rjmp	.-14     	; 0x3b4c <vQuamGen+0x58>

00003b5a <fillBuffer>:
	}
}

void fillBuffer(uint16_t buffer[NR_OF_GENERATOR_SAMPLES]) {
    3b5a:	cf 93       	push	r28
    3b5c:	df 93       	push	r29
    3b5e:	d8 2f       	mov	r29, r24
    3b60:	c9 2f       	mov	r28, r25
    
    uint8_t  EventGroupBits= xEventGroupGetBitsFromISR(xQAMchannel_1);
    3b62:	80 91 47 30 	lds	r24, 0x3047	; 0x803047 <xQAMchannel_1>
    3b66:	90 91 48 30 	lds	r25, 0x3048	; 0x803048 <xQAMchannel_1+0x1>
    3b6a:	0e 94 71 03 	call	0x6e2	; 0x6e2 <xEventGroupGetBitsFromISR>
	if(EventGroupBits&ein_kHZ_1_00V)
	{
		ein_kHz_amplitude Amplitude = amp_100;
	}*/
	
    switch(EventGroupBits)
    3b6e:	60 32       	cpi	r22, 0x20	; 32
    3b70:	c1 f0       	breq	.+48     	; 0x3ba2 <fillBuffer+0x48>
    3b72:	18 f4       	brcc	.+6      	; 0x3b7a <fillBuffer+0x20>
    3b74:	60 31       	cpi	r22, 0x10	; 16
    3b76:	31 f0       	breq	.+12     	; 0x3b84 <fillBuffer+0x2a>
    3b78:	40 c0       	rjmp	.+128    	; 0x3bfa <fillBuffer+0xa0>
    3b7a:	60 34       	cpi	r22, 0x40	; 64
    3b7c:	09 f1       	breq	.+66     	; 0x3bc0 <fillBuffer+0x66>
    3b7e:	60 38       	cpi	r22, 0x80	; 128
    3b80:	71 f1       	breq	.+92     	; 0x3bde <fillBuffer+0x84>
    3b82:	3b c0       	rjmp	.+118    	; 0x3bfa <fillBuffer+0xa0>
    3b84:	ee e7       	ldi	r30, 0x7E	; 126
    3b86:	f2 e2       	ldi	r31, 0x22	; 34
    3b88:	ad 2f       	mov	r26, r29
    3b8a:	bc 2f       	mov	r27, r28
    3b8c:	2e eb       	ldi	r18, 0xBE	; 190
    3b8e:	32 e2       	ldi	r19, 0x22	; 34
	{
		case ein_kHz_0_25V:
		{
        		for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
	        		buffer[i] = 0x800+(sinLookup1k0_25V[i]); //0x800 war offset
    3b90:	81 91       	ld	r24, Z+
    3b92:	91 91       	ld	r25, Z+
    3b94:	98 5f       	subi	r25, 0xF8	; 248
    3b96:	8d 93       	st	X+, r24
    3b98:	9d 93       	st	X+, r25
	
    switch(EventGroupBits)
	{
		case ein_kHz_0_25V:
		{
        		for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
    3b9a:	2e 17       	cp	r18, r30
    3b9c:	3f 07       	cpc	r19, r31
    3b9e:	c1 f7       	brne	.-16     	; 0x3b90 <fillBuffer+0x36>
    3ba0:	2c c0       	rjmp	.+88     	; 0x3bfa <fillBuffer+0xa0>
    3ba2:	ee e3       	ldi	r30, 0x3E	; 62
    3ba4:	f2 e2       	ldi	r31, 0x22	; 34
    3ba6:	ad 2f       	mov	r26, r29
    3ba8:	bc 2f       	mov	r27, r28
    3baa:	2e e7       	ldi	r18, 0x7E	; 126
    3bac:	32 e2       	ldi	r19, 0x22	; 34
		}

		case ein_kHz_0_50V:
		{
			for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
				buffer[i] = 0x800+(sinLookup1k0_5V[i]); //0x800 war offset
    3bae:	81 91       	ld	r24, Z+
    3bb0:	91 91       	ld	r25, Z+
    3bb2:	98 5f       	subi	r25, 0xF8	; 248
    3bb4:	8d 93       	st	X+, r24
    3bb6:	9d 93       	st	X+, r25
		break;
		}

		case ein_kHz_0_50V:
		{
			for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
    3bb8:	2e 17       	cp	r18, r30
    3bba:	3f 07       	cpc	r19, r31
    3bbc:	c1 f7       	brne	.-16     	; 0x3bae <fillBuffer+0x54>
    3bbe:	1d c0       	rjmp	.+58     	; 0x3bfa <fillBuffer+0xa0>
    3bc0:	ee ef       	ldi	r30, 0xFE	; 254
    3bc2:	f1 e2       	ldi	r31, 0x21	; 33
    3bc4:	ad 2f       	mov	r26, r29
    3bc6:	bc 2f       	mov	r27, r28
    3bc8:	2e e3       	ldi	r18, 0x3E	; 62
    3bca:	32 e2       	ldi	r19, 0x22	; 34
		}

		case ein_kHZ_0_75V:
		{
			for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
				buffer[i] = 0x800+(sinLookup1k0_75V[i]); //0x800 war offset
    3bcc:	81 91       	ld	r24, Z+
    3bce:	91 91       	ld	r25, Z+
    3bd0:	98 5f       	subi	r25, 0xF8	; 248
    3bd2:	8d 93       	st	X+, r24
    3bd4:	9d 93       	st	X+, r25
		break;
		}

		case ein_kHZ_0_75V:
		{
			for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
    3bd6:	2e 17       	cp	r18, r30
    3bd8:	3f 07       	cpc	r19, r31
    3bda:	c1 f7       	brne	.-16     	; 0x3bcc <fillBuffer+0x72>
    3bdc:	0e c0       	rjmp	.+28     	; 0x3bfa <fillBuffer+0xa0>
    3bde:	ee eb       	ldi	r30, 0xBE	; 190
    3be0:	f1 e2       	ldi	r31, 0x21	; 33
    3be2:	ad 2f       	mov	r26, r29
    3be4:	bc 2f       	mov	r27, r28
    3be6:	2e ef       	ldi	r18, 0xFE	; 254
    3be8:	31 e2       	ldi	r19, 0x21	; 33
		}

		case ein_kHZ_1_00V:
		{
			for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
				buffer[i] = 0x800+(sinLookup1k1V[i]); //0x800 war offset
    3bea:	81 91       	ld	r24, Z+
    3bec:	91 91       	ld	r25, Z+
    3bee:	98 5f       	subi	r25, 0xF8	; 248
    3bf0:	8d 93       	st	X+, r24
    3bf2:	9d 93       	st	X+, r25
		break;
		}

		case ein_kHZ_1_00V:
		{
			for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
    3bf4:	e2 17       	cp	r30, r18
    3bf6:	f3 07       	cpc	r31, r19
    3bf8:	c1 f7       	brne	.-16     	; 0x3bea <fillBuffer+0x90>
			};
		break;
		}
	}
		
        xEventGroupSetBits(xQAMchannel_1,DATEN_AUFBEREITET);
    3bfa:	44 e0       	ldi	r20, 0x04	; 4
    3bfc:	50 e0       	ldi	r21, 0x00	; 0
    3bfe:	60 e0       	ldi	r22, 0x00	; 0
    3c00:	70 e0       	ldi	r23, 0x00	; 0
    3c02:	80 91 47 30 	lds	r24, 0x3047	; 0x803047 <xQAMchannel_1>
    3c06:	90 91 48 30 	lds	r25, 0x3048	; 0x803048 <xQAMchannel_1+0x1>
    3c0a:	0e 94 80 03 	call	0x700	; 0x700 <xEventGroupSetBits>
}
    3c0e:	df 91       	pop	r29
    3c10:	cf 91       	pop	r28
    3c12:	08 95       	ret

00003c14 <fillBuffer_1>:

// Mit ISR EventGroups arbeiten, da der Interrupt Buffer fllt
void fillBuffer_1(uint16_t buffer[NR_OF_GENERATOR_SAMPLES]) {
    3c14:	0f 93       	push	r16
    3c16:	1f 93       	push	r17
    3c18:	cf 93       	push	r28
    3c1a:	df 93       	push	r29
    3c1c:	1f 92       	push	r1
    3c1e:	1f 92       	push	r1
    3c20:	cd b7       	in	r28, 0x3d	; 61
    3c22:	de b7       	in	r29, 0x3e	; 62
    3c24:	08 2f       	mov	r16, r24
    3c26:	19 2f       	mov	r17, r25
    static uint8_t Amp_1=1;
    volatile uint16_t  EventGroupBits= xEventGroupGetBitsFromISR(xQAMchannel_2);
    3c28:	80 91 49 30 	lds	r24, 0x3049	; 0x803049 <xQAMchannel_2>
    3c2c:	90 91 4a 30 	lds	r25, 0x304A	; 0x80304a <xQAMchannel_2+0x1>
    3c30:	0e 94 71 03 	call	0x6e2	; 0x6e2 <xEventGroupGetBitsFromISR>
    3c34:	69 83       	std	Y+1, r22	; 0x01
    3c36:	7a 83       	std	Y+2, r23	; 0x02
    Amp_1++;
    3c38:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    3c3c:	8f 5f       	subi	r24, 0xFF	; 255
    3c3e:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
   switch(EventGroupBits)
    3c42:	89 81       	ldd	r24, Y+1	; 0x01
    3c44:	9a 81       	ldd	r25, Y+2	; 0x02
    3c46:	81 15       	cp	r24, r1
    3c48:	22 e0       	ldi	r18, 0x02	; 2
    3c4a:	92 07       	cpc	r25, r18
    3c4c:	e1 f0       	breq	.+56     	; 0x3c86 <fillBuffer_1+0x72>
    3c4e:	20 f4       	brcc	.+8      	; 0x3c58 <fillBuffer_1+0x44>
    3c50:	81 15       	cp	r24, r1
    3c52:	91 40       	sbci	r25, 0x01	; 1
    3c54:	49 f0       	breq	.+18     	; 0x3c68 <fillBuffer_1+0x54>
    3c56:	43 c0       	rjmp	.+134    	; 0x3cde <fillBuffer_1+0xca>
    3c58:	81 15       	cp	r24, r1
    3c5a:	24 e0       	ldi	r18, 0x04	; 4
    3c5c:	92 07       	cpc	r25, r18
    3c5e:	11 f1       	breq	.+68     	; 0x3ca4 <fillBuffer_1+0x90>
    3c60:	81 15       	cp	r24, r1
    3c62:	98 40       	sbci	r25, 0x08	; 8
    3c64:	71 f1       	breq	.+92     	; 0x3cc2 <fillBuffer_1+0xae>
    3c66:	3b c0       	rjmp	.+118    	; 0x3cde <fillBuffer_1+0xca>
    3c68:	ee e7       	ldi	r30, 0x7E	; 126
    3c6a:	f1 e2       	ldi	r31, 0x21	; 33
    3c6c:	a0 2f       	mov	r26, r16
    3c6e:	b1 2f       	mov	r27, r17
    3c70:	2e eb       	ldi	r18, 0xBE	; 190
    3c72:	31 e2       	ldi	r19, 0x21	; 33
   {
	   case zwei_kHz_0_25V:
	   {
		   for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
			   buffer[i] = 0x800+(sinLookup2k0_25V[i]); //0x800 war offset
    3c74:	81 91       	ld	r24, Z+
    3c76:	91 91       	ld	r25, Z+
    3c78:	98 5f       	subi	r25, 0xF8	; 248
    3c7a:	8d 93       	st	X+, r24
    3c7c:	9d 93       	st	X+, r25
    Amp_1++;
   switch(EventGroupBits)
   {
	   case zwei_kHz_0_25V:
	   {
		   for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
    3c7e:	2e 17       	cp	r18, r30
    3c80:	3f 07       	cpc	r19, r31
    3c82:	c1 f7       	brne	.-16     	; 0x3c74 <fillBuffer_1+0x60>
    3c84:	2c c0       	rjmp	.+88     	; 0x3cde <fillBuffer_1+0xca>
    3c86:	ee e3       	ldi	r30, 0x3E	; 62
    3c88:	f1 e2       	ldi	r31, 0x21	; 33
    3c8a:	a0 2f       	mov	r26, r16
    3c8c:	b1 2f       	mov	r27, r17
    3c8e:	2e e7       	ldi	r18, 0x7E	; 126
    3c90:	31 e2       	ldi	r19, 0x21	; 33
	   }

	   case zwei_kHz_0_50V:
	   {
		   for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
			   buffer[i] = 0x800+(sinLookup2k0_5V[i]); //0x800 war offset
    3c92:	81 91       	ld	r24, Z+
    3c94:	91 91       	ld	r25, Z+
    3c96:	98 5f       	subi	r25, 0xF8	; 248
    3c98:	8d 93       	st	X+, r24
    3c9a:	9d 93       	st	X+, r25
		   break;
	   }

	   case zwei_kHz_0_50V:
	   {
		   for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
    3c9c:	2e 17       	cp	r18, r30
    3c9e:	3f 07       	cpc	r19, r31
    3ca0:	c1 f7       	brne	.-16     	; 0x3c92 <fillBuffer_1+0x7e>
    3ca2:	1d c0       	rjmp	.+58     	; 0x3cde <fillBuffer_1+0xca>
    3ca4:	ee ef       	ldi	r30, 0xFE	; 254
    3ca6:	f0 e2       	ldi	r31, 0x20	; 32
    3ca8:	a0 2f       	mov	r26, r16
    3caa:	b1 2f       	mov	r27, r17
    3cac:	2e e3       	ldi	r18, 0x3E	; 62
    3cae:	31 e2       	ldi	r19, 0x21	; 33
	   }

	   case zwei_kHz_0_75V:
	   {
		   for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
			   buffer[i] = 0x800+(sinLookup2k0_75V[i]); //0x800 war offset
    3cb0:	81 91       	ld	r24, Z+
    3cb2:	91 91       	ld	r25, Z+
    3cb4:	98 5f       	subi	r25, 0xF8	; 248
    3cb6:	8d 93       	st	X+, r24
    3cb8:	9d 93       	st	X+, r25
		   break;
	   }

	   case zwei_kHz_0_75V:
	   {
		   for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
    3cba:	2e 17       	cp	r18, r30
    3cbc:	3f 07       	cpc	r19, r31
    3cbe:	c1 f7       	brne	.-16     	; 0x3cb0 <fillBuffer_1+0x9c>
    3cc0:	0e c0       	rjmp	.+28     	; 0x3cde <fillBuffer_1+0xca>
    3cc2:	ee eb       	ldi	r30, 0xBE	; 190
    3cc4:	f0 e2       	ldi	r31, 0x20	; 32
    3cc6:	a0 2f       	mov	r26, r16
    3cc8:	b1 2f       	mov	r27, r17
    3cca:	2e ef       	ldi	r18, 0xFE	; 254
    3ccc:	30 e2       	ldi	r19, 0x20	; 32
	   }

	   case zwei_kHz_1_00V:
	   {
		   for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
			   buffer[i] = 0x800+(sinLookup2k1V[i]); //0x800 war offset
    3cce:	81 91       	ld	r24, Z+
    3cd0:	91 91       	ld	r25, Z+
    3cd2:	98 5f       	subi	r25, 0xF8	; 248
    3cd4:	8d 93       	st	X+, r24
    3cd6:	9d 93       	st	X+, r25
		   break;
	   }

	   case zwei_kHz_1_00V:
	   {
		   for(int i = 0; i < NR_OF_GENERATOR_SAMPLES;i++) {
    3cd8:	e2 17       	cp	r30, r18
    3cda:	f3 07       	cpc	r31, r19
    3cdc:	c1 f7       	brne	.-16     	; 0x3cce <fillBuffer_1+0xba>
		   };
		   break;
	   }
   }
   
   xEventGroupSetBits(xQAMchannel_2,DATEN_AUFBEREITET);
    3cde:	44 e0       	ldi	r20, 0x04	; 4
    3ce0:	50 e0       	ldi	r21, 0x00	; 0
    3ce2:	60 e0       	ldi	r22, 0x00	; 0
    3ce4:	70 e0       	ldi	r23, 0x00	; 0
    3ce6:	80 91 49 30 	lds	r24, 0x3049	; 0x803049 <xQAMchannel_2>
    3cea:	90 91 4a 30 	lds	r25, 0x304A	; 0x80304a <xQAMchannel_2+0x1>
    3cee:	0e 94 80 03 	call	0x700	; 0x700 <xEventGroupSetBits>
   }
    3cf2:	0f 90       	pop	r0
    3cf4:	0f 90       	pop	r0
    3cf6:	df 91       	pop	r29
    3cf8:	cf 91       	pop	r28
    3cfa:	1f 91       	pop	r17
    3cfc:	0f 91       	pop	r16
    3cfe:	08 95       	ret

00003d00 <__vector_6>:

ISR(DMA_CH0_vect)
{
    3d00:	1f 92       	push	r1
    3d02:	0f 92       	push	r0
    3d04:	0f b6       	in	r0, 0x3f	; 63
    3d06:	0f 92       	push	r0
    3d08:	11 24       	eor	r1, r1
    3d0a:	0b b6       	in	r0, 0x3b	; 59
    3d0c:	0f 92       	push	r0
    3d0e:	2f 93       	push	r18
    3d10:	3f 93       	push	r19
    3d12:	4f 93       	push	r20
    3d14:	5f 93       	push	r21
    3d16:	6f 93       	push	r22
    3d18:	7f 93       	push	r23
    3d1a:	8f 93       	push	r24
    3d1c:	9f 93       	push	r25
    3d1e:	af 93       	push	r26
    3d20:	bf 93       	push	r27
    3d22:	ef 93       	push	r30
    3d24:	ff 93       	push	r31
	DMA.CH0.CTRLB|=0x10;
    3d26:	e0 e0       	ldi	r30, 0x00	; 0
    3d28:	f1 e0       	ldi	r31, 0x01	; 1
    3d2a:	81 89       	ldd	r24, Z+17	; 0x11
    3d2c:	80 61       	ori	r24, 0x10	; 16
    3d2e:	81 8b       	std	Z+17, r24	; 0x11
	fillBuffer(&dacBuffer0[0]);
    3d30:	8a ef       	ldi	r24, 0xFA	; 250
    3d32:	9f e2       	ldi	r25, 0x2F	; 47
    3d34:	0e 94 ad 1d 	call	0x3b5a	; 0x3b5a <fillBuffer>
}
    3d38:	ff 91       	pop	r31
    3d3a:	ef 91       	pop	r30
    3d3c:	bf 91       	pop	r27
    3d3e:	af 91       	pop	r26
    3d40:	9f 91       	pop	r25
    3d42:	8f 91       	pop	r24
    3d44:	7f 91       	pop	r23
    3d46:	6f 91       	pop	r22
    3d48:	5f 91       	pop	r21
    3d4a:	4f 91       	pop	r20
    3d4c:	3f 91       	pop	r19
    3d4e:	2f 91       	pop	r18
    3d50:	0f 90       	pop	r0
    3d52:	0b be       	out	0x3b, r0	; 59
    3d54:	0f 90       	pop	r0
    3d56:	0f be       	out	0x3f, r0	; 63
    3d58:	0f 90       	pop	r0
    3d5a:	1f 90       	pop	r1
    3d5c:	18 95       	reti

00003d5e <__vector_7>:

ISR(DMA_CH1_vect)
{
    3d5e:	1f 92       	push	r1
    3d60:	0f 92       	push	r0
    3d62:	0f b6       	in	r0, 0x3f	; 63
    3d64:	0f 92       	push	r0
    3d66:	11 24       	eor	r1, r1
    3d68:	0b b6       	in	r0, 0x3b	; 59
    3d6a:	0f 92       	push	r0
    3d6c:	2f 93       	push	r18
    3d6e:	3f 93       	push	r19
    3d70:	4f 93       	push	r20
    3d72:	5f 93       	push	r21
    3d74:	6f 93       	push	r22
    3d76:	7f 93       	push	r23
    3d78:	8f 93       	push	r24
    3d7a:	9f 93       	push	r25
    3d7c:	af 93       	push	r26
    3d7e:	bf 93       	push	r27
    3d80:	ef 93       	push	r30
    3d82:	ff 93       	push	r31
	DMA.CH1.CTRLB|=0x10;
    3d84:	e0 e0       	ldi	r30, 0x00	; 0
    3d86:	f1 e0       	ldi	r31, 0x01	; 1
    3d88:	81 a1       	ldd	r24, Z+33	; 0x21
    3d8a:	80 61       	ori	r24, 0x10	; 16
    3d8c:	81 a3       	std	Z+33, r24	; 0x21
	fillBuffer(&dacBuffer1[0]);
    3d8e:	8a eb       	ldi	r24, 0xBA	; 186
    3d90:	9f e2       	ldi	r25, 0x2F	; 47
    3d92:	0e 94 ad 1d 	call	0x3b5a	; 0x3b5a <fillBuffer>
}
    3d96:	ff 91       	pop	r31
    3d98:	ef 91       	pop	r30
    3d9a:	bf 91       	pop	r27
    3d9c:	af 91       	pop	r26
    3d9e:	9f 91       	pop	r25
    3da0:	8f 91       	pop	r24
    3da2:	7f 91       	pop	r23
    3da4:	6f 91       	pop	r22
    3da6:	5f 91       	pop	r21
    3da8:	4f 91       	pop	r20
    3daa:	3f 91       	pop	r19
    3dac:	2f 91       	pop	r18
    3dae:	0f 90       	pop	r0
    3db0:	0b be       	out	0x3b, r0	; 59
    3db2:	0f 90       	pop	r0
    3db4:	0f be       	out	0x3f, r0	; 63
    3db6:	0f 90       	pop	r0
    3db8:	1f 90       	pop	r1
    3dba:	18 95       	reti

00003dbc <__vector_8>:

ISR(DMA_CH2_vect)
{
    3dbc:	1f 92       	push	r1
    3dbe:	0f 92       	push	r0
    3dc0:	0f b6       	in	r0, 0x3f	; 63
    3dc2:	0f 92       	push	r0
    3dc4:	11 24       	eor	r1, r1
    3dc6:	0b b6       	in	r0, 0x3b	; 59
    3dc8:	0f 92       	push	r0
    3dca:	2f 93       	push	r18
    3dcc:	3f 93       	push	r19
    3dce:	4f 93       	push	r20
    3dd0:	5f 93       	push	r21
    3dd2:	6f 93       	push	r22
    3dd4:	7f 93       	push	r23
    3dd6:	8f 93       	push	r24
    3dd8:	9f 93       	push	r25
    3dda:	af 93       	push	r26
    3ddc:	bf 93       	push	r27
    3dde:	ef 93       	push	r30
    3de0:	ff 93       	push	r31
    
    DMA.CH2.CTRLB|=0x10;
    3de2:	e0 e0       	ldi	r30, 0x00	; 0
    3de4:	f1 e0       	ldi	r31, 0x01	; 1
    3de6:	81 a9       	ldd	r24, Z+49	; 0x31
    3de8:	80 61       	ori	r24, 0x10	; 16
    3dea:	81 ab       	std	Z+49, r24	; 0x31
    fillBuffer_1(&dacBuffer2[0]);
    3dec:	8a e7       	ldi	r24, 0x7A	; 122
    3dee:	9f e2       	ldi	r25, 0x2F	; 47
    3df0:	0e 94 0a 1e 	call	0x3c14	; 0x3c14 <fillBuffer_1>
}
    3df4:	ff 91       	pop	r31
    3df6:	ef 91       	pop	r30
    3df8:	bf 91       	pop	r27
    3dfa:	af 91       	pop	r26
    3dfc:	9f 91       	pop	r25
    3dfe:	8f 91       	pop	r24
    3e00:	7f 91       	pop	r23
    3e02:	6f 91       	pop	r22
    3e04:	5f 91       	pop	r21
    3e06:	4f 91       	pop	r20
    3e08:	3f 91       	pop	r19
    3e0a:	2f 91       	pop	r18
    3e0c:	0f 90       	pop	r0
    3e0e:	0b be       	out	0x3b, r0	; 59
    3e10:	0f 90       	pop	r0
    3e12:	0f be       	out	0x3f, r0	; 63
    3e14:	0f 90       	pop	r0
    3e16:	1f 90       	pop	r1
    3e18:	18 95       	reti

00003e1a <__vector_9>:

ISR(DMA_CH3_vect)
{
    3e1a:	1f 92       	push	r1
    3e1c:	0f 92       	push	r0
    3e1e:	0f b6       	in	r0, 0x3f	; 63
    3e20:	0f 92       	push	r0
    3e22:	11 24       	eor	r1, r1
    3e24:	0b b6       	in	r0, 0x3b	; 59
    3e26:	0f 92       	push	r0
    3e28:	2f 93       	push	r18
    3e2a:	3f 93       	push	r19
    3e2c:	4f 93       	push	r20
    3e2e:	5f 93       	push	r21
    3e30:	6f 93       	push	r22
    3e32:	7f 93       	push	r23
    3e34:	8f 93       	push	r24
    3e36:	9f 93       	push	r25
    3e38:	af 93       	push	r26
    3e3a:	bf 93       	push	r27
    3e3c:	ef 93       	push	r30
    3e3e:	ff 93       	push	r31
    DMA.CH3.CTRLB|=0x10;
    3e40:	e1 e4       	ldi	r30, 0x41	; 65
    3e42:	f1 e0       	ldi	r31, 0x01	; 1
    3e44:	80 81       	ld	r24, Z
    3e46:	80 61       	ori	r24, 0x10	; 16
    3e48:	80 83       	st	Z, r24
    fillBuffer_1(&dacBuffer3[0]);
    3e4a:	8a e3       	ldi	r24, 0x3A	; 58
    3e4c:	9f e2       	ldi	r25, 0x2F	; 47
    3e4e:	0e 94 0a 1e 	call	0x3c14	; 0x3c14 <fillBuffer_1>
}
    3e52:	ff 91       	pop	r31
    3e54:	ef 91       	pop	r30
    3e56:	bf 91       	pop	r27
    3e58:	af 91       	pop	r26
    3e5a:	9f 91       	pop	r25
    3e5c:	8f 91       	pop	r24
    3e5e:	7f 91       	pop	r23
    3e60:	6f 91       	pop	r22
    3e62:	5f 91       	pop	r21
    3e64:	4f 91       	pop	r20
    3e66:	3f 91       	pop	r19
    3e68:	2f 91       	pop	r18
    3e6a:	0f 90       	pop	r0
    3e6c:	0b be       	out	0x3b, r0	; 59
    3e6e:	0f 90       	pop	r0
    3e70:	0f be       	out	0x3f, r0	; 63
    3e72:	0f 90       	pop	r0
    3e74:	1f 90       	pop	r1
    3e76:	18 95       	reti

00003e78 <vsendCommand>:

void vsendCommand(uint8_t Data[])
{
    3e78:	0f 93       	push	r16

    if( xQueue_Data != 0 )
    3e7a:	e0 91 4b 30 	lds	r30, 0x304B	; 0x80304b <xQueue_Data>
    3e7e:	f0 91 4c 30 	lds	r31, 0x304C	; 0x80304c <xQueue_Data+0x1>
    3e82:	30 97       	sbiw	r30, 0x00	; 0
    3e84:	49 f0       	breq	.+18     	; 0x3e98 <vsendCommand+0x20>
    3e86:	bc 01       	movw	r22, r24
    {
        /* Put data to send to xQueue_Data. */
        xQueueSend(xQueue_Data,(void *)Data,pdMS_TO_TICKS(10));
    3e88:	00 e0       	ldi	r16, 0x00	; 0
    3e8a:	2a e0       	ldi	r18, 0x0A	; 10
    3e8c:	30 e0       	ldi	r19, 0x00	; 0
    3e8e:	40 e0       	ldi	r20, 0x00	; 0
    3e90:	50 e0       	ldi	r21, 0x00	; 0
    3e92:	cf 01       	movw	r24, r30
    3e94:	0e 94 dd 07 	call	0xfba	; 0xfba <xQueueGenericSend>
    }    
}
    3e98:	0f 91       	pop	r16
    3e9a:	08 95       	ret

00003e9c <getResetReason>:
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
	 // software reset ?
	 if( RST.STATUS & RST_SRF_bm )
    3e9c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3ea0:	85 ff       	sbrs	r24, 5
    3ea2:	05 c0       	rjmp	.+10     	; 0x3eae <getResetReason+0x12>
	 {
		 // reset this bit
		 RST.STATUS = RST_SRF_bm;
    3ea4:	80 e2       	ldi	r24, 0x20	; 32
    3ea6:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_SOFTWARERESET;
    3eaa:	81 e0       	ldi	r24, 0x01	; 1
    3eac:	08 95       	ret
	 }
	 // power on reset ?
	 else if( RST.STATUS & RST_PORF_bm)
    3eae:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3eb2:	80 ff       	sbrs	r24, 0
    3eb4:	05 c0       	rjmp	.+10     	; 0x3ec0 <getResetReason+0x24>
	 {
		 // reset this bit
		 RST.STATUS = RST_PORF_bm;
    3eb6:	81 e0       	ldi	r24, 0x01	; 1
    3eb8:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_POWERONRESET;
    3ebc:	82 e0       	ldi	r24, 0x02	; 2
    3ebe:	08 95       	ret
	 }
	 // debugger reset ?
	 else if( RST.STATUS & RST_PDIRF_bm)
    3ec0:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3ec4:	84 ff       	sbrs	r24, 4
    3ec6:	05 c0       	rjmp	.+10     	; 0x3ed2 <getResetReason+0x36>
	 {
		 // reset this bit
		 RST.STATUS = RST_PDIRF_bm;
    3ec8:	80 e1       	ldi	r24, 0x10	; 16
    3eca:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_DEBUGGERRESET;
    3ece:	83 e0       	ldi	r24, 0x03	; 3
    3ed0:	08 95       	ret
	 }
	 // external reset ?
	 else if( RST.STATUS & RST_EXTRF_bm)
    3ed2:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3ed6:	81 ff       	sbrs	r24, 1
    3ed8:	05 c0       	rjmp	.+10     	; 0x3ee4 <getResetReason+0x48>
	 {
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
    3eda:	82 e0       	ldi	r24, 0x02	; 2
    3edc:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_EXTERNALRESET;
    3ee0:	84 e0       	ldi	r24, 0x04	; 4
    3ee2:	08 95       	ret
 */ 
 #include "avr_compiler.h"
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
    3ee4:	82 e0       	ldi	r24, 0x02	; 2
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
		 returnValue = RESETREASON_EXTERNALRESET;
	 }
	 return returnValue;
    3ee6:	08 95       	ret

00003ee8 <__subsf3>:
    3ee8:	50 58       	subi	r21, 0x80	; 128

00003eea <__addsf3>:
    3eea:	bb 27       	eor	r27, r27
    3eec:	aa 27       	eor	r26, r26
    3eee:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <__addsf3x>
    3ef2:	0c 94 06 21 	jmp	0x420c	; 0x420c <__fp_round>
    3ef6:	0e 94 f8 20 	call	0x41f0	; 0x41f0 <__fp_pscA>
    3efa:	38 f0       	brcs	.+14     	; 0x3f0a <__addsf3+0x20>
    3efc:	0e 94 ff 20 	call	0x41fe	; 0x41fe <__fp_pscB>
    3f00:	20 f0       	brcs	.+8      	; 0x3f0a <__addsf3+0x20>
    3f02:	39 f4       	brne	.+14     	; 0x3f12 <__addsf3+0x28>
    3f04:	9f 3f       	cpi	r25, 0xFF	; 255
    3f06:	19 f4       	brne	.+6      	; 0x3f0e <__addsf3+0x24>
    3f08:	26 f4       	brtc	.+8      	; 0x3f12 <__addsf3+0x28>
    3f0a:	0c 94 f5 20 	jmp	0x41ea	; 0x41ea <__fp_nan>
    3f0e:	0e f4       	brtc	.+2      	; 0x3f12 <__addsf3+0x28>
    3f10:	e0 95       	com	r30
    3f12:	e7 fb       	bst	r30, 7
    3f14:	0c 94 ef 20 	jmp	0x41de	; 0x41de <__fp_inf>

00003f18 <__addsf3x>:
    3f18:	e9 2f       	mov	r30, r25
    3f1a:	0e 94 17 21 	call	0x422e	; 0x422e <__fp_split3>
    3f1e:	58 f3       	brcs	.-42     	; 0x3ef6 <__addsf3+0xc>
    3f20:	ba 17       	cp	r27, r26
    3f22:	62 07       	cpc	r22, r18
    3f24:	73 07       	cpc	r23, r19
    3f26:	84 07       	cpc	r24, r20
    3f28:	95 07       	cpc	r25, r21
    3f2a:	20 f0       	brcs	.+8      	; 0x3f34 <__addsf3x+0x1c>
    3f2c:	79 f4       	brne	.+30     	; 0x3f4c <__addsf3x+0x34>
    3f2e:	a6 f5       	brtc	.+104    	; 0x3f98 <__addsf3x+0x80>
    3f30:	0c 94 39 21 	jmp	0x4272	; 0x4272 <__fp_zero>
    3f34:	0e f4       	brtc	.+2      	; 0x3f38 <__addsf3x+0x20>
    3f36:	e0 95       	com	r30
    3f38:	0b 2e       	mov	r0, r27
    3f3a:	ba 2f       	mov	r27, r26
    3f3c:	a0 2d       	mov	r26, r0
    3f3e:	0b 01       	movw	r0, r22
    3f40:	b9 01       	movw	r22, r18
    3f42:	90 01       	movw	r18, r0
    3f44:	0c 01       	movw	r0, r24
    3f46:	ca 01       	movw	r24, r20
    3f48:	a0 01       	movw	r20, r0
    3f4a:	11 24       	eor	r1, r1
    3f4c:	ff 27       	eor	r31, r31
    3f4e:	59 1b       	sub	r21, r25
    3f50:	99 f0       	breq	.+38     	; 0x3f78 <__addsf3x+0x60>
    3f52:	59 3f       	cpi	r21, 0xF9	; 249
    3f54:	50 f4       	brcc	.+20     	; 0x3f6a <__addsf3x+0x52>
    3f56:	50 3e       	cpi	r21, 0xE0	; 224
    3f58:	68 f1       	brcs	.+90     	; 0x3fb4 <__addsf3x+0x9c>
    3f5a:	1a 16       	cp	r1, r26
    3f5c:	f0 40       	sbci	r31, 0x00	; 0
    3f5e:	a2 2f       	mov	r26, r18
    3f60:	23 2f       	mov	r18, r19
    3f62:	34 2f       	mov	r19, r20
    3f64:	44 27       	eor	r20, r20
    3f66:	58 5f       	subi	r21, 0xF8	; 248
    3f68:	f3 cf       	rjmp	.-26     	; 0x3f50 <__addsf3x+0x38>
    3f6a:	46 95       	lsr	r20
    3f6c:	37 95       	ror	r19
    3f6e:	27 95       	ror	r18
    3f70:	a7 95       	ror	r26
    3f72:	f0 40       	sbci	r31, 0x00	; 0
    3f74:	53 95       	inc	r21
    3f76:	c9 f7       	brne	.-14     	; 0x3f6a <__addsf3x+0x52>
    3f78:	7e f4       	brtc	.+30     	; 0x3f98 <__addsf3x+0x80>
    3f7a:	1f 16       	cp	r1, r31
    3f7c:	ba 0b       	sbc	r27, r26
    3f7e:	62 0b       	sbc	r22, r18
    3f80:	73 0b       	sbc	r23, r19
    3f82:	84 0b       	sbc	r24, r20
    3f84:	ba f0       	brmi	.+46     	; 0x3fb4 <__addsf3x+0x9c>
    3f86:	91 50       	subi	r25, 0x01	; 1
    3f88:	a1 f0       	breq	.+40     	; 0x3fb2 <__addsf3x+0x9a>
    3f8a:	ff 0f       	add	r31, r31
    3f8c:	bb 1f       	adc	r27, r27
    3f8e:	66 1f       	adc	r22, r22
    3f90:	77 1f       	adc	r23, r23
    3f92:	88 1f       	adc	r24, r24
    3f94:	c2 f7       	brpl	.-16     	; 0x3f86 <__addsf3x+0x6e>
    3f96:	0e c0       	rjmp	.+28     	; 0x3fb4 <__addsf3x+0x9c>
    3f98:	ba 0f       	add	r27, r26
    3f9a:	62 1f       	adc	r22, r18
    3f9c:	73 1f       	adc	r23, r19
    3f9e:	84 1f       	adc	r24, r20
    3fa0:	48 f4       	brcc	.+18     	; 0x3fb4 <__addsf3x+0x9c>
    3fa2:	87 95       	ror	r24
    3fa4:	77 95       	ror	r23
    3fa6:	67 95       	ror	r22
    3fa8:	b7 95       	ror	r27
    3faa:	f7 95       	ror	r31
    3fac:	9e 3f       	cpi	r25, 0xFE	; 254
    3fae:	08 f0       	brcs	.+2      	; 0x3fb2 <__addsf3x+0x9a>
    3fb0:	b0 cf       	rjmp	.-160    	; 0x3f12 <__addsf3+0x28>
    3fb2:	93 95       	inc	r25
    3fb4:	88 0f       	add	r24, r24
    3fb6:	08 f0       	brcs	.+2      	; 0x3fba <__addsf3x+0xa2>
    3fb8:	99 27       	eor	r25, r25
    3fba:	ee 0f       	add	r30, r30
    3fbc:	97 95       	ror	r25
    3fbe:	87 95       	ror	r24
    3fc0:	08 95       	ret

00003fc2 <__cmpsf2>:
    3fc2:	0e 94 cb 20 	call	0x4196	; 0x4196 <__fp_cmp>
    3fc6:	08 f4       	brcc	.+2      	; 0x3fca <__cmpsf2+0x8>
    3fc8:	81 e0       	ldi	r24, 0x01	; 1
    3fca:	08 95       	ret

00003fcc <__divsf3>:
    3fcc:	0e 94 fa 1f 	call	0x3ff4	; 0x3ff4 <__divsf3x>
    3fd0:	0c 94 06 21 	jmp	0x420c	; 0x420c <__fp_round>
    3fd4:	0e 94 ff 20 	call	0x41fe	; 0x41fe <__fp_pscB>
    3fd8:	58 f0       	brcs	.+22     	; 0x3ff0 <__divsf3+0x24>
    3fda:	0e 94 f8 20 	call	0x41f0	; 0x41f0 <__fp_pscA>
    3fde:	40 f0       	brcs	.+16     	; 0x3ff0 <__divsf3+0x24>
    3fe0:	29 f4       	brne	.+10     	; 0x3fec <__divsf3+0x20>
    3fe2:	5f 3f       	cpi	r21, 0xFF	; 255
    3fe4:	29 f0       	breq	.+10     	; 0x3ff0 <__divsf3+0x24>
    3fe6:	0c 94 ef 20 	jmp	0x41de	; 0x41de <__fp_inf>
    3fea:	51 11       	cpse	r21, r1
    3fec:	0c 94 3a 21 	jmp	0x4274	; 0x4274 <__fp_szero>
    3ff0:	0c 94 f5 20 	jmp	0x41ea	; 0x41ea <__fp_nan>

00003ff4 <__divsf3x>:
    3ff4:	0e 94 17 21 	call	0x422e	; 0x422e <__fp_split3>
    3ff8:	68 f3       	brcs	.-38     	; 0x3fd4 <__divsf3+0x8>

00003ffa <__divsf3_pse>:
    3ffa:	99 23       	and	r25, r25
    3ffc:	b1 f3       	breq	.-20     	; 0x3fea <__divsf3+0x1e>
    3ffe:	55 23       	and	r21, r21
    4000:	91 f3       	breq	.-28     	; 0x3fe6 <__divsf3+0x1a>
    4002:	95 1b       	sub	r25, r21
    4004:	55 0b       	sbc	r21, r21
    4006:	bb 27       	eor	r27, r27
    4008:	aa 27       	eor	r26, r26
    400a:	62 17       	cp	r22, r18
    400c:	73 07       	cpc	r23, r19
    400e:	84 07       	cpc	r24, r20
    4010:	38 f0       	brcs	.+14     	; 0x4020 <__stack+0x21>
    4012:	9f 5f       	subi	r25, 0xFF	; 255
    4014:	5f 4f       	sbci	r21, 0xFF	; 255
    4016:	22 0f       	add	r18, r18
    4018:	33 1f       	adc	r19, r19
    401a:	44 1f       	adc	r20, r20
    401c:	aa 1f       	adc	r26, r26
    401e:	a9 f3       	breq	.-22     	; 0x400a <__stack+0xb>
    4020:	35 d0       	rcall	.+106    	; 0x408c <__stack+0x8d>
    4022:	0e 2e       	mov	r0, r30
    4024:	3a f0       	brmi	.+14     	; 0x4034 <__stack+0x35>
    4026:	e0 e8       	ldi	r30, 0x80	; 128
    4028:	32 d0       	rcall	.+100    	; 0x408e <__stack+0x8f>
    402a:	91 50       	subi	r25, 0x01	; 1
    402c:	50 40       	sbci	r21, 0x00	; 0
    402e:	e6 95       	lsr	r30
    4030:	00 1c       	adc	r0, r0
    4032:	ca f7       	brpl	.-14     	; 0x4026 <__stack+0x27>
    4034:	2b d0       	rcall	.+86     	; 0x408c <__stack+0x8d>
    4036:	fe 2f       	mov	r31, r30
    4038:	29 d0       	rcall	.+82     	; 0x408c <__stack+0x8d>
    403a:	66 0f       	add	r22, r22
    403c:	77 1f       	adc	r23, r23
    403e:	88 1f       	adc	r24, r24
    4040:	bb 1f       	adc	r27, r27
    4042:	26 17       	cp	r18, r22
    4044:	37 07       	cpc	r19, r23
    4046:	48 07       	cpc	r20, r24
    4048:	ab 07       	cpc	r26, r27
    404a:	b0 e8       	ldi	r27, 0x80	; 128
    404c:	09 f0       	breq	.+2      	; 0x4050 <__stack+0x51>
    404e:	bb 0b       	sbc	r27, r27
    4050:	80 2d       	mov	r24, r0
    4052:	bf 01       	movw	r22, r30
    4054:	ff 27       	eor	r31, r31
    4056:	93 58       	subi	r25, 0x83	; 131
    4058:	5f 4f       	sbci	r21, 0xFF	; 255
    405a:	3a f0       	brmi	.+14     	; 0x406a <__stack+0x6b>
    405c:	9e 3f       	cpi	r25, 0xFE	; 254
    405e:	51 05       	cpc	r21, r1
    4060:	78 f0       	brcs	.+30     	; 0x4080 <__stack+0x81>
    4062:	0c 94 ef 20 	jmp	0x41de	; 0x41de <__fp_inf>
    4066:	0c 94 3a 21 	jmp	0x4274	; 0x4274 <__fp_szero>
    406a:	5f 3f       	cpi	r21, 0xFF	; 255
    406c:	e4 f3       	brlt	.-8      	; 0x4066 <__stack+0x67>
    406e:	98 3e       	cpi	r25, 0xE8	; 232
    4070:	d4 f3       	brlt	.-12     	; 0x4066 <__stack+0x67>
    4072:	86 95       	lsr	r24
    4074:	77 95       	ror	r23
    4076:	67 95       	ror	r22
    4078:	b7 95       	ror	r27
    407a:	f7 95       	ror	r31
    407c:	9f 5f       	subi	r25, 0xFF	; 255
    407e:	c9 f7       	brne	.-14     	; 0x4072 <__stack+0x73>
    4080:	88 0f       	add	r24, r24
    4082:	91 1d       	adc	r25, r1
    4084:	96 95       	lsr	r25
    4086:	87 95       	ror	r24
    4088:	97 f9       	bld	r25, 7
    408a:	08 95       	ret
    408c:	e1 e0       	ldi	r30, 0x01	; 1
    408e:	66 0f       	add	r22, r22
    4090:	77 1f       	adc	r23, r23
    4092:	88 1f       	adc	r24, r24
    4094:	bb 1f       	adc	r27, r27
    4096:	62 17       	cp	r22, r18
    4098:	73 07       	cpc	r23, r19
    409a:	84 07       	cpc	r24, r20
    409c:	ba 07       	cpc	r27, r26
    409e:	20 f0       	brcs	.+8      	; 0x40a8 <__stack+0xa9>
    40a0:	62 1b       	sub	r22, r18
    40a2:	73 0b       	sbc	r23, r19
    40a4:	84 0b       	sbc	r24, r20
    40a6:	ba 0b       	sbc	r27, r26
    40a8:	ee 1f       	adc	r30, r30
    40aa:	88 f7       	brcc	.-30     	; 0x408e <__stack+0x8f>
    40ac:	e0 95       	com	r30
    40ae:	08 95       	ret

000040b0 <__fixsfsi>:
    40b0:	0e 94 5f 20 	call	0x40be	; 0x40be <__fixunssfsi>
    40b4:	68 94       	set
    40b6:	b1 11       	cpse	r27, r1
    40b8:	0c 94 3a 21 	jmp	0x4274	; 0x4274 <__fp_szero>
    40bc:	08 95       	ret

000040be <__fixunssfsi>:
    40be:	0e 94 1f 21 	call	0x423e	; 0x423e <__fp_splitA>
    40c2:	88 f0       	brcs	.+34     	; 0x40e6 <__fixunssfsi+0x28>
    40c4:	9f 57       	subi	r25, 0x7F	; 127
    40c6:	98 f0       	brcs	.+38     	; 0x40ee <__fixunssfsi+0x30>
    40c8:	b9 2f       	mov	r27, r25
    40ca:	99 27       	eor	r25, r25
    40cc:	b7 51       	subi	r27, 0x17	; 23
    40ce:	b0 f0       	brcs	.+44     	; 0x40fc <__fixunssfsi+0x3e>
    40d0:	e1 f0       	breq	.+56     	; 0x410a <__fixunssfsi+0x4c>
    40d2:	66 0f       	add	r22, r22
    40d4:	77 1f       	adc	r23, r23
    40d6:	88 1f       	adc	r24, r24
    40d8:	99 1f       	adc	r25, r25
    40da:	1a f0       	brmi	.+6      	; 0x40e2 <__fixunssfsi+0x24>
    40dc:	ba 95       	dec	r27
    40de:	c9 f7       	brne	.-14     	; 0x40d2 <__fixunssfsi+0x14>
    40e0:	14 c0       	rjmp	.+40     	; 0x410a <__fixunssfsi+0x4c>
    40e2:	b1 30       	cpi	r27, 0x01	; 1
    40e4:	91 f0       	breq	.+36     	; 0x410a <__fixunssfsi+0x4c>
    40e6:	0e 94 39 21 	call	0x4272	; 0x4272 <__fp_zero>
    40ea:	b1 e0       	ldi	r27, 0x01	; 1
    40ec:	08 95       	ret
    40ee:	0c 94 39 21 	jmp	0x4272	; 0x4272 <__fp_zero>
    40f2:	67 2f       	mov	r22, r23
    40f4:	78 2f       	mov	r23, r24
    40f6:	88 27       	eor	r24, r24
    40f8:	b8 5f       	subi	r27, 0xF8	; 248
    40fa:	39 f0       	breq	.+14     	; 0x410a <__fixunssfsi+0x4c>
    40fc:	b9 3f       	cpi	r27, 0xF9	; 249
    40fe:	cc f3       	brlt	.-14     	; 0x40f2 <__fixunssfsi+0x34>
    4100:	86 95       	lsr	r24
    4102:	77 95       	ror	r23
    4104:	67 95       	ror	r22
    4106:	b3 95       	inc	r27
    4108:	d9 f7       	brne	.-10     	; 0x4100 <__fixunssfsi+0x42>
    410a:	3e f4       	brtc	.+14     	; 0x411a <__fixunssfsi+0x5c>
    410c:	90 95       	com	r25
    410e:	80 95       	com	r24
    4110:	70 95       	com	r23
    4112:	61 95       	neg	r22
    4114:	7f 4f       	sbci	r23, 0xFF	; 255
    4116:	8f 4f       	sbci	r24, 0xFF	; 255
    4118:	9f 4f       	sbci	r25, 0xFF	; 255
    411a:	08 95       	ret

0000411c <__floatunsisf>:
    411c:	e8 94       	clt
    411e:	09 c0       	rjmp	.+18     	; 0x4132 <__floatsisf+0x12>

00004120 <__floatsisf>:
    4120:	97 fb       	bst	r25, 7
    4122:	3e f4       	brtc	.+14     	; 0x4132 <__floatsisf+0x12>
    4124:	90 95       	com	r25
    4126:	80 95       	com	r24
    4128:	70 95       	com	r23
    412a:	61 95       	neg	r22
    412c:	7f 4f       	sbci	r23, 0xFF	; 255
    412e:	8f 4f       	sbci	r24, 0xFF	; 255
    4130:	9f 4f       	sbci	r25, 0xFF	; 255
    4132:	99 23       	and	r25, r25
    4134:	a9 f0       	breq	.+42     	; 0x4160 <__floatsisf+0x40>
    4136:	f9 2f       	mov	r31, r25
    4138:	96 e9       	ldi	r25, 0x96	; 150
    413a:	bb 27       	eor	r27, r27
    413c:	93 95       	inc	r25
    413e:	f6 95       	lsr	r31
    4140:	87 95       	ror	r24
    4142:	77 95       	ror	r23
    4144:	67 95       	ror	r22
    4146:	b7 95       	ror	r27
    4148:	f1 11       	cpse	r31, r1
    414a:	f8 cf       	rjmp	.-16     	; 0x413c <__floatsisf+0x1c>
    414c:	fa f4       	brpl	.+62     	; 0x418c <__floatsisf+0x6c>
    414e:	bb 0f       	add	r27, r27
    4150:	11 f4       	brne	.+4      	; 0x4156 <__floatsisf+0x36>
    4152:	60 ff       	sbrs	r22, 0
    4154:	1b c0       	rjmp	.+54     	; 0x418c <__floatsisf+0x6c>
    4156:	6f 5f       	subi	r22, 0xFF	; 255
    4158:	7f 4f       	sbci	r23, 0xFF	; 255
    415a:	8f 4f       	sbci	r24, 0xFF	; 255
    415c:	9f 4f       	sbci	r25, 0xFF	; 255
    415e:	16 c0       	rjmp	.+44     	; 0x418c <__floatsisf+0x6c>
    4160:	88 23       	and	r24, r24
    4162:	11 f0       	breq	.+4      	; 0x4168 <__floatsisf+0x48>
    4164:	96 e9       	ldi	r25, 0x96	; 150
    4166:	11 c0       	rjmp	.+34     	; 0x418a <__floatsisf+0x6a>
    4168:	77 23       	and	r23, r23
    416a:	21 f0       	breq	.+8      	; 0x4174 <__floatsisf+0x54>
    416c:	9e e8       	ldi	r25, 0x8E	; 142
    416e:	87 2f       	mov	r24, r23
    4170:	76 2f       	mov	r23, r22
    4172:	05 c0       	rjmp	.+10     	; 0x417e <__floatsisf+0x5e>
    4174:	66 23       	and	r22, r22
    4176:	71 f0       	breq	.+28     	; 0x4194 <__floatsisf+0x74>
    4178:	96 e8       	ldi	r25, 0x86	; 134
    417a:	86 2f       	mov	r24, r22
    417c:	70 e0       	ldi	r23, 0x00	; 0
    417e:	60 e0       	ldi	r22, 0x00	; 0
    4180:	2a f0       	brmi	.+10     	; 0x418c <__floatsisf+0x6c>
    4182:	9a 95       	dec	r25
    4184:	66 0f       	add	r22, r22
    4186:	77 1f       	adc	r23, r23
    4188:	88 1f       	adc	r24, r24
    418a:	da f7       	brpl	.-10     	; 0x4182 <__floatsisf+0x62>
    418c:	88 0f       	add	r24, r24
    418e:	96 95       	lsr	r25
    4190:	87 95       	ror	r24
    4192:	97 f9       	bld	r25, 7
    4194:	08 95       	ret

00004196 <__fp_cmp>:
    4196:	99 0f       	add	r25, r25
    4198:	00 08       	sbc	r0, r0
    419a:	55 0f       	add	r21, r21
    419c:	aa 0b       	sbc	r26, r26
    419e:	e0 e8       	ldi	r30, 0x80	; 128
    41a0:	fe ef       	ldi	r31, 0xFE	; 254
    41a2:	16 16       	cp	r1, r22
    41a4:	17 06       	cpc	r1, r23
    41a6:	e8 07       	cpc	r30, r24
    41a8:	f9 07       	cpc	r31, r25
    41aa:	c0 f0       	brcs	.+48     	; 0x41dc <__fp_cmp+0x46>
    41ac:	12 16       	cp	r1, r18
    41ae:	13 06       	cpc	r1, r19
    41b0:	e4 07       	cpc	r30, r20
    41b2:	f5 07       	cpc	r31, r21
    41b4:	98 f0       	brcs	.+38     	; 0x41dc <__fp_cmp+0x46>
    41b6:	62 1b       	sub	r22, r18
    41b8:	73 0b       	sbc	r23, r19
    41ba:	84 0b       	sbc	r24, r20
    41bc:	95 0b       	sbc	r25, r21
    41be:	39 f4       	brne	.+14     	; 0x41ce <__fp_cmp+0x38>
    41c0:	0a 26       	eor	r0, r26
    41c2:	61 f0       	breq	.+24     	; 0x41dc <__fp_cmp+0x46>
    41c4:	23 2b       	or	r18, r19
    41c6:	24 2b       	or	r18, r20
    41c8:	25 2b       	or	r18, r21
    41ca:	21 f4       	brne	.+8      	; 0x41d4 <__fp_cmp+0x3e>
    41cc:	08 95       	ret
    41ce:	0a 26       	eor	r0, r26
    41d0:	09 f4       	brne	.+2      	; 0x41d4 <__fp_cmp+0x3e>
    41d2:	a1 40       	sbci	r26, 0x01	; 1
    41d4:	a6 95       	lsr	r26
    41d6:	8f ef       	ldi	r24, 0xFF	; 255
    41d8:	81 1d       	adc	r24, r1
    41da:	81 1d       	adc	r24, r1
    41dc:	08 95       	ret

000041de <__fp_inf>:
    41de:	97 f9       	bld	r25, 7
    41e0:	9f 67       	ori	r25, 0x7F	; 127
    41e2:	80 e8       	ldi	r24, 0x80	; 128
    41e4:	70 e0       	ldi	r23, 0x00	; 0
    41e6:	60 e0       	ldi	r22, 0x00	; 0
    41e8:	08 95       	ret

000041ea <__fp_nan>:
    41ea:	9f ef       	ldi	r25, 0xFF	; 255
    41ec:	80 ec       	ldi	r24, 0xC0	; 192
    41ee:	08 95       	ret

000041f0 <__fp_pscA>:
    41f0:	00 24       	eor	r0, r0
    41f2:	0a 94       	dec	r0
    41f4:	16 16       	cp	r1, r22
    41f6:	17 06       	cpc	r1, r23
    41f8:	18 06       	cpc	r1, r24
    41fa:	09 06       	cpc	r0, r25
    41fc:	08 95       	ret

000041fe <__fp_pscB>:
    41fe:	00 24       	eor	r0, r0
    4200:	0a 94       	dec	r0
    4202:	12 16       	cp	r1, r18
    4204:	13 06       	cpc	r1, r19
    4206:	14 06       	cpc	r1, r20
    4208:	05 06       	cpc	r0, r21
    420a:	08 95       	ret

0000420c <__fp_round>:
    420c:	09 2e       	mov	r0, r25
    420e:	03 94       	inc	r0
    4210:	00 0c       	add	r0, r0
    4212:	11 f4       	brne	.+4      	; 0x4218 <__fp_round+0xc>
    4214:	88 23       	and	r24, r24
    4216:	52 f0       	brmi	.+20     	; 0x422c <__fp_round+0x20>
    4218:	bb 0f       	add	r27, r27
    421a:	40 f4       	brcc	.+16     	; 0x422c <__fp_round+0x20>
    421c:	bf 2b       	or	r27, r31
    421e:	11 f4       	brne	.+4      	; 0x4224 <__fp_round+0x18>
    4220:	60 ff       	sbrs	r22, 0
    4222:	04 c0       	rjmp	.+8      	; 0x422c <__fp_round+0x20>
    4224:	6f 5f       	subi	r22, 0xFF	; 255
    4226:	7f 4f       	sbci	r23, 0xFF	; 255
    4228:	8f 4f       	sbci	r24, 0xFF	; 255
    422a:	9f 4f       	sbci	r25, 0xFF	; 255
    422c:	08 95       	ret

0000422e <__fp_split3>:
    422e:	57 fd       	sbrc	r21, 7
    4230:	90 58       	subi	r25, 0x80	; 128
    4232:	44 0f       	add	r20, r20
    4234:	55 1f       	adc	r21, r21
    4236:	59 f0       	breq	.+22     	; 0x424e <__fp_splitA+0x10>
    4238:	5f 3f       	cpi	r21, 0xFF	; 255
    423a:	71 f0       	breq	.+28     	; 0x4258 <__fp_splitA+0x1a>
    423c:	47 95       	ror	r20

0000423e <__fp_splitA>:
    423e:	88 0f       	add	r24, r24
    4240:	97 fb       	bst	r25, 7
    4242:	99 1f       	adc	r25, r25
    4244:	61 f0       	breq	.+24     	; 0x425e <__fp_splitA+0x20>
    4246:	9f 3f       	cpi	r25, 0xFF	; 255
    4248:	79 f0       	breq	.+30     	; 0x4268 <__fp_splitA+0x2a>
    424a:	87 95       	ror	r24
    424c:	08 95       	ret
    424e:	12 16       	cp	r1, r18
    4250:	13 06       	cpc	r1, r19
    4252:	14 06       	cpc	r1, r20
    4254:	55 1f       	adc	r21, r21
    4256:	f2 cf       	rjmp	.-28     	; 0x423c <__fp_split3+0xe>
    4258:	46 95       	lsr	r20
    425a:	f1 df       	rcall	.-30     	; 0x423e <__fp_splitA>
    425c:	08 c0       	rjmp	.+16     	; 0x426e <__fp_splitA+0x30>
    425e:	16 16       	cp	r1, r22
    4260:	17 06       	cpc	r1, r23
    4262:	18 06       	cpc	r1, r24
    4264:	99 1f       	adc	r25, r25
    4266:	f1 cf       	rjmp	.-30     	; 0x424a <__fp_splitA+0xc>
    4268:	86 95       	lsr	r24
    426a:	71 05       	cpc	r23, r1
    426c:	61 05       	cpc	r22, r1
    426e:	08 94       	sec
    4270:	08 95       	ret

00004272 <__fp_zero>:
    4272:	e8 94       	clt

00004274 <__fp_szero>:
    4274:	bb 27       	eor	r27, r27
    4276:	66 27       	eor	r22, r22
    4278:	77 27       	eor	r23, r23
    427a:	cb 01       	movw	r24, r22
    427c:	97 f9       	bld	r25, 7
    427e:	08 95       	ret

00004280 <__gesf2>:
    4280:	0e 94 cb 20 	call	0x4196	; 0x4196 <__fp_cmp>
    4284:	08 f4       	brcc	.+2      	; 0x4288 <__gesf2+0x8>
    4286:	8f ef       	ldi	r24, 0xFF	; 255
    4288:	08 95       	ret

0000428a <__mulsf3>:
    428a:	0e 94 58 21 	call	0x42b0	; 0x42b0 <__mulsf3x>
    428e:	0c 94 06 21 	jmp	0x420c	; 0x420c <__fp_round>
    4292:	0e 94 f8 20 	call	0x41f0	; 0x41f0 <__fp_pscA>
    4296:	38 f0       	brcs	.+14     	; 0x42a6 <__mulsf3+0x1c>
    4298:	0e 94 ff 20 	call	0x41fe	; 0x41fe <__fp_pscB>
    429c:	20 f0       	brcs	.+8      	; 0x42a6 <__mulsf3+0x1c>
    429e:	95 23       	and	r25, r21
    42a0:	11 f0       	breq	.+4      	; 0x42a6 <__mulsf3+0x1c>
    42a2:	0c 94 ef 20 	jmp	0x41de	; 0x41de <__fp_inf>
    42a6:	0c 94 f5 20 	jmp	0x41ea	; 0x41ea <__fp_nan>
    42aa:	11 24       	eor	r1, r1
    42ac:	0c 94 3a 21 	jmp	0x4274	; 0x4274 <__fp_szero>

000042b0 <__mulsf3x>:
    42b0:	0e 94 17 21 	call	0x422e	; 0x422e <__fp_split3>
    42b4:	70 f3       	brcs	.-36     	; 0x4292 <__mulsf3+0x8>

000042b6 <__mulsf3_pse>:
    42b6:	95 9f       	mul	r25, r21
    42b8:	c1 f3       	breq	.-16     	; 0x42aa <__mulsf3+0x20>
    42ba:	95 0f       	add	r25, r21
    42bc:	50 e0       	ldi	r21, 0x00	; 0
    42be:	55 1f       	adc	r21, r21
    42c0:	62 9f       	mul	r22, r18
    42c2:	f0 01       	movw	r30, r0
    42c4:	72 9f       	mul	r23, r18
    42c6:	bb 27       	eor	r27, r27
    42c8:	f0 0d       	add	r31, r0
    42ca:	b1 1d       	adc	r27, r1
    42cc:	63 9f       	mul	r22, r19
    42ce:	aa 27       	eor	r26, r26
    42d0:	f0 0d       	add	r31, r0
    42d2:	b1 1d       	adc	r27, r1
    42d4:	aa 1f       	adc	r26, r26
    42d6:	64 9f       	mul	r22, r20
    42d8:	66 27       	eor	r22, r22
    42da:	b0 0d       	add	r27, r0
    42dc:	a1 1d       	adc	r26, r1
    42de:	66 1f       	adc	r22, r22
    42e0:	82 9f       	mul	r24, r18
    42e2:	22 27       	eor	r18, r18
    42e4:	b0 0d       	add	r27, r0
    42e6:	a1 1d       	adc	r26, r1
    42e8:	62 1f       	adc	r22, r18
    42ea:	73 9f       	mul	r23, r19
    42ec:	b0 0d       	add	r27, r0
    42ee:	a1 1d       	adc	r26, r1
    42f0:	62 1f       	adc	r22, r18
    42f2:	83 9f       	mul	r24, r19
    42f4:	a0 0d       	add	r26, r0
    42f6:	61 1d       	adc	r22, r1
    42f8:	22 1f       	adc	r18, r18
    42fa:	74 9f       	mul	r23, r20
    42fc:	33 27       	eor	r19, r19
    42fe:	a0 0d       	add	r26, r0
    4300:	61 1d       	adc	r22, r1
    4302:	23 1f       	adc	r18, r19
    4304:	84 9f       	mul	r24, r20
    4306:	60 0d       	add	r22, r0
    4308:	21 1d       	adc	r18, r1
    430a:	82 2f       	mov	r24, r18
    430c:	76 2f       	mov	r23, r22
    430e:	6a 2f       	mov	r22, r26
    4310:	11 24       	eor	r1, r1
    4312:	9f 57       	subi	r25, 0x7F	; 127
    4314:	50 40       	sbci	r21, 0x00	; 0
    4316:	9a f0       	brmi	.+38     	; 0x433e <__mulsf3_pse+0x88>
    4318:	f1 f0       	breq	.+60     	; 0x4356 <__mulsf3_pse+0xa0>
    431a:	88 23       	and	r24, r24
    431c:	4a f0       	brmi	.+18     	; 0x4330 <__mulsf3_pse+0x7a>
    431e:	ee 0f       	add	r30, r30
    4320:	ff 1f       	adc	r31, r31
    4322:	bb 1f       	adc	r27, r27
    4324:	66 1f       	adc	r22, r22
    4326:	77 1f       	adc	r23, r23
    4328:	88 1f       	adc	r24, r24
    432a:	91 50       	subi	r25, 0x01	; 1
    432c:	50 40       	sbci	r21, 0x00	; 0
    432e:	a9 f7       	brne	.-22     	; 0x431a <__mulsf3_pse+0x64>
    4330:	9e 3f       	cpi	r25, 0xFE	; 254
    4332:	51 05       	cpc	r21, r1
    4334:	80 f0       	brcs	.+32     	; 0x4356 <__mulsf3_pse+0xa0>
    4336:	0c 94 ef 20 	jmp	0x41de	; 0x41de <__fp_inf>
    433a:	0c 94 3a 21 	jmp	0x4274	; 0x4274 <__fp_szero>
    433e:	5f 3f       	cpi	r21, 0xFF	; 255
    4340:	e4 f3       	brlt	.-8      	; 0x433a <__mulsf3_pse+0x84>
    4342:	98 3e       	cpi	r25, 0xE8	; 232
    4344:	d4 f3       	brlt	.-12     	; 0x433a <__mulsf3_pse+0x84>
    4346:	86 95       	lsr	r24
    4348:	77 95       	ror	r23
    434a:	67 95       	ror	r22
    434c:	b7 95       	ror	r27
    434e:	f7 95       	ror	r31
    4350:	e7 95       	ror	r30
    4352:	9f 5f       	subi	r25, 0xFF	; 255
    4354:	c1 f7       	brne	.-16     	; 0x4346 <__mulsf3_pse+0x90>
    4356:	fe 2b       	or	r31, r30
    4358:	88 0f       	add	r24, r24
    435a:	91 1d       	adc	r25, r1
    435c:	96 95       	lsr	r25
    435e:	87 95       	ror	r24
    4360:	97 f9       	bld	r25, 7
    4362:	08 95       	ret

00004364 <__tablejump2__>:
    4364:	ee 0f       	add	r30, r30
    4366:	ff 1f       	adc	r31, r31
    4368:	88 1f       	adc	r24, r24
    436a:	8b bf       	out	0x3b, r24	; 59
    436c:	07 90       	elpm	r0, Z+
    436e:	f6 91       	elpm	r31, Z
    4370:	e0 2d       	mov	r30, r0
    4372:	19 94       	eijmp

00004374 <memcpy>:
    4374:	fb 01       	movw	r30, r22
    4376:	dc 01       	movw	r26, r24
    4378:	02 c0       	rjmp	.+4      	; 0x437e <memcpy+0xa>
    437a:	01 90       	ld	r0, Z+
    437c:	0d 92       	st	X+, r0
    437e:	41 50       	subi	r20, 0x01	; 1
    4380:	50 40       	sbci	r21, 0x00	; 0
    4382:	d8 f7       	brcc	.-10     	; 0x437a <memcpy+0x6>
    4384:	08 95       	ret

00004386 <memset>:
    4386:	dc 01       	movw	r26, r24
    4388:	01 c0       	rjmp	.+2      	; 0x438c <memset+0x6>
    438a:	6d 93       	st	X+, r22
    438c:	41 50       	subi	r20, 0x01	; 1
    438e:	50 40       	sbci	r21, 0x00	; 0
    4390:	e0 f7       	brcc	.-8      	; 0x438a <memset+0x4>
    4392:	08 95       	ret

00004394 <__itoa_ncheck>:
    4394:	bb 27       	eor	r27, r27
    4396:	4a 30       	cpi	r20, 0x0A	; 10
    4398:	31 f4       	brne	.+12     	; 0x43a6 <__itoa_ncheck+0x12>
    439a:	99 23       	and	r25, r25
    439c:	22 f4       	brpl	.+8      	; 0x43a6 <__itoa_ncheck+0x12>
    439e:	bd e2       	ldi	r27, 0x2D	; 45
    43a0:	90 95       	com	r25
    43a2:	81 95       	neg	r24
    43a4:	9f 4f       	sbci	r25, 0xFF	; 255
    43a6:	0c 94 d6 21 	jmp	0x43ac	; 0x43ac <__utoa_common>

000043aa <__utoa_ncheck>:
    43aa:	bb 27       	eor	r27, r27

000043ac <__utoa_common>:
    43ac:	fb 01       	movw	r30, r22
    43ae:	55 27       	eor	r21, r21
    43b0:	aa 27       	eor	r26, r26
    43b2:	88 0f       	add	r24, r24
    43b4:	99 1f       	adc	r25, r25
    43b6:	aa 1f       	adc	r26, r26
    43b8:	a4 17       	cp	r26, r20
    43ba:	10 f0       	brcs	.+4      	; 0x43c0 <__utoa_common+0x14>
    43bc:	a4 1b       	sub	r26, r20
    43be:	83 95       	inc	r24
    43c0:	50 51       	subi	r21, 0x10	; 16
    43c2:	b9 f7       	brne	.-18     	; 0x43b2 <__utoa_common+0x6>
    43c4:	a0 5d       	subi	r26, 0xD0	; 208
    43c6:	aa 33       	cpi	r26, 0x3A	; 58
    43c8:	08 f0       	brcs	.+2      	; 0x43cc <__utoa_common+0x20>
    43ca:	a9 5d       	subi	r26, 0xD9	; 217
    43cc:	a1 93       	st	Z+, r26
    43ce:	00 97       	sbiw	r24, 0x00	; 0
    43d0:	79 f7       	brne	.-34     	; 0x43b0 <__utoa_common+0x4>
    43d2:	b1 11       	cpse	r27, r1
    43d4:	b1 93       	st	Z+, r27
    43d6:	11 92       	st	Z+, r1
    43d8:	cb 01       	movw	r24, r22
    43da:	0c 94 ef 21 	jmp	0x43de	; 0x43de <strrev>

000043de <strrev>:
    43de:	dc 01       	movw	r26, r24
    43e0:	fc 01       	movw	r30, r24
    43e2:	67 2f       	mov	r22, r23
    43e4:	71 91       	ld	r23, Z+
    43e6:	77 23       	and	r23, r23
    43e8:	e1 f7       	brne	.-8      	; 0x43e2 <strrev+0x4>
    43ea:	32 97       	sbiw	r30, 0x02	; 2
    43ec:	04 c0       	rjmp	.+8      	; 0x43f6 <strrev+0x18>
    43ee:	7c 91       	ld	r23, X
    43f0:	6d 93       	st	X+, r22
    43f2:	70 83       	st	Z, r23
    43f4:	62 91       	ld	r22, -Z
    43f6:	ae 17       	cp	r26, r30
    43f8:	bf 07       	cpc	r27, r31
    43fa:	c8 f3       	brcs	.-14     	; 0x43ee <strrev+0x10>
    43fc:	08 95       	ret

000043fe <_exit>:
    43fe:	f8 94       	cli

00004400 <__stop_program>:
    4400:	ff cf       	rjmp	.-2      	; 0x4400 <__stop_program>
